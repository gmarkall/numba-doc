
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>Adding Type Inference for External Code &mdash; numba 0.12.0 documentation</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    
<link rel="stylesheet" href="_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" href="_static/css/bootstrap.min.css" type="text/css" />
<link rel="stylesheet" href="_static/css/font-awesome.min.css">
<!--[if IE 7]>
<link rel="stylesheet" href="_static/css/font-awesome-ie7.min.css">
<![endif]-->
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
}
</style>
<link rel="stylesheet" href="_static/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="_static/pygments.css" type="text/css" />
<link rel="stylesheet" href="_static/css/bootstrap-responsive.min.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    '',
            VERSION:     '0.12.0',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
<script type="text/javascript" src="_static/js/jquery.min.js"></script>
<script type="text/javascript" src="_static/underscore.js"></script>
<script type="text/javascript" src="_static/doctools.js"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="_static/js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    $('.show-sidebar').click(function(e) {
       e.preventDefault();
       if ($(".show-sidebar").html() == "Open Table Of Contents") {
          $('.for-mobile').removeClass('hidden-phone');
          $(".show-sidebar").html("Close Table Of Contents");
       } else {
          $(".show-sidebar").html("Open Table Of Contents");
       }
    });
  });
</script>
    <link rel="top" title="numba 0.12.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="index.html">numba 0.12.0 documentation</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right">
              
                <li>
                <a href="genindex.html" title="General Index" accesskey="I">index</a>
                </li>
                <li>
                <a href="py-modindex.html" title="Python Module Index" >modules</a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container-fluid">


      
      <div class="row-fluid hidden-desktop hidden-tablet">
      
<div class="span3 ">
  <a class="visible-phone btn btn-small show-sidebar" data-toggle="collapse" data-target=".for-mobile">Open Table Of Contents</a>
  <div class="for-mobile sidebar hidden-phone">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Adding Type Inference for External Code</a><ul>
<li><a class="reference internal" href="#type-functions">Type Functions</a><ul>
<li><a class="reference internal" href="#simple-signatures">Simple Signatures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parametric-polymorphism">Parametric Polymorphism</a></li>
<li><a class="reference internal" href="#registering-unbound-methods">Registering Unbound Methods</a></li>
<li><a class="reference internal" href="#future-directions">Future Directions</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/type_inference.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div>
      </div>
      

      <!-- row -->
      <div class="row-fluid">
         
<div class="span3 visible-desktop visible-tablet">
  <div class=" sidebar hidden-phone">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Adding Type Inference for External Code</a><ul>
<li><a class="reference internal" href="#type-functions">Type Functions</a><ul>
<li><a class="reference internal" href="#simple-signatures">Simple Signatures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parametric-polymorphism">Parametric Polymorphism</a></li>
<li><a class="reference internal" href="#registering-unbound-methods">Registering Unbound Methods</a></li>
<li><a class="reference internal" href="#future-directions">Future Directions</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/type_inference.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        

        <div class="span9">
          <div class="document">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="adding-type-inference-for-external-code">
<span id="type-inference"></span><h1>Adding Type Inference for External Code<a class="headerlink" href="#adding-type-inference-for-external-code" title="Permalink to this headline">¶</a></h1>
<p>Users can add type inference for non-numba functions, to specify to
numba what the result of an operation will look like. This can make
numba code much more efficient by knowing the lower-level types.</p>
<div class="section" id="type-functions">
<h2>Type Functions<a class="headerlink" href="#type-functions" title="Permalink to this headline">¶</a></h2>
<p>Users can write type functions to tell Numba what the return type of
a certain function call in numba code will be. The return type may
be always the same, or it may depend on the input types in a simple
or complicated way.</p>
<p>Below we will describe ways to handle all these cases.</p>
<div class="section" id="simple-signatures">
<h3>Simple Signatures<a class="headerlink" href="#simple-signatures" title="Permalink to this headline">¶</a></h3>
<p>Simple signatures can be easily handled by registering a callable with
a static signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">register_callable</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="o">*</span>

<span class="nd">@register_callable</span><span class="p">(</span><span class="n">double</span><span class="p">(</span><span class="n">double</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>This specifies that the function takes only a double and returns a double.</p>
<p>If a function is statically polymorphic, a typeset can be used to
represent a variety of inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numba</span> <span class="kn">as</span> <span class="nn">nb</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="o">*</span>

<span class="nd">@nb.register_callable</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">numeric</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">numba.numeric</span></tt> represents the set of numeric types. The set is
then bound in a similar way to Cython&#8217;s fused types, in that the argument
types instantiate the sets to concrete types. This means the signature above
allows signatures like <tt class="docutils literal"><span class="pre">double(double)</span></tt> and <tt class="docutils literal"><span class="pre">int_(int_)</span></tt>, but not for
instance <tt class="docutils literal"><span class="pre">double(int)</span></tt>.</p>
<p>Type sets can be created explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">signatures</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">typeset</span><span class="p">(</span><span class="n">object_</span><span class="p">(</span><span class="n">object_</span><span class="p">),</span> <span class="n">numeric</span><span class="p">(</span><span class="n">numeric</span><span class="p">))</span>

<span class="nd">@numba.register_callable</span><span class="p">(</span><span class="n">signatures</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="parametric-polymorphism">
<h2>Parametric Polymorphism<a class="headerlink" href="#parametric-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Type sets are fine for small sets, but not general enough for a large
or infinite type universe. Instead, we allow parametric polymorphism through
simple templates and type functions (functions that return the type at compile
time given the input types). For an introduction to templates
we refer the reader to <a href="#id1"><span class="problematic" id="id2">templates_</span></a>.</p>
<p>Templates can be used as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># create a type variable that will be bound by an argument type</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">template</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>

<span class="nd">@numba.register_callable</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">[:]))</span>
<span class="k">def</span> <span class="nf">sum_1d</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>More general type expressions are listed under <a href="#id3"><span class="problematic" id="id4">templates_</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Templates for user-based type inference is not yet implemented.</p>
</div>
<p>For full control a user can write an explicit function that performs the type
inference based on the input types. The input types are passed in as objects
and inferred from the function&#8217;s signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">typesystem</span>
<span class="kn">from</span> <span class="nn">numba.typesystem</span> <span class="kn">import</span> <span class="n">get_type</span>

<span class="k">def</span> <span class="nf">infer_reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">dtype_type</span> <span class="o">=</span> <span class="n">get_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">static_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Return the scalar type</span>
        <span class="k">return</span> <span class="n">dtype_type</span>

    <span class="k">if</span> <span class="n">dtype_type</span><span class="p">:</span>
        <span class="c"># Handle the axis parameter</span>
        <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_tuple</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_sized</span><span class="p">:</span>
            <span class="c"># axis=(tuple with a constant size)</span>
            <span class="k">return</span> <span class="n">typesystem</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dtype_type</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">axis</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_int</span><span class="p">:</span>
            <span class="c"># axis=1</span>
            <span class="k">return</span> <span class="n">typesystem</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dtype_type</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># axis=(something unknown)</span>
            <span class="k">return</span> <span class="n">object_</span>

<span class="n">register_inferer</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="n">infer_reduce</span><span class="p">)</span>    <span class="c"># Register type inference for np.sum</span>
<span class="n">register_inferer</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&#39;prod&#39;</span><span class="p">,</span> <span class="n">infer_reduce</span><span class="p">)</span>   <span class="c"># Register type inference for np.prod</span>
</pre></div>
</div>
<p>The above works through introspection of the function using the <tt class="docutils literal"><span class="pre">inspect</span></tt> module. A call
in the user code to <tt class="docutils literal"><span class="pre">np.sum</span></tt> or <tt class="docutils literal"><span class="pre">np.prod</span></tt> will now ask the above function to resolve its
type at Numba compile time, passing in the types representing the arguments, or None
when absent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Numba code</span>
<span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>              <span class="c"># =&gt; infer_reduce(a=double[:, :]), axis=None, dtype=None, out=None)</span>
<span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c"># =&gt; infer_reduce(a=double[:, :, :]), axis=tuple(base_type=int_, size=2),</span>
                       <span class="c">#                 dtype=None, out=None)</span>
</pre></div>
</div>
<p>A shorthand function to register type functions is provided by <tt class="docutils literal"><span class="pre">numba.register</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@numba.register</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This retrieves <tt class="docutils literal"><span class="pre">np.sum</span></tt> based on the name of the type inferring function (hence it must be called
<tt class="docutils literal"><span class="pre">sum</span></tt>).</p>
</div>
<div class="section" id="registering-unbound-methods">
<h2>Registering Unbound Methods<a class="headerlink" href="#registering-unbound-methods" title="Permalink to this headline">¶</a></h2>
<p>Unbound methods are transient, and hence can not be registered by value. Instead we register
a dotted path starting at a value, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numba</span><span class="o">.</span><span class="n">register_unbound</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="p">,</span> <span class="s">&quot;reduce&quot;</span><span class="p">,</span> <span class="n">infer_reduce</span><span class="p">)</span>
</pre></div>
</div>
<p>To allow type inference for <tt class="docutils literal"><span class="pre">np.add.reduce()</span></tt>. The first string specifies the module (<tt class="docutils literal"><span class="pre">np</span></tt>), the
second the object (<tt class="docutils literal"><span class="pre">&quot;add&quot;</span></tt>), the third the dotted path (<tt class="docutils literal"><span class="pre">&quot;reduce&quot;</span></tt>) and the last the type
function (<tt class="docutils literal"><span class="pre">infer_reduce</span></tt>).</p>
</div>
<div class="section" id="future-directions">
<h2>Future Directions<a class="headerlink" href="#future-directions" title="Permalink to this headline">¶</a></h2>
<p>The code above is clearly very verbose, which is partly due to the generality of the <tt class="docutils literal"><span class="pre">sum</span></tt>
signature. In the future we hope to expose a more declarative way to specify parametrically
polymorphic signatures. Perhaps something like:</p>
<div class="highlight-python"><pre>sum(a)                                              =&gt; a
sum(array(dtype, ndim), axis=integral)              =&gt; array(dtype, ndim - 1)
sum(array(dtype, ndim), axis=tuple(integral, size)) =&gt; array(dtype, ndim - size)
sum(in, axis=axis, out=out)                         =&gt; sum(out, axis=axis)
sum(_, _)                                           =&gt; object_</pre>
</div>
</div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
        
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row-fluid">
<div class="related navbar ">
  <div class="navbar-inner">
    <ul class="nav pull-right">
      
        <li><a href="genindex.html" title="General Index" >index</a></li>
        <li><a href="py-modindex.html" title="Python Module Index" >modules</a></li>
        <li><a href="index.html">numba 0.12.0 documentation</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer>
          &copy; Copyright 2012-2013, Continuum Analytics.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>