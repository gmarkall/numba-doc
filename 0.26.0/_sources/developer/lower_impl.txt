Lowering Registry
=================
Lower Impl ``'delitem'``
------------------------

signature `(List, SliceType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``setitem_list`` `numba/targets/listobj.py` lines 509-535

.. code-block:: python

    @lower_builtin('delitem', types.List, types.SliceType)
    def setitem_list(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        slice = context.make_helper(builder, sig.args[1], args[1])

        slicing.guard_invalid_slice(context, builder, sig.args[1], slice)
        inst.fix_slice(slice)

        slice_len = slicing.get_slice_length(builder, slice)

        zero = ir.Constant(slice_len.type, 0)
        one = ir.Constant(slice_len.type, 1)

        with builder.if_then(builder.icmp_signed('!=', slice.step, one), likely=False):
            msg = "unsupported del list[start:stop:step] with step != 1"
            context.call_conv.return_user_exc(builder, NotImplementedError, (msg,))

        # Compute the real stop, e.g. for dest[2:0]
        start = slice.start
        real_stop = builder.add(start, slice_len)
        # Size of the list tail, after the end of slice
        tail_size = builder.sub(inst.size, real_stop)
        inst.move(start, real_stop, tail_size)
        inst.resize(builder.sub(inst.size, slice_len))

        return context.get_dummy_value()


Lower Impl ``numpy.core.numeric.ones_like``
-------------------------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_ones_like_nd`` `numba/targets/arrayobj.py` lines 2810-2821

.. code-block:: python

    @lower_builtin(numpy.ones_like, types.Any)
    def numpy_ones_like_nd(context, builder, sig, args):

        def ones_like(arr):
            arr = numpy.empty_like(arr)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = 1
            return arr

        res = context.compile_internal(builder, ones_like, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_ones_like_dtype_nd`` `numba/targets/arrayobj.py` lines 2822-2833

.. code-block:: python

    @lower_builtin(numpy.ones_like, types.Any, types.DTypeSpec)
    def numpy_ones_like_dtype_nd(context, builder, sig, args):

        def ones_like(arr, dtype):
            arr = numpy.empty_like(arr, dtype)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = 1
            return arr

        res = context.compile_internal(builder, ones_like, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``cmath.cos``
------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``cos_impl`` `numba/targets/cmathimpl.py` lines 259-267

.. code-block:: python

    @lower(cmath.cos, types.Complex)
    def cos_impl(context, builder, sig, args):
        def cos_impl(z):
            """cmath.cos(z) = cmath.cosh(z j)"""
            return cmath.cosh(complex(-z.imag, z.real))

        res = context.compile_internal(builder, cos_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``<ufunc 'rint'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.numeric.full``
--------------------------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_full_nd`` `numba/targets/arrayobj.py` lines 2733-2744

.. code-block:: python

    @lower_builtin(numpy.full, types.Any, types.Any)
    def numpy_full_nd(context, builder, sig, args):

        def full(shape, value):
            arr = numpy.empty(shape)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = value
            return arr

        res = context.compile_internal(builder, full, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(any, any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_full_dtype_nd`` `numba/targets/arrayobj.py` lines 2745-2756

.. code-block:: python

    @lower_builtin(numpy.full, types.Any, types.Any, types.DTypeSpec)
    def numpy_full_dtype_nd(context, builder, sig, args):

        def full(shape, value, dtype):
            arr = numpy.empty(shape, dtype)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = value
            return arr

        res = context.compile_internal(builder, full, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'random.randrange'``
---------------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``randrange_impl_1`` `numba/targets/randomimpl.py` lines 334-341

.. code-block:: python

    @lower("random.randrange", types.Integer)
    def randrange_impl_1(context, builder, sig, args):
        stop, = args
        start = ir.Constant(stop.type, 0)
        step = ir.Constant(stop.type, 1)
        res = _randrange_impl(context, builder, start, stop, step, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``randrange_impl_2`` `numba/targets/randomimpl.py` lines 342-348

.. code-block:: python

    @lower("random.randrange", types.Integer, types.Integer)
    def randrange_impl_2(context, builder, sig, args):
        start, stop = args
        step = ir.Constant(start.type, 1)
        res = _randrange_impl(context, builder, start, stop, step, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``randrange_impl_3`` `numba/targets/randomimpl.py` lines 349-355

.. code-block:: python

    @lower("random.randrange", types.Integer,
               types.Integer, types.Integer)
    def randrange_impl_3(context, builder, sig, args):
        start, stop, step = args
        res = _randrange_impl(context, builder, start, stop, step, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'complex.conjugate'``
----------------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``complex_conjugate_impl`` `numba/targets/numbers.py` lines 781-788

.. code-block:: python

    @lower_builtin("complex.conjugate", types.Complex)
    def complex_conjugate_impl(context, builder, sig, args):
        from . import mathimpl
        z = context.make_complex(builder, sig.args[0], args[0])
        z.imag = mathimpl.negate_real(builder, z.imag)
        res = z._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``real_conjugate_impl`` `numba/targets/numbers.py` lines 796-798

.. code-block:: python

    def real_conjugate_impl(context, builder, sig, args):
        return impl_ret_untracked(context, builder, sig.return_type, args[0])


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``real_conjugate_impl`` `numba/targets/numbers.py` lines 796-798

.. code-block:: python

    def real_conjugate_impl(context, builder, sig, args):
        return impl_ret_untracked(context, builder, sig.return_type, args[0])


Lower Impl ``'is'``
-------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_is`` `numba/targets/arrayobj.py` lines 1737-1749

.. code-block:: python

    @lower_builtin('is', types.Array, types.Array)
    def array_is(context, builder, sig, args):
        aty, bty = sig.args
        if aty != bty:
            return cgutils.false_bit

        def array_is_impl(a, b):
            return (a.shape == b.shape and
                    a.strides == b.strides and
                    a.ctypes.data == b.ctypes.data)

        return context.compile_internal(builder, array_is_impl, sig, args)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``generic_is`` `numba/targets/builtins.py` lines 28-34

.. code-block:: python

    @lower_builtin('is', types.Any, types.Any)
    def generic_is(context, builder, sig, args):
        """
        Default implementation for `x is y`
        """
        return cgutils.false_bit


signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_is`` `numba/targets/listobj.py` lines 630-637

.. code-block:: python

    @lower_builtin('is', types.List, types.List)
    def list_is(context, builder, sig, args):
        a = ListInstance(context, builder, sig.args[0], args[0])
        b = ListInstance(context, builder, sig.args[1], args[1])
        ma = builder.ptrtoint(a.meminfo, cgutils.intp_t)
        mb = builder.ptrtoint(b.meminfo, cgutils.intp_t)
        return builder.icmp_signed('==', ma, mb)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_is`` `numba/targets/setobj.py` lines 1381-1388

.. code-block:: python

    @lower_builtin('is', types.Set, types.Set)
    def set_is(context, builder, sig, args):
        a = SetInstance(context, builder, sig.args[0], args[0])
        b = SetInstance(context, builder, sig.args[1], args[1])
        ma = builder.ptrtoint(a.meminfo, cgutils.intp_t)
        mb = builder.ptrtoint(b.meminfo, cgutils.intp_t)
        return builder.icmp_signed('==', ma, mb)


signature `(EnumMember, EnumMember)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``enum_is`` `numba/targets/enumimpl.py` lines 20-30

.. code-block:: python

    @lower_builtin('is', types.EnumMember, types.EnumMember)
    def enum_is(context, builder, sig, args):
        tu, tv = sig.args
        u, v = args
        if tu == tv:
            res = context.generic_compare(builder, "==",
                                          (tu.dtype, tv.dtype), (u, v))
        else:
            res = context.get_constant(sig.return_type, False)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(none, none)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``always_return_true_impl`` `numba/targets/optional.py` lines 9-11

.. code-block:: python

    def always_return_true_impl(context, builder, sig, args):
        return cgutils.true_bit


signature `(Optional, none)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``optional_is_none`` `numba/targets/optional.py` lines 17-35

.. code-block:: python

    def optional_is_none(context, builder, sig, args):
        """
        Check if an Optional value is invalid
        """
        [lty, rty] = sig.args
        [lval, rval] = args

        # Make sure None is on the right
        if lty == types.none:
            lty, rty = rty, lty
            lval, rval = rval, lval

        opt_type = lty
        opt_val = lval

        opt = context.make_helper(builder, opt_type, opt_val)
        res = builder.not_(cgutils.as_bool_bit(builder, opt.valid))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(none, Optional)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``optional_is_none`` `numba/targets/optional.py` lines 17-35

.. code-block:: python

    def optional_is_none(context, builder, sig, args):
        """
        Check if an Optional value is invalid
        """
        [lty, rty] = sig.args
        [lval, rval] = args

        # Make sure None is on the right
        if lty == types.none:
            lty, rty = rty, lty
            lval, rval = rval, lval

        opt_type = lty
        opt_val = lval

        opt = context.make_helper(builder, opt_type, opt_val)
        res = builder.not_(cgutils.as_bool_bit(builder, opt.valid))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'random.gauss'``
-----------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``gauss_impl`` `numba/targets/randomimpl.py` lines 206-211

.. code-block:: python

    @lower("random.gauss", types.Float, types.Float)
    @lower("random.normalvariate", types.Float, types.Float)
    def gauss_impl(context, builder, sig, args):
        res = _gauss_impl(context, builder, sig, args, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``numpy.core.numeric.full_like``
-------------------------------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_full_like_nd`` `numba/targets/arrayobj.py` lines 2758-2769

.. code-block:: python

    @lower_builtin(numpy.full_like, types.Any, types.Any)
    def numpy_full_like_nd(context, builder, sig, args):

        def full_like(arr, value):
            arr = numpy.empty_like(arr)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = value
            return arr

        res = context.compile_internal(builder, full_like, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(any, any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_full_like_nd`` `numba/targets/arrayobj.py` lines 2771-2782

.. code-block:: python

    @lower_builtin(numpy.full_like, types.Any, types.Any, types.DTypeSpec)
    def numpy_full_like_nd(context, builder, sig, args):

        def full_like(arr, value, dtype):
            arr = numpy.empty_like(arr, dtype)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = value
            return arr

        res = context.compile_internal(builder, full_like, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'sign'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.argmin``
--------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_argmin`` `numba/targets/arraymath.py` lines 203-252

.. code-block:: python

    @lower_builtin(numpy.argmin, types.Array)
    @lower_builtin("array.argmin", types.Array)
    def array_argmin(context, builder, sig, args):
        ty = sig.args[0].dtype
        # NOTE: Under Numpy < 1.10, argmin() is inconsistent with min() on NaT values:
        # https://github.com/numpy/numpy/issues/6030

        if (numpy_version >= (1, 10) and
            isinstance(ty, (types.NPDatetime, types.NPTimedelta))):
            # NaT is smaller than every other value, but it is
            # ignored as far as argmin() is concerned.
            nat = ty('NaT')

            def array_argmin_impl(arry):
                min_value = nat
                min_idx = 0
                it = arry.flat
                idx = 0
                for v in it:
                    if v != nat:
                        min_value = v
                        min_idx = idx
                        idx += 1
                        break
                    idx += 1

                for v in it:
                    if v != nat and v < min_value:
                        min_value = v
                        min_idx = idx
                    idx += 1
                return min_idx

        else:
            def array_argmin_impl(arry):
                for v in arry.flat:
                    min_value = v
                    min_idx = 0
                    break

                idx = 0
                for v in arry.flat:
                    if v < min_value:
                        min_value = v
                        min_idx = idx
                    idx += 1
                return min_idx
        res = context.compile_internal(builder, array_argmin_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``numpy.core.multiarray.vdot``
-----------------------------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``vdot`` `numba/targets/linalg.py` lines 332-341

.. code-block:: python

    @lower_builtin(numpy.vdot, types.Array, types.Array)
    def vdot(context, builder, sig, args):
        """
        np.vdot(a, b)
        """
        ensure_blas()

        with make_contiguous(context, builder, sig, args) as (sig, args):
            return dot_2_vv(context, builder, sig, args, conjugate=True)


Lower Impl ``math.copysign``
----------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``copysign_float_impl`` `numba/targets/mathimpl.py` lines 246-254

.. code-block:: python

    @lower(math.copysign, types.Float, types.Float)
    def copysign_float_impl(context, builder, sig, args):
        lty = args[0].type
        mod = builder.module
        fn = mod.get_or_insert_function(lc.Type.function(lty, (lty, lty)),
                                        'llvm.copysign.%s' % lty.intrinsic_name)
        res = builder.call(fn, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'signbit'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.multiarray.where``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_nonzero`` `numba/targets/arraymath.py` lines 693-751

.. code-block:: python

    @lower_builtin(numpy.nonzero, types.Array)
    @lower_builtin("array.nonzero", types.Array)
    @lower_builtin(numpy.where, types.Array)
    def array_nonzero(context, builder, sig, args):
        aryty = sig.args[0]
        # Return type is a N-tuple of 1D C-contiguous arrays
        retty = sig.return_type
        outaryty = retty.dtype
        ndim = aryty.ndim
        nouts = retty.count

        ary = make_array(aryty)(context, builder, args[0])
        shape = cgutils.unpack_tuple(builder, ary.shape)
        strides = cgutils.unpack_tuple(builder, ary.strides)
        data = ary.data
        layout = aryty.layout

        # First count the number of non-zero elements
        zero = context.get_constant(types.intp, 0)
        one = context.get_constant(types.intp, 1)
        count = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                builder.store(builder.add(builder.load(count), one), count)

        # Then allocate output arrays of the right size
        out_shape = (builder.load(count),)
        outs = [_empty_nd_impl(context, builder, outaryty, out_shape)._getvalue()
                for i in range(nouts)]
        outarys = [make_array(outaryty)(context, builder, out) for out in outs]
        out_datas = [out.data for out in outarys]

        # And fill them up
        index = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                # Store element indices in output arrays
                if not indices:
                    # For a 0-d array, store 0 in the unique output array
                    indices = (zero,)
                cur = builder.load(index)
                for i in range(nouts):
                    ptr = cgutils.get_item_pointer2(builder, out_datas[i],
                                                    out_shape, (),
                                                    'C', [cur])
                    store_item(context, builder, outaryty, indices[i], ptr)
                builder.store(builder.add(cur, one), index)

        tup = context.make_tuple(builder, sig.return_type, outs)
        return impl_ret_new_ref(context, builder, sig.return_type, tup)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``any_where`` `numba/targets/arraymath.py` lines 787-806

.. code-block:: python

    @lower_builtin(numpy.where, types.Any, types.Any, types.Any)
    def any_where(context, builder, sig, args):
        cond = sig.args[0]
        if isinstance(cond, types.Array):
            return array_where(context, builder, sig, args)

        def scalar_where_impl(cond, x, y):
            """
            np.where(scalar, scalar, scalar): return a 0-dim array
            """
            scal = x if cond else y
            # This is the equivalent of numpy.full_like(scal, scal),
            # for compatibility with Numpy < 1.8
            arr = numpy.empty_like(scal)
            arr[()] = scal
            return arr

        res = context.compile_internal(builder, scalar_where_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'set.add'``
------------------------

signature `(Set, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_add`` `numba/targets/setobj.py` lines 1155-1162

.. code-block:: python

    @lower_builtin("set.add", types.Set, types.Any)
    def set_add(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        item = args[1]
        inst.add(item)

        return context.get_dummy_value()


Lower Impl ``<ufunc 'sin'>``
----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'&'``
------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_intersection`` `numba/targets/setobj.py` lines 1281-1295

.. code-block:: python

    @lower_builtin("&", types.Set, types.Set)
    @lower_builtin("set.intersection", types.Set, types.Set)
    def set_intersection(context, builder, sig, args):
        def intersection_impl(a, b):
            if len(a) < len(b):
                s = a.copy()
                s.intersection_update(b)
                return s
            else:
                s = b.copy()
                s.intersection_update(a)
                return s

        return context.compile_internal(builder, intersection_impl, sig, args)


signature `(Boolean, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_and_impl`` `numba/targets/numbers.py` lines 308-315

.. code-block:: python

    def int_and_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.and_(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_and_impl`` `numba/targets/numbers.py` lines 308-315

.. code-block:: python

    def int_and_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.and_(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.uniform'``
----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``uniform_impl`` `numba/targets/randomimpl.py` lines 384-388

.. code-block:: python

    @lower("np.random.uniform", types.Float, types.Float)
    def uniform_impl(context, builder, sig, args):
        res = uniform_impl(context, builder, sig, args, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'array.var'``
--------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_var`` `numba/targets/arraymath.py` lines 119-134

.. code-block:: python

    @lower_builtin(numpy.var, types.Array)
    @lower_builtin("array.var", types.Array)
    def array_var(context, builder, sig, args):
        def array_var_impl(arr):
            # Compute the mean
            m = arr.mean()

            # Compute the sum of square diffs
            ssd = 0
            for v in numpy.nditer(arr):
                ssd += (v.item() - m) ** 2
            return ssd / arr.size

        res = context.compile_internal(builder, array_var_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``_operator.imul``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.core.fromnumeric.ravel``
-------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``np_ravel`` `numba/targets/arrayobj.py` lines 1274-1280

.. code-block:: python

    @lower_builtin(numpy.ravel, types.Array)
    def np_ravel(context, builder, sig, args):
        def np_ravel_impl(a):
            return a.ravel()

        return context.compile_internal(builder, np_ravel_impl, sig, args)


Lower Impl ``math.sin``
-----------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'sinh'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.standard_cauchy'``
------------------------------------------

signature `()`
~~~~~~~~~~~~~~

by ``cauchy_impl`` `numba/targets/randomimpl.py` lines 1071-1080

.. code-block:: python

    @lower("np.random.standard_cauchy")
    def cauchy_impl(context, builder, sig, args):
        _gauss = np.random.standard_normal

        def cauchy_impl():
            return _gauss() / _gauss()

        res = context.compile_internal(builder, cauchy_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``numpy.core.numeric.asfortranarray``
------------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_asfortranarray`` `numba/targets/arrayobj.py` lines 3091-3119

.. code-block:: python

    @lower_builtin(numpy.asfortranarray, types.Array)
    def array_asfortranarray(context, builder, sig, args):
        retty = sig.return_type
        aryty = sig.args[0]
        assert retty.layout == 'F'

        if aryty.ndim == 0:
            # 0-dim input => asfortranarray() returns a 1-dim array
            assert retty.ndim == 1
            ary = make_array(aryty)(context, builder, value=args[0])
            ret = make_array(retty)(context, builder)

            shape = context.get_constant(types.UniTuple(types.intp, 1), (1,))
            strides = context.make_tuple(builder,
                                         types.UniTuple(types.intp, 1),
                                         (ary.itemsize,))
            populate_array(ret, ary.data, shape, strides, ary.itemsize,
                           ary.meminfo, ary.parent)
            return impl_ret_borrowed(context, builder, retty, ret._getvalue())

        elif (retty.layout == aryty.layout
            or (aryty.ndim == 1 and aryty.layout in 'CF')):
            # 1-dim contiguous input => return the same array
            return impl_ret_borrowed(context, builder, retty, args[0])

        else:
            # Return a copy with the right layout
            return _array_copy(context, builder, sig, args)


Lower Impl ``'array.ravel'``
----------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_ravel`` `numba/targets/arrayobj.py` lines 1251-1272

.. code-block:: python

    @lower_builtin('array.ravel', types.Array)
    def array_ravel(context, builder, sig, args):
        # Only support no argument version (default order='C')
        def imp_nocopy(ary):
            """No copy version"""
            return ary.reshape(ary.size)

        def imp_copy(ary):
            """Copy version"""
            return ary.flatten()

        # If the input array is C layout already, use the nocopy version
        if sig.args[0].layout == 'C':
            imp = imp_nocopy
        # otherwise, use flatten under-the-hood
        else:
            imp = imp_copy

        res = context.compile_internal(builder, imp, sig, args)
        res = impl_ret_new_ref(context, builder, sig.return_type, res)
        return res


Lower Impl ``builtins.type``
----------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``type_impl`` `numba/targets/builtins.py` lines 263-269

.. code-block:: python

    @lower_builtin(type, types.Any)
    def type_impl(context, builder, sig, args):
        """
        One-argument type() builtin.
        """
        return context.get_dummy_value()


Lower Impl ``'list.extend'``
----------------------------

signature `(List, IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_extend`` `numba/targets/listobj.py` lines 774-788

.. code-block:: python

    @lower_builtin("list.extend", types.List, types.IterableType)
    def list_extend(context, builder, sig, args):
        if isinstance(sig.args[1], types.List):
            # Specialize for list operands, for speed.
            _list_extend_list(context, builder, sig, args)
            return context.get_dummy_value()

        def list_extend(lst, iterable):
            # Speed hack to avoid NRT refcount operations inside the loop
            meth = lst.append
            for v in iterable:
                meth(v)

        return context.compile_internal(builder, list_extend, sig, args)


Lower Impl ``<ufunc 'spacing'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.multiarray.empty_like``
-----------------------------------------------

signature `(any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_empty_like_nd`` `numba/targets/arrayobj.py` lines 2706-2712

.. code-block:: python

    @lower_builtin(numpy.empty_like, types.Any)
    @lower_builtin(numpy.empty_like, types.Any, types.DTypeSpec)
    def numpy_empty_like_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_like_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_empty_like_nd`` `numba/targets/arrayobj.py` lines 2706-2712

.. code-block:: python

    @lower_builtin(numpy.empty_like, types.Any)
    @lower_builtin(numpy.empty_like, types.Any, types.DTypeSpec)
    def numpy_empty_like_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_like_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


Lower Impl ``'np.random.hypergeometric'``
-----------------------------------------

signature `(Integer, Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``hypergeometric_impl`` `numba/targets/randomimpl.py` lines 873-897

.. code-block:: python

    @lower("np.random.hypergeometric", types.Integer,
               types.Integer, types.Integer)
    def hypergeometric_impl(context, builder, sig, args):
        _random = np.random.random
        _floor = math.floor

        def hypergeometric_impl(ngood, nbad, nsamples):
            """Numpy's algorithm for hypergeometric()."""
            d1 = nbad + ngood - nsamples
            d2 = float(min(nbad, ngood))

            Y = d2
            K = nsamples
            while Y > 0.0 and K > 0:
                Y -= _floor(_random() + Y / (d1 + K))
                K -= 1
            Z = int(d2 - Y)
            if ngood > nbad:
                return nsamples - Z
            else:
                return Z

        res = context.compile_internal(builder, hypergeometric_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'&='``
-------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_inplace`` `numba/targets/setobj.py` lines 1262-1267

.. code-block:: python

    @lower_builtin(op, types.Set, types.Set)
    def set_inplace(context, builder, sig, args, op_impl=op_impl):
        assert sig.return_type == sig.args[0]
        op_impl(context, builder, sig, args)
        return impl_ret_borrowed(context, builder, sig.args[0], args[0])


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``<ufunc 'sqrt'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.lgamma``
--------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.erfc``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.gamma``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``numpy.core.multiarray.empty``
------------------------------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_empty_nd`` `numba/targets/arrayobj.py` lines 2699-2705

.. code-block:: python

    @lower_builtin(numpy.empty, types.Any)
    @lower_builtin(numpy.empty, types.Any, types.Any)
    def numpy_empty_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_empty_nd`` `numba/targets/arrayobj.py` lines 2699-2705

.. code-block:: python

    @lower_builtin(numpy.empty, types.Any)
    @lower_builtin(numpy.empty, types.Any, types.Any)
    def numpy_empty_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


Lower Impl ``math.erf``
-----------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.radians``
---------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``radians_float_impl`` `numba/targets/mathimpl.py` lines 368-374

.. code-block:: python

    @lower(math.radians, types.Float)
    def radians_float_impl(context, builder, sig, args):
        [x] = args
        coef = context.get_constant(sig.return_type, math.pi / 180)
        res = builder.fmul(x, coef)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``numpy.core.fromnumeric.sum``
-----------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_sum`` `numba/targets/arraymath.py` lines 28-42

.. code-block:: python

    @lower_builtin(numpy.sum, types.Array)
    @lower_builtin("array.sum", types.Array)
    def array_sum(context, builder, sig, args):
        zero = sig.return_type(0)

        def array_sum_impl(arr):
            c = zero
            for v in numpy.nditer(arr):
                c += v.item()
            return c

        res = context.compile_internal(builder, array_sum_impl, sig, args,
                                        locals=dict(c=sig.return_type))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``math.degrees``
---------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``degrees_float_impl`` `numba/targets/mathimpl.py` lines 379-385

.. code-block:: python

    @lower(math.degrees, types.Float)
    def degrees_float_impl(context, builder, sig, args):
        [x] = args
        coef = context.get_constant(sig.return_type, 180 / math.pi)
        res = builder.fmul(x, coef)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'np.random.normal'``
---------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``np_gauss_impl`` `numba/targets/randomimpl.py` lines 213-221

.. code-block:: python

    @lower("np.random.standard_normal")
    @lower("np.random.normal")
    @lower("np.random.normal", types.Float)
    @lower("np.random.normal", types.Float, types.Float)
    def np_gauss_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _gauss_impl(context, builder, sig, args, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``np_gauss_impl`` `numba/targets/randomimpl.py` lines 213-221

.. code-block:: python

    @lower("np.random.standard_normal")
    @lower("np.random.normal")
    @lower("np.random.normal", types.Float)
    @lower("np.random.normal", types.Float, types.Float)
    def np_gauss_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _gauss_impl(context, builder, sig, args, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``np_gauss_impl`` `numba/targets/randomimpl.py` lines 213-221

.. code-block:: python

    @lower("np.random.standard_normal")
    @lower("np.random.normal")
    @lower("np.random.normal", types.Float)
    @lower("np.random.normal", types.Float, types.Float)
    def np_gauss_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _gauss_impl(context, builder, sig, args, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``numpy.lib.function_base.copy``
-------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``numpy_copy`` `numba/targets/arrayobj.py` lines 3087-3090

.. code-block:: python

    @lower_builtin(numpy.copy, types.Array)
    def numpy_copy(context, builder, sig, args):
        return _array_copy(context, builder, sig, args)


Lower Impl ``<ufunc 'subtract'>``
---------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'set.union'``
--------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_union`` `numba/targets/setobj.py` lines 1312-1326

.. code-block:: python

    @lower_builtin("|", types.Set, types.Set)
    @lower_builtin("set.union", types.Set, types.Set)
    def set_union(context, builder, sig, args):
        def union_impl(a, b):
            if len(a) > len(b):
                s = a.copy()
                s.update(b)
                return s
            else:
                s = b.copy()
                s.update(a)
                return s

        return context.compile_internal(builder, union_impl, sig, args)


Lower Impl ``numpy.core.multiarray.zeros``
------------------------------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_zeros_nd`` `numba/targets/arrayobj.py` lines 2714-2721

.. code-block:: python

    @lower_builtin(numpy.zeros, types.Any)
    @lower_builtin(numpy.zeros, types.Any, types.Any)
    def numpy_zeros_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        _zero_fill_array(context, builder, ary)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_zeros_nd`` `numba/targets/arrayobj.py` lines 2714-2721

.. code-block:: python

    @lower_builtin(numpy.zeros, types.Any)
    @lower_builtin(numpy.zeros, types.Any, types.Any)
    def numpy_zeros_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        _zero_fill_array(context, builder, ary)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


Lower Impl ``<ufunc 'tan'>``
----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.multiarray.arange``
-------------------------------------------

signature `(Number)`
~~~~~~~~~~~~~~~~~~~~

by ``numpy_arange_1`` `numba/targets/arrayobj.py` lines 2956-2965

.. code-block:: python

    @lower_builtin(numpy.arange, types.Number)
    def numpy_arange_1(context, builder, sig, args):
        dtype = as_dtype(sig.return_type.dtype)

        def arange(stop):
            return numpy.arange(0, stop, 1, dtype)

        res = context.compile_internal(builder, arange, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Number, Number)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_arange_2`` `numba/targets/arrayobj.py` lines 2966-2975

.. code-block:: python

    @lower_builtin(numpy.arange, types.Number, types.Number)
    def numpy_arange_2(context, builder, sig, args):
        dtype = as_dtype(sig.return_type.dtype)

        def arange(start, stop):
            return numpy.arange(start, stop, 1, dtype)

        res = context.compile_internal(builder, arange, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Number, Number, Number)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_arange_3`` `numba/targets/arrayobj.py` lines 2977-2987

.. code-block:: python

    @lower_builtin(numpy.arange, types.Number, types.Number,
               types.Number)
    def numpy_arange_3(context, builder, sig, args):
        dtype = as_dtype(sig.return_type.dtype)

        def arange(start, stop, step):
            return numpy.arange(start, stop, step, dtype)

        res = context.compile_internal(builder, arange, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Number, Number, Number, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_arange_4`` `numba/targets/arrayobj.py` lines 2988-3018

.. code-block:: python

    @lower_builtin(numpy.arange, types.Number, types.Number,
               types.Number, types.DTypeSpec)
    def numpy_arange_4(context, builder, sig, args):

        if any(isinstance(a, types.Complex) for a in sig.args):
            def arange(start, stop, step, dtype):
                nitems_c = (stop - start) / step
                nitems_r = math.ceil(nitems_c.real)
                nitems_i = math.ceil(nitems_c.imag)
                nitems = max(min(nitems_i, nitems_r), 0)
                arr = numpy.empty(nitems, dtype)
                val = start
                for i in range(nitems):
                    arr[i] = val
                    val += step
                return arr
        else:
            def arange(start, stop, step, dtype):
                nitems_r = math.ceil((stop - start) / step)
                nitems = max(nitems_r, 0)
                arr = numpy.empty(nitems, dtype)
                val = start
                for i in range(nitems):
                    arr[i] = val
                    val += step
                return arr

        res = context.compile_internal(builder, arange, sig, args,
                                       locals={'nitems': types.intp})
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'>='``
-------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_ge`` `numba/targets/listobj.py` lines 700-707

.. code-block:: python

    @lower_builtin('>=', types.List, types.List)
    def list_ge(context, builder, sig, args):

        def list_ge_impl(a, b):
            return b <= a

        return context.compile_internal(builder, list_ge_impl, sig, args)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_issuperset`` `numba/targets/setobj.py` lines 1345-1352

.. code-block:: python

    @lower_builtin(">=", types.Set, types.Set)
    @lower_builtin("set.issuperset", types.Set, types.Set)
    def set_issuperset(context, builder, sig, args):
        def superset_impl(a, b):
            return b.issubset(a)

        return context.compile_internal(builder, superset_impl, sig, args)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_uge_impl`` `numba/targets/numbers.py` lines 258-261

.. code-block:: python

    def int_uge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint8, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_uge_impl`` `numba/targets/numbers.py` lines 258-261

.. code-block:: python

    def int_uge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint32, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_uge_impl`` `numba/targets/numbers.py` lines 258-261

.. code-block:: python

    def int_uge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint16, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_uge_impl`` `numba/targets/numbers.py` lines 258-261

.. code-block:: python

    def int_uge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_uge_impl`` `numba/targets/numbers.py` lines 258-261

.. code-block:: python

    def int_uge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int8, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sge_impl`` `numba/targets/numbers.py` lines 238-241

.. code-block:: python

    def int_sge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sge_impl`` `numba/targets/numbers.py` lines 238-241

.. code-block:: python

    def int_sge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sge_impl`` `numba/targets/numbers.py` lines 238-241

.. code-block:: python

    def int_sge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int16, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sge_impl`` `numba/targets/numbers.py` lines 238-241

.. code-block:: python

    def int_sge_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_ge_impl`` `numba/targets/numbers.py` lines 677-680

.. code-block:: python

    def real_ge_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_OGE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_ge`` `numba/targets/tupleobj.py` lines 82-86

.. code-block:: python

    @lower_builtin('>=', types.BaseTuple, types.BaseTuple)
    def tuple_ge(context, builder, sig, args):
        res = tuple_cmp_ordered(context, builder, '>=', sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_ordering_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 291-306

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaT with something else
                # (i.e. NaT is <= everything else, since it's the smallest
                #  int64 value)
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.trunc``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'set.discard'``
----------------------------

signature `(Set, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_discard`` `numba/targets/setobj.py` lines 1163-1170

.. code-block:: python

    @lower_builtin("set.discard", types.Set, types.Any)
    def set_discard(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        item = args[1]
        inst.discard(item)

        return context.get_dummy_value()


Lower Impl ``numba.types.functions.NamedTupleClass``
----------------------------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``namedtuple_constructor`` `numba/targets/tupleobj.py` lines 14-20

.. code-block:: python

    @lower_builtin(types.NamedTupleClass, types.VarArg(types.Any))
    def namedtuple_constructor(context, builder, sig, args):
        # A namedtuple has the same representation as a regular tuple
        res = context.make_tuple(builder, sig.return_type, args)
        # The tuple's contents are borrowed
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'tanh'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.argmax'``
-----------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_argmax`` `numba/targets/arraymath.py` lines 254-272

.. code-block:: python

    @lower_builtin(numpy.argmax, types.Array)
    @lower_builtin("array.argmax", types.Array)
    def array_argmax(context, builder, sig, args):
        def array_argmax_impl(arry):
            for v in arry.flat:
                max_value = v
                max_idx = 0
                break

            idx = 0
            for v in arry.flat:
                if v > max_value:
                    max_value = v
                    max_idx = idx
                idx += 1
            return max_idx
        res = context.compile_internal(builder, array_argmax_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``numpy.lib.index_tricks.ndenumerate``
-------------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``make_array_ndenumerate`` `numba/targets/arrayobj.py` lines 2477-2494

.. code-block:: python

    @lower_builtin(numpy.ndenumerate, types.Array)
    def make_array_ndenumerate(context, builder, sig, args):
        arrty, = sig.args
        arr, = args
        nditercls = make_array_ndenumerate_cls(types.NumpyNdEnumerateType(arrty))
        nditer = nditercls(context, builder)

        arrayptr = cgutils.alloca_once_value(builder, arr)
        nditer.array = arrayptr

        arrcls = context.make_array(arrty)
        arr = arrcls(context, builder, ref=arrayptr)

        nditer.init_specific(context, builder, arrty, arr)

        res = nditer._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``math.ceil``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``numpy.lib.function_base.angle``
--------------------------------------------

signature `(Number, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``scalar_angle_kwarg`` `numba/targets/arraymath.py` lines 656-672

.. code-block:: python

    @lower_builtin(numpy.angle, types.Number)
    @lower_builtin(numpy.angle, types.Number, types.Boolean)
    def scalar_angle_kwarg(context, builder, sig, args):
        deg_mult = sig.return_type(180 / numpy.pi)
        def scalar_angle_impl(val, deg):
            if deg:
                return numpy.arctan2(val.imag, val.real) * deg_mult
            else:
                return numpy.arctan2(val.imag, val.real)

        if len(args) == 1:
            args = args + (cgutils.false_bit,)
            sig = signature(sig.return_type, *(sig.args + (types.boolean,)))
        res = context.compile_internal(builder, scalar_angle_impl,
                                       sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Number)`
~~~~~~~~~~~~~~~~~~~~

by ``scalar_angle_kwarg`` `numba/targets/arraymath.py` lines 656-672

.. code-block:: python

    @lower_builtin(numpy.angle, types.Number)
    @lower_builtin(numpy.angle, types.Number, types.Boolean)
    def scalar_angle_kwarg(context, builder, sig, args):
        deg_mult = sig.return_type(180 / numpy.pi)
        def scalar_angle_impl(val, deg):
            if deg:
                return numpy.arctan2(val.imag, val.real) * deg_mult
            else:
                return numpy.arctan2(val.imag, val.real)

        if len(args) == 1:
            args = args + (cgutils.false_bit,)
            sig = signature(sig.return_type, *(sig.args + (types.boolean,)))
        res = context.compile_internal(builder, scalar_angle_impl,
                                       sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_angle_kwarg`` `numba/targets/arraymath.py` lines 673-691

.. code-block:: python

    @lower_builtin(numpy.angle, types.Array)
    @lower_builtin(numpy.angle, types.Array, types.Boolean)
    def array_angle_kwarg(context, builder, sig, args):
        arg = sig.args[0]
        ret_dtype = sig.return_type.dtype

        def array_angle_impl(arr, deg):
            out = numpy.zeros_like(arr, dtype=ret_dtype)
            for index, val in numpy.ndenumerate(arr):
                out[index] = numpy.angle(val, deg)
            return out

        if len(args) == 1:
            args = args + (cgutils.false_bit,)
            sig = signature(sig.return_type, *(sig.args + (types.boolean,)))

        res = context.compile_internal(builder, array_angle_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_angle_kwarg`` `numba/targets/arraymath.py` lines 673-691

.. code-block:: python

    @lower_builtin(numpy.angle, types.Array)
    @lower_builtin(numpy.angle, types.Array, types.Boolean)
    def array_angle_kwarg(context, builder, sig, args):
        arg = sig.args[0]
        ret_dtype = sig.return_type.dtype

        def array_angle_impl(arr, deg):
            out = numpy.zeros_like(arr, dtype=ret_dtype)
            for index, val in numpy.ndenumerate(arr):
                out[index] = numpy.angle(val, deg)
            return out

        if len(args) == 1:
            args = args + (cgutils.false_bit,)
            sig = signature(sig.return_type, *(sig.args + (types.boolean,)))

        res = context.compile_internal(builder, array_angle_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'true_divide'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'random.lognormvariate'``
--------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``lognormvariate_impl`` `numba/targets/randomimpl.py` lines 619-624

.. code-block:: python

    @lower("random.lognormvariate",
               types.Float, types.Float)
    def lognormvariate_impl(context, builder, sig, args):
        res = _lognormvariate_impl(context, builder, sig, args, random.gauss)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'trunc'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.mean'``
---------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_mean`` `numba/targets/arraymath.py` lines 102-118

.. code-block:: python

    @lower_builtin(numpy.mean, types.Array)
    @lower_builtin("array.mean", types.Array)
    def array_mean(context, builder, sig, args):
        zero = sig.return_type(0)

        def array_mean_impl(arr):
            # Can't use the naive `arr.sum() / arr.size`, as it would return
            # a wrong result on integer sum overflow.
            c = zero
            for v in numpy.nditer(arr):
                c += v.item()
            return c / arr.size

        res = context.compile_internal(builder, array_mean_impl, sig, args,
                                       locals=dict(c=sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'setitem'``
------------------------

signature `(Buffer, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``setitem_array`` `numba/targets/arrayobj.py` lines 443-481

.. code-block:: python

    @lower_builtin('setitem', types.Buffer, types.Any, types.Any)
    def setitem_array(context, builder, sig, args):
        """
        array[a] = scalar_or_array
        array[a,..,b] = scalar_or_array
        """
        aryty, idxty, valty = sig.args
        ary, idx, val = args

        if isinstance(idxty, types.BaseTuple):
            index_types = idxty.types
            indices = cgutils.unpack_tuple(builder, idx, count=len(idxty))
        else:
            index_types = (idxty,)
            indices = (idx,)

        ary = make_array(aryty)(context, builder, ary)

        # First try basic indexing to see if a single array location is denoted.
        index_types, indices = normalize_indices(context, builder,
                                                 index_types, indices)
        try:
            dataptr, shapes, strides = \
                basic_indexing(context, builder, aryty, ary, index_types, indices)
        except NotImplementedError:
            use_fancy_indexing = True
        else:
            use_fancy_indexing = bool(shapes)

        if use_fancy_indexing:
            # Index describes a non-trivial view => use generic slice assignment
            # (NOTE: this also handles scalar broadcasting)
            return fancy_setslice(context, builder, sig, args,
                                  index_types, indices)

        # Store source value the given location
        val = context.cast(builder, val, valty, aryty.dtype)
        store_item(context, builder, aryty, val, dataptr)


signature `(NumpyFlatType, Integer, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_numpy_getitem`` `numba/targets/arrayobj.py` lines 2449-2464

.. code-block:: python

    @lower_builtin('setitem', types.NumpyFlatType, types.Integer,
               types.Any)
    def iternext_numpy_getitem(context, builder, sig, args):
        flatiterty = sig.args[0]
        flatiter, index, value = args

        flatitercls = make_array_flat_cls(flatiterty)
        flatiter = flatitercls(context, builder, value=flatiter)

        arrty = flatiterty.array_type
        arrcls = context.make_array(arrty)
        arr = arrcls(context, builder, value=builder.load(flatiter.array))

        res = flatiter.setitem(context, builder, arrty, arr, index, value)
        return context.get_dummy_value()


signature `(CPointer, Integer, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``setitem_cpointer`` `numba/targets/builtins.py` lines 75-80

.. code-block:: python

    @lower_builtin('setitem', types.CPointer, types.Integer, types.Any)
    def setitem_cpointer(context, builder, sig, args):
        base_ptr, idx, val = args
        elem_ptr = builder.gep(base_ptr, [idx])
        builder.store(val, elem_ptr)


signature `(List, Integer, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``setitem_list`` `numba/targets/listobj.py` lines 415-424

.. code-block:: python

    @lower_builtin('setitem', types.List, types.Integer, types.Any)
    def setitem_list(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        index = args[1]
        value = args[2]

        index = inst.fix_index(index)
        inst.setitem(index, value)
        return context.get_dummy_value()


signature `(List, SliceType, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``setitem_list`` `numba/targets/listobj.py` lines 449-507

.. code-block:: python

    @lower_builtin('setitem', types.List, types.SliceType, types.Any)
    def setitem_list(context, builder, sig, args):
        dest = ListInstance(context, builder, sig.args[0], args[0])
        src = ListInstance(context, builder, sig.args[2], args[2])

        slice = context.make_helper(builder, sig.args[1], args[1])
        slicing.guard_invalid_slice(context, builder, sig.args[1], slice)
        dest.fix_slice(slice)

        src_size = src.size
        avail_size = slicing.get_slice_length(builder, slice)
        size_delta = builder.sub(src.size, avail_size)

        zero = ir.Constant(size_delta.type, 0)
        one = ir.Constant(size_delta.type, 1)

        with builder.if_else(builder.icmp_signed('==', slice.step, one)) as (then, otherwise):
            with then:
                # Slice step == 1 => we can resize

                # Compute the real stop, e.g. for dest[2:0] = [...]
                real_stop = builder.add(slice.start, avail_size)
                # Size of the list tail, after the end of slice
                tail_size = builder.sub(dest.size, real_stop)

                with builder.if_then(builder.icmp_signed('>', size_delta, zero)):
                    # Grow list then move list tail
                    dest.resize(builder.add(dest.size, size_delta))
                    dest.move(builder.add(real_stop, size_delta), real_stop,
                              tail_size)

                with builder.if_then(builder.icmp_signed('<', size_delta, zero)):
                    # Move list tail then shrink list
                    dest.move(builder.add(real_stop, size_delta), real_stop,
                              tail_size)
                    dest.resize(builder.add(dest.size, size_delta))

                dest_offset = slice.start

                with cgutils.for_range(builder, src_size) as loop:
                    value = src.getitem(loop.index)
                    dest.setitem(builder.add(loop.index, dest_offset), value)

            with otherwise:
                with builder.if_then(builder.icmp_signed('!=', size_delta, zero)):
                    msg = "cannot resize extended list slice with step != 1"
                    context.call_conv.return_user_exc(builder, ValueError, (msg,))

                with cgutils.for_range_slice_generic(
                    builder, slice.start, slice.stop, slice.step) as (pos_range, neg_range):
                    with pos_range as (index, count):
                        value = src.getitem(count)
                        dest.setitem(index, value)
                    with neg_range as (index, count):
                        value = src.getitem(count)
                        dest.setitem(index, value)

        return context.get_dummy_value()


Lower Impl ``math.isnan``
-------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``isnan_float_impl`` `numba/targets/mathimpl.py` lines 209-214

.. code-block:: python

    @lower(math.isnan, types.Float)
    def isnan_float_impl(context, builder, sig, args):
        [val] = args
        res = is_nan(builder, val)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``isnan_int_impl`` `numba/targets/mathimpl.py` lines 215-219

.. code-block:: python

    @lower(math.isnan, types.Integer)
    def isnan_int_impl(context, builder, sig, args):
        res = cgutils.false_bit
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``math.isfinite``
----------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``isfinite_float_impl`` `numba/targets/mathimpl.py` lines 234-239

.. code-block:: python

    @lower(math.isfinite, types.Float)
    def isfinite_float_impl(context, builder, sig, args):
        [val] = args
        res = is_finite(builder, val)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``isfinite_int_impl`` `numba/targets/mathimpl.py` lines 240-244

.. code-block:: python

    @lower(math.isfinite, types.Integer)
    def isfinite_int_impl(context, builder, sig, args):
        res = cgutils.true_bit
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``numpy.core.fromnumeric.amax``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_max`` `numba/targets/arraymath.py` lines 185-201

.. code-block:: python

    @lower_builtin(numpy.max, types.Array)
    @lower_builtin("array.max", types.Array)
    def array_max(context, builder, sig, args):
        def array_max_impl(arry):
            it = numpy.nditer(arry)
            for view in it:
                max_value = view.item()
                break

            for view in it:
                v = view.item()
                if v > max_value:
                    max_value = v
            return max_value
        res = context.compile_internal(builder, array_max_impl, sig, args)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``math.cos``
-----------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'arccosh'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.amin``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_min`` `numba/targets/arraymath.py` lines 145-183

.. code-block:: python

    @lower_builtin(numpy.min, types.Array)
    @lower_builtin("array.min", types.Array)
    def array_min(context, builder, sig, args):
        ty = sig.args[0].dtype
        if isinstance(ty, (types.NPDatetime, types.NPTimedelta)):
            # NaT is smaller than every other value, but it is
            # ignored as far as min() is concerned.
            nat = ty('NaT')

            def array_min_impl(arry):
                min_value = nat
                it = numpy.nditer(arry)
                for view in it:
                    v = view.item()
                    if v != nat:
                        min_value = v
                        break

                for view in it:
                    v = view.item()
                    if v != nat and v < min_value:
                        min_value = v
                return min_value

        else:
            def array_min_impl(arry):
                it = numpy.nditer(arry)
                for view in it:
                    min_value = view.item()
                    break

                for view in it:
                    v = view.item()
                    if v < min_value:
                        min_value = v
                return min_value
        res = context.compile_internal(builder, array_min_impl, sig, args)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'arcsin'>``
-------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.gt``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``cmath.exp``
------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``intrinsic_complex_unary.<locals>.wrapper`` `numba/targets/cmathimpl.py` lines 97-112

.. code-block:: python

    def wrapper(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        x = z.real
        y = z.imag
        # Same as above: math.isfinite() is unavailable on 2.x so we precompute
        # its value and pass it to the pure Python implementation.
        x_is_finite = mathimpl.is_finite(builder, x)
        y_is_finite = mathimpl.is_finite(builder, y)
        inner_sig = signature(sig.return_type,
                              *(typ.underlying_float,) * 2 + (types.boolean,) * 2)
        res = context.compile_internal(builder, inner_func, inner_sig,
                                        (x, y, x_is_finite, y_is_finite))
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``_operator.ne``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.core.fromnumeric.prod``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_prod`` `numba/targets/arraymath.py` lines 43-56

.. code-block:: python

    @lower_builtin(numpy.prod, types.Array)
    @lower_builtin("array.prod", types.Array)
    def array_prod(context, builder, sig, args):

        def array_prod_impl(arr):
            c = 1
            for v in numpy.nditer(arr):
                c *= v.item()
            return c

        res = context.compile_internal(builder, array_prod_impl, sig, args,
                                        locals=dict(c=sig.return_type))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'arcsinh'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'not'``
--------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``number_not_impl`` `numba/targets/numbers.py` lines 1016-1022

.. code-block:: python

    def number_not_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        istrue = context.cast(builder, val, typ, sig.return_type)
        res = builder.not_(istrue)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``number_not_impl`` `numba/targets/numbers.py` lines 1016-1022

.. code-block:: python

    def number_not_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        istrue = context.cast(builder, val, typ, sig.return_type)
        res = builder.not_(istrue)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``number_not_impl`` `numba/targets/numbers.py` lines 1016-1022

.. code-block:: python

    def number_not_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        istrue = context.cast(builder, val, typ, sig.return_type)
        res = builder.not_(istrue)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(bool)`
~~~~~~~~~~~~~~~~~~

by ``number_not_impl`` `numba/targets/numbers.py` lines 1016-1022

.. code-block:: python

    def number_not_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        istrue = context.cast(builder, val, typ, sig.return_type)
        res = builder.not_(istrue)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``cmath.log10``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``log10_impl`` `numba/targets/cmathimpl.py` lines 180-193

.. code-block:: python

    @lower(cmath.log10, types.Complex)
    def log10_impl(context, builder, sig, args):
        LN_10 = 2.302585092994045684

        def log10_impl(z):
            """cmath.log10(z)"""
            z = cmath.log(z)
            # This formula gives better results on +/-inf than cmath.log(z, 10)
            # See http://bugs.python.org/issue22544
            return complex(z.real / LN_10, z.imag / LN_10)

        res = context.compile_internal(builder, log10_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``_operator.eq``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'arctan'>``
-------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.ge``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.core.fromnumeric.cumprod``
---------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_cumprod`` `numba/targets/arraymath.py` lines 81-101

.. code-block:: python

    @lower_builtin(numpy.cumprod, types.Array)
    @lower_builtin("array.cumprod", types.Array)
    def array_cumprod(context, builder, sig, args):
        scalar_dtype = sig.return_type.dtype
        dtype = as_dtype(scalar_dtype)

        def array_cumprod_impl(arr):
            size = 1
            for i in arr.shape:
                size = size * i
            out = numpy.empty(size, dtype)
            c = 1
            for idx, v in enumerate(arr.flat):
                c *= v
                out[idx] = c
            return out

        res = context.compile_internal(builder, array_cumprod_impl, sig, args,
                                       locals=dict(c=scalar_dtype))
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``_operator.pow``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``math.isinf``
-------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``isinf_float_impl`` `numba/targets/mathimpl.py` lines 221-226

.. code-block:: python

    @lower(math.isinf, types.Float)
    def isinf_float_impl(context, builder, sig, args):
        [val] = args
        res = is_inf(builder, val)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``isinf_int_impl`` `numba/targets/mathimpl.py` lines 227-231

.. code-block:: python

    @lower(math.isinf, types.Integer)
    def isinf_int_impl(context, builder, sig, args):
        res = cgutils.false_bit
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``math.atan2``
-------------------------

signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``atan2_s64_impl`` `numba/targets/mathimpl.py` lines 293-300

.. code-block:: python

    @lower(math.atan2, types.int64, types.int64)
    def atan2_s64_impl(context, builder, sig, args):
        [y, x] = args
        y = builder.sitofp(y, Type.double())
        x = builder.sitofp(x, Type.double())
        fsig = signature(types.float64, types.float64, types.float64)
        return atan2_f64_impl(context, builder, fsig, (y, x))


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``atan2_u64_impl`` `numba/targets/mathimpl.py` lines 301-308

.. code-block:: python

    @lower(math.atan2, types.uint64, types.uint64)
    def atan2_u64_impl(context, builder, sig, args):
        [y, x] = args
        y = builder.uitofp(y, Type.double())
        x = builder.uitofp(x, Type.double())
        fsig = signature(types.float64, types.float64, types.float64)
        return atan2_f64_impl(context, builder, fsig, (y, x))


signature `(float32, float32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``atan2_f32_impl`` `numba/targets/mathimpl.py` lines 310-318

.. code-block:: python

    @lower(math.atan2, types.float32, types.float32)
    def atan2_f32_impl(context, builder, sig, args):
        assert len(args) == 2
        mod = builder.module
        fnty = Type.function(Type.float(), [Type.float(), Type.float()])
        fn = cgutils.insert_pure_function(builder.module, fnty, name="atan2f")
        res = builder.call(fn, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, float64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``atan2_f64_impl`` `numba/targets/mathimpl.py` lines 319-329

.. code-block:: python

    @lower(math.atan2, types.float64, types.float64)
    def atan2_f64_impl(context, builder, sig, args):
        assert len(args) == 2
        mod = builder.module
        fnty = Type.function(Type.double(), [Type.double(), Type.double()])
        # Workaround atan2() issues under Windows
        fname = "atan2_fixed" if sys.platform == "win32" else "atan2"
        fn = cgutils.insert_pure_function(builder.module, fnty, name=fname)
        res = builder.call(fn, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'+='``
-------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_add_inplace`` `numba/targets/listobj.py` lines 579-585

.. code-block:: python

    @lower_builtin("+=", types.List, types.List)
    def list_add_inplace(context, builder, sig, args):
        assert sig.args[0].dtype == sig.return_type.dtype
        dest = _list_extend_list(context, builder, sig, args)

        return impl_ret_borrowed(context, builder, sig.return_type, dest.value)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``_operator.le``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.core.numeric.ones``
--------------------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_ones_nd`` `numba/targets/arrayobj.py` lines 2784-2797

.. code-block:: python

    @lower_builtin(numpy.ones, types.Any)
    def numpy_ones_nd(context, builder, sig, args):

        def ones(shape):
            arr = numpy.empty(shape)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = 1
            return arr

        valty = sig.return_type.dtype
        res = context.compile_internal(builder, ones, sig, args,
                                       locals={'c': valty})
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_ones_dtype_nd`` `numba/targets/arrayobj.py` lines 2798-2809

.. code-block:: python

    @lower_builtin(numpy.ones, types.Any, types.DTypeSpec)
    def numpy_ones_dtype_nd(context, builder, sig, args):

        def ones(shape, dtype):
            arr = numpy.empty(shape, dtype)
            for idx in numpy.ndindex(arr.shape):
                arr[idx] = 1
            return arr

        res = context.compile_internal(builder, ones, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``numpy.lib.index_tricks.ndindex``
---------------------------------------------

signature `(*<class 'numba.types.scalars.Integer'>)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_array_ndindex`` `numba/targets/arrayobj.py` lines 2512-2524

.. code-block:: python

    @lower_builtin(numpy.ndindex, types.VarArg(types.Integer))
    def make_array_ndindex(context, builder, sig, args):
        """ndindex(*shape)"""
        shape = [context.cast(builder, arg, argty, types.intp)
                 for argty, arg in zip(sig.args, args)]

        nditercls = make_ndindex_cls(types.NumpyNdIndexType(len(shape)))
        nditer = nditercls(context, builder)
        nditer.init_specific(context, builder, shape)

        res = nditer._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``make_array_ndindex`` `numba/targets/arrayobj.py` lines 2525-2545

.. code-block:: python

    @lower_builtin(numpy.ndindex, types.BaseTuple)
    def make_array_ndindex(context, builder, sig, args):
        """ndindex(shape)"""
        ndim = sig.return_type.ndim
        if ndim > 0:
            idxty = sig.args[0].dtype
            tup = args[0]

            shape = cgutils.unpack_tuple(builder, tup, ndim)
            shape = [context.cast(builder, idx, idxty, types.intp)
                     for idx in shape]
        else:
            shape = []

        nditercls = make_ndindex_cls(types.NumpyNdIndexType(len(shape)))
        nditer = nditercls(context, builder)
        nditer.init_specific(context, builder, shape)

        res = nditer._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``'np.random.seed'``
-------------------------------

signature `(uint32)`
~~~~~~~~~~~~~~~~~~~~

by ``seed_impl`` `numba/targets/randomimpl.py` lines 180-185

.. code-block:: python

    @lower("np.random.seed", types.uint32)
    def seed_impl(context, builder, sig, args):
        res = _seed_impl(context, builder, sig, args, get_state_ptr(context,
                                                                   builder, "np"))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``cmath.log``
------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``intrinsic_complex_unary.<locals>.wrapper`` `numba/targets/cmathimpl.py` lines 97-112

.. code-block:: python

    def wrapper(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        x = z.real
        y = z.imag
        # Same as above: math.isfinite() is unavailable on 2.x so we precompute
        # its value and pass it to the pure Python implementation.
        x_is_finite = mathimpl.is_finite(builder, x)
        y_is_finite = mathimpl.is_finite(builder, y)
        inner_sig = signature(sig.return_type,
                              *(typ.underlying_float,) * 2 + (types.boolean,) * 2)
        res = context.compile_internal(builder, inner_func, inner_sig,
                                        (x, y, x_is_finite, y_is_finite))
        return impl_ret_untracked(context, builder, sig, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``log_base_impl`` `numba/targets/cmathimpl.py` lines 168-178

.. code-block:: python

    @lower(cmath.log, types.Complex, types.Complex)
    def log_base_impl(context, builder, sig, args):
        """cmath.log(z, base)"""
        [z, base] = args

        def log_base(z, base):
            return cmath.log(z) / cmath.log(base)

        res = context.compile_internal(builder, log_base, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``numpy.core.numeric.zeros_like``
--------------------------------------------

signature `(any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_zeros_like_nd`` `numba/targets/arrayobj.py` lines 2723-2730

.. code-block:: python

    @lower_builtin(numpy.zeros_like, types.Any)
    @lower_builtin(numpy.zeros_like, types.Any, types.DTypeSpec)
    def numpy_zeros_like_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_like_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        _zero_fill_array(context, builder, ary)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``numpy_zeros_like_nd`` `numba/targets/arrayobj.py` lines 2723-2730

.. code-block:: python

    @lower_builtin(numpy.zeros_like, types.Any)
    @lower_builtin(numpy.zeros_like, types.Any, types.DTypeSpec)
    def numpy_zeros_like_nd(context, builder, sig, args):
        arrtype, shapes = _parse_empty_like_args(context, builder, sig, args)
        ary = _empty_nd_impl(context, builder, arrtype, shapes)
        _zero_fill_array(context, builder, ary)
        return impl_ret_new_ref(context, builder, sig.return_type, ary._getvalue())


Lower Impl ``'|'``
------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_union`` `numba/targets/setobj.py` lines 1312-1326

.. code-block:: python

    @lower_builtin("|", types.Set, types.Set)
    @lower_builtin("set.union", types.Set, types.Set)
    def set_union(context, builder, sig, args):
        def union_impl(a, b):
            if len(a) > len(b):
                s = a.copy()
                s.update(b)
                return s
            else:
                s = b.copy()
                s.update(a)
                return s

        return context.compile_internal(builder, union_impl, sig, args)


signature `(Boolean, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_or_impl`` `numba/targets/numbers.py` lines 317-324

.. code-block:: python

    def int_or_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.or_(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_or_impl`` `numba/targets/numbers.py` lines 317-324

.. code-block:: python

    def int_or_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.or_(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.multiarray.array``
------------------------------------------

signature `(any, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``np_array`` `numba/targets/arrayobj.py` lines 3327-3344

.. code-block:: python

    @lower_builtin(numpy.array, types.Any)
    @lower_builtin(numpy.array, types.Any, types.DTypeSpec)
    def np_array(context, builder, sig, args):
        arrty = sig.return_type
        ndim = arrty.ndim
        seqty = sig.args[0]
        seq = args[0]

        shapes = compute_sequence_shape(context, builder, ndim, seqty, seq)
        assert len(shapes) == ndim

        check_sequence_shape(context, builder, seqty, seq, shapes)
        arr = _empty_nd_impl(context, builder, arrty, shapes)
        assign_sequence_to_array(context, builder, arr.data, shapes, arr.strides,
                                 arrty, seqty, seq)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``np_array`` `numba/targets/arrayobj.py` lines 3327-3344

.. code-block:: python

    @lower_builtin(numpy.array, types.Any)
    @lower_builtin(numpy.array, types.Any, types.DTypeSpec)
    def np_array(context, builder, sig, args):
        arrty = sig.return_type
        ndim = arrty.ndim
        seqty = sig.args[0]
        seq = args[0]

        shapes = compute_sequence_shape(context, builder, ndim, seqty, seq)
        assert len(shapes) == ndim

        check_sequence_shape(context, builder, seqty, seq, shapes)
        arr = _empty_nd_impl(context, builder, arrty, shapes)
        assign_sequence_to_array(context, builder, arr.data, shapes, arr.strides,
                                 arrty, seqty, seq)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``_operator.ipow``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'getitem'``
------------------------

signature `(Buffer, SliceType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_arraynd_intp`` `numba/targets/arrayobj.py` lines 401-416

.. code-block:: python

    @lower_builtin('getitem', types.Buffer, types.Integer)
    @lower_builtin('getitem', types.Buffer, types.SliceType)
    def getitem_arraynd_intp(context, builder, sig, args):
        """
        Basic indexing with an integer or a slice.
        """
        aryty, idxty = sig.args
        ary, idx = args

        assert aryty.ndim >= 1
        ary = make_array(aryty)(context, builder, ary)

        res = _getitem_array_generic(context, builder, sig.return_type,
                                     aryty, ary, (idxty,), (idx,))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(Buffer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_arraynd_intp`` `numba/targets/arrayobj.py` lines 401-416

.. code-block:: python

    @lower_builtin('getitem', types.Buffer, types.Integer)
    @lower_builtin('getitem', types.Buffer, types.SliceType)
    def getitem_arraynd_intp(context, builder, sig, args):
        """
        Basic indexing with an integer or a slice.
        """
        aryty, idxty = sig.args
        ary, idx = args

        assert aryty.ndim >= 1
        ary = make_array(aryty)(context, builder, ary)

        res = _getitem_array_generic(context, builder, sig.return_type,
                                     aryty, ary, (idxty,), (idx,))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(Buffer, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_array_tuple`` `numba/targets/arrayobj.py` lines 418-441

.. code-block:: python

    @lower_builtin('getitem', types.Buffer, types.BaseTuple)
    def getitem_array_tuple(context, builder, sig, args):
        """
        Basic or advanced indexing with a tuple.
        """
        aryty, tupty = sig.args
        ary, tup = args
        ary = make_array(aryty)(context, builder, ary)

        index_types = tupty.types
        indices = cgutils.unpack_tuple(builder, tup, count=len(tupty))

        index_types, indices = normalize_indices(context, builder,
                                                 index_types, indices)

        if any(isinstance(ty, types.Array) for ty in index_types):
            # Advanced indexing
            return fancy_getitem(context, builder, sig, args,
                                 aryty, ary, index_types, indices)

        res = _getitem_array_generic(context, builder, sig.return_type,
                                     aryty, ary, index_types, indices)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(Buffer, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``fancy_getitem_array`` `numba/targets/arrayobj.py` lines 961-979

.. code-block:: python

    @lower_builtin('getitem', types.Buffer, types.Array)
    def fancy_getitem_array(context, builder, sig, args):
        """
        Advanced or basic indexing with an array.
        """
        aryty, idxty = sig.args
        ary, idx = args
        ary = make_array(aryty)(context, builder, ary)
        if idxty.ndim == 0:
            # 0-d array index acts as a basic integer index
            idxty, idx = normalize_index(context, builder, idxty, idx)
            res = _getitem_array_generic(context, builder, sig.return_type,
                                         aryty, ary, (idxty,), (idx,))
            return impl_ret_borrowed(context, builder, sig.return_type, res)
        else:
            # Advanced indexing
            return fancy_getitem(context, builder, sig, args,
                                 aryty, ary, (idxty,), (idx,))


signature `(NumpyFlatType, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_numpy_getitem`` `numba/targets/arrayobj.py` lines 2433-2447

.. code-block:: python

    @lower_builtin('getitem', types.NumpyFlatType, types.Integer)
    def iternext_numpy_getitem(context, builder, sig, args):
        flatiterty = sig.args[0]
        flatiter, index = args

        flatitercls = make_array_flat_cls(flatiterty)
        flatiter = flatitercls(context, builder, value=flatiter)

        arrty = flatiterty.array_type
        arrcls = context.make_array(arrty)
        arr = arrcls(context, builder, value=builder.load(flatiter.array))

        res = flatiter.getitem(context, builder, arrty, arr, index)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(CPointer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_cpointer`` `numba/targets/builtins.py` lines 67-73

.. code-block:: python

    @lower_builtin('getitem', types.CPointer, types.Integer)
    def getitem_cpointer(context, builder, sig, args):
        base_ptr, idx = args
        elem_ptr = builder.gep(base_ptr, [idx])
        res = builder.load(elem_ptr)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(List, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_list`` `numba/targets/listobj.py` lines 405-414

.. code-block:: python

    @lower_builtin('getitem', types.List, types.Integer)
    def getitem_list(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        index = args[1]

        index = inst.fix_index(index)
        result = inst.getitem(index)

        return impl_ret_borrowed(context, builder, sig.return_type, result)


signature `(List, SliceType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getslice_list`` `numba/targets/listobj.py` lines 426-448

.. code-block:: python

    @lower_builtin('getitem', types.List, types.SliceType)
    def getslice_list(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        slice = context.make_helper(builder, sig.args[1], args[1])
        slicing.guard_invalid_slice(context, builder, sig.args[1], slice)
        inst.fix_slice(slice)

        # Allocate result and populate it
        result_size = slicing.get_slice_length(builder, slice)
        result = ListInstance.allocate(context, builder, sig.return_type,
                                       result_size)
        result.size = result_size
        with cgutils.for_range_slice_generic(builder, slice.start, slice.stop,
                                             slice.step) as (pos_range, neg_range):
            with pos_range as (idx, count):
                value = inst.getitem(idx)
                result.inititem(count, value)
            with neg_range as (idx, count):
                value = inst.getitem(idx)
                result.inititem(count, value)

        return impl_ret_new_ref(context, builder, sig.return_type, result.value)


signature `(NamedUniTuple, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_unituple`` `numba/targets/tupleobj.py` lines 192-223

.. code-block:: python

    @lower_builtin('getitem', types.UniTuple, types.intp)
    @lower_builtin('getitem', types.NamedUniTuple, types.intp)
    def getitem_unituple(context, builder, sig, args):
        tupty, _ = sig.args
        tup, idx = args

        bbelse = builder.append_basic_block("switch.else")
        bbend = builder.append_basic_block("switch.end")
        switch = builder.switch(idx, bbelse)

        with builder.goto_block(bbelse):
            context.call_conv.return_user_exc(builder, IndexError,
                                              ("tuple index out of range",))

        lrtty = context.get_value_type(tupty.dtype)
        with builder.goto_block(bbend):
            phinode = builder.phi(lrtty)

        for i in range(tupty.count):
            ki = context.get_constant(types.intp, i)
            bbi = builder.append_basic_block("switch.%d" % i)
            switch.add_case(ki, bbi)
            with builder.goto_block(bbi):
                value = builder.extract_value(tup, i)
                builder.branch(bbend)
                phinode.add_incoming(value, bbi)

        builder.position_at_end(bbend)
        res = phinode
        assert sig.return_type == tupty.dtype
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(UniTuple, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getitem_unituple`` `numba/targets/tupleobj.py` lines 192-223

.. code-block:: python

    @lower_builtin('getitem', types.UniTuple, types.intp)
    @lower_builtin('getitem', types.NamedUniTuple, types.intp)
    def getitem_unituple(context, builder, sig, args):
        tupty, _ = sig.args
        tup, idx = args

        bbelse = builder.append_basic_block("switch.else")
        bbend = builder.append_basic_block("switch.end")
        switch = builder.switch(idx, bbelse)

        with builder.goto_block(bbelse):
            context.call_conv.return_user_exc(builder, IndexError,
                                              ("tuple index out of range",))

        lrtty = context.get_value_type(tupty.dtype)
        with builder.goto_block(bbend):
            phinode = builder.phi(lrtty)

        for i in range(tupty.count):
            ki = context.get_constant(types.intp, i)
            bbi = builder.append_basic_block("switch.%d" % i)
            switch.add_case(ki, bbi)
            with builder.goto_block(bbi):
                value = builder.extract_value(tup, i)
                builder.branch(bbend)
                phinode.add_incoming(value, bbi)

        builder.position_at_end(bbend)
        res = phinode
        assert sig.return_type == tupty.dtype
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'absolute'>``
---------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``builtins.round``
-----------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``round_impl_unary`` `numba/targets/builtins.py` lines 141-153

.. code-block:: python

    @lower_builtin(round, types.Float)
    def round_impl_unary(context, builder, sig, args):
        fltty = sig.args[0]
        llty = context.get_value_type(fltty)
        module = builder.module
        fnty = Type.function(llty, [llty])
        fn = module.get_or_insert_function(fnty, name=_round_intrinsic(fltty))
        res = builder.call(fn, args)
        if utils.IS_PY3:
            # unary round() returns an int on Python 3
            res = builder.fptosi(res, context.get_value_type(sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``round_impl_binary`` `numba/targets/builtins.py` lines 154-187

.. code-block:: python

    @lower_builtin(round, types.Float, types.Integer)
    def round_impl_binary(context, builder, sig, args):
        fltty = sig.args[0]
        # Allow calling the intrinsic from the Python implementation below.
        # This avoids the conversion to an int in Python 3's unary round().
        _round = types.ExternalFunction(
            _round_intrinsic(fltty), typing.signature(fltty, fltty))

        def round_ndigits(x, ndigits):
            if math.isinf(x) or math.isnan(x):
                return x

            if ndigits >= 0:
                if ndigits > 22:
                    # pow1 and pow2 are each safe from overflow, but
                    # pow1*pow2 ~= pow(10.0, ndigits) might overflow.
                    pow1 = 10.0 ** (ndigits - 22)
                    pow2 = 1e22
                else:
                    pow1 = 10.0 ** ndigits
                    pow2 = 1.0
                y = (x * pow1) * pow2
                if math.isinf(y):
                    return x
                return (_round(y) / pow2) / pow1

            else:
                pow1 = 10.0 ** (-ndigits)
                y = x / pow1
                return _round(y) * pow1

        res = context.compile_internal(builder, round_ndigits, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'/?'``
-------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_floordiv_impl`` `numba/targets/numbers.py` lines 108-135

.. code-block:: python

    @lower_builtin('/?', types.Integer, types.Integer)
    @lower_builtin('//', types.Integer, types.Integer)
    def int_floordiv_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = cgutils.alloca_once(builder, a.type)

        with builder.if_else(cgutils.is_scalar_zero(builder, b), likely=False
                             ) as (if_zero, if_non_zero):
            with if_zero:
                if not context.error_model.fp_zero_division(
                    builder, ("integer division by zero",)):
                    # No exception raised => return 0
                    # XXX We should also set the FPU exception status, but
                    # there's no easy way to do that from LLVM.
                    builder.store(b, res)
            with if_non_zero:
                if sig.return_type.signed:
                    quot, _ = int_divmod(context, builder, a, b)
                else:
                    quot = builder.udiv(a, b)
                builder.store(quot, res)

        return impl_ret_untracked(context, builder, sig.return_type,
                                  builder.load(res))


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_div_impl`` `numba/targets/numbers.py` lines 474-479

.. code-block:: python

    def real_div_impl(context, builder, sig, args):
        with cgutils.if_zero(builder, args[1]):
            context.error_model.fp_zero_division(builder, ("division by zero",))
        res = builder.fdiv(*args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_div_impl`` `numba/targets/numbers.py` lines 901-931

.. code-block:: python

    def complex_div_impl(context, builder, sig, args):
        def complex_div(a, b):
            # This is CPython's algorithm (in _Py_c_quot()).
            areal = a.real
            aimag = a.imag
            breal = b.real
            bimag = b.imag
            if not breal and not bimag:
                raise ZeroDivisionError("complex division by zero")
            if abs(breal) >= abs(bimag):
                # Divide tops and bottom by b.real
                if not breal:
                    return complex(NAN, NAN)
                ratio = bimag / breal
                denom = breal + bimag * ratio
                return complex(
                    (areal + aimag * ratio) / denom,
                    (aimag - areal * ratio) / denom)
            else:
                # Divide tops and bottom by b.imag
                if not bimag:
                    return complex(NAN, NAN)
                ratio = breal / bimag
                denom = breal * ratio + bimag
                return complex(
                    (a.real * ratio + a.imag) / denom,
                    (a.imag * ratio - a.real) / denom)

        res = context.compile_internal(builder, complex_div, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_timedelta`` `numba/targets/npdatetime.py` lines 247-263

.. code-block:: python

    @lower_builtin('/', *TIMEDELTA_BINOP_SIG)
    @lower_builtin('/?', *TIMEDELTA_BINOP_SIG)
    def timedelta_over_timedelta(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        not_nan = are_not_nat(builder, [va, vb])
        ll_ret_type = context.get_value_type(sig.return_type)
        ret = cgutils.alloca_once(builder, ll_ret_type, name='ret')
        builder.store(Constant.real(ll_ret_type, float('nan')), ret)
        with cgutils.if_likely(builder, not_nan):
            va, vb = normalize_timedeltas(context, builder, va, vb, ta, tb)
            va = builder.sitofp(va, ll_ret_type)
            vb = builder.sitofp(vb, ll_ret_type)
            builder.store(builder.fdiv(va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'list.reverse'``
-----------------------------

signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_reverse`` `numba/targets/listobj.py` lines 901-910

.. code-block:: python

    @lower_builtin("list.reverse", types.List)
    def list_reverse(context, builder, sig, args):

        def list_reverse_impl(lst):
            for a in range(0, len(lst) // 2):
                b = -a - 1
                lst[a], lst[b] = lst[b], lst[a]

        return context.compile_internal(builder, list_reverse_impl, sig, args)


Lower Impl ``<ufunc 'add'>``
----------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'*'``
------------------

signature `(List, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_mul`` `numba/targets/listobj.py` lines 587-606

.. code-block:: python

    @lower_builtin("*", types.List, types.Integer)
    def list_mul(context, builder, sig, args):
        src = ListInstance(context, builder, sig.args[0], args[0])
        src_size = src.size

        mult = args[1]
        zero = ir.Constant(mult.type, 0)
        mult = builder.select(cgutils.is_neg_int(builder, mult), zero, mult)
        nitems = builder.mul(mult, src_size)

        dest = ListInstance.allocate(context, builder, sig.return_type, nitems)
        dest.size = nitems

        with cgutils.for_range_slice(builder, zero, nitems, src_size, inc=True) as (dest_offset, _):
            with cgutils.for_range(builder, src_size) as loop:
                value = src.getitem(loop.index)
                dest.setitem(builder.add(loop.index, dest_offset), value)

        return impl_ret_new_ref(context, builder, sig.return_type, dest.value)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_mul_impl`` `numba/targets/numbers.py` lines 53-60

.. code-block:: python

    def int_mul_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = builder.mul(a, b, flags=_int_arith_flags(sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_mul_impl`` `numba/targets/numbers.py` lines 469-472

.. code-block:: python

    def real_mul_impl(context, builder, sig, args):
        res = builder.fmul(*args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_mul_impl`` `numba/targets/numbers.py` lines 876-897

.. code-block:: python

    def complex_mul_impl(context, builder, sig, args):
        """
        (a+bi)(c+di)=(ac-bd)+i(ad+bc)
        """
        [cx, cy] = args
        ty = sig.args[0]
        x = context.make_complex(builder, ty, value=cx)
        y = context.make_complex(builder, ty, value=cy)
        z = context.make_complex(builder, ty)
        a = x.real
        b = x.imag
        c = y.real
        d = y.imag
        ac = builder.fmul(a, c)
        bd = builder.fmul(b, d)
        ad = builder.fmul(a, d)
        bc = builder.fmul(b, c)
        z.real = builder.fsub(ac, bd)
        z.imag = builder.fadd(ad, bc)
        res = z._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_times_number`` `numba/targets/npdatetime.py` lines 204-211

.. code-block:: python

    @lower_builtin('*', types.NPTimedelta, types.Integer)
    @lower_builtin('*', types.NPTimedelta, types.Float)
    def timedelta_times_number(context, builder, sig, args):
        res = _timedelta_times_number(context, builder,
                                       args[0], sig.args[0], args[1], sig.args[1],
                                       sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_times_number`` `numba/targets/npdatetime.py` lines 204-211

.. code-block:: python

    @lower_builtin('*', types.NPTimedelta, types.Integer)
    @lower_builtin('*', types.NPTimedelta, types.Float)
    def timedelta_times_number(context, builder, sig, args):
        res = _timedelta_times_number(context, builder,
                                       args[0], sig.args[0], args[1], sig.args[1],
                                       sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``number_times_timedelta`` `numba/targets/npdatetime.py` lines 212-219

.. code-block:: python

    @lower_builtin('*', types.Integer, types.NPTimedelta)
    @lower_builtin('*', types.Float, types.NPTimedelta)
    def number_times_timedelta(context, builder, sig, args):
        res = _timedelta_times_number(context, builder,
                                       args[1], sig.args[1], args[0], sig.args[0],
                                       sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``number_times_timedelta`` `numba/targets/npdatetime.py` lines 212-219

.. code-block:: python

    @lower_builtin('*', types.Integer, types.NPTimedelta)
    @lower_builtin('*', types.Float, types.NPTimedelta)
    def number_times_timedelta(context, builder, sig, args):
        res = _timedelta_times_number(context, builder,
                                       args[1], sig.args[1], args[0], sig.args[0],
                                       sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.lib.twodim_base.eye``
----------------------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``numpy_eye`` `numba/targets/arrayobj.py` lines 2860-2868

.. code-block:: python

    @lower_builtin(numpy.eye, types.Integer)
    def numpy_eye(context, builder, sig, args):

        def eye(n):
            return numpy.identity(n)

        res = context.compile_internal(builder, eye, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_eye`` `numba/targets/arrayobj.py` lines 2869-2877

.. code-block:: python

    @lower_builtin(numpy.eye, types.Integer, types.Integer)
    def numpy_eye(context, builder, sig, args):

        def eye(n, m):
            return numpy.eye(n, m, 0, numpy.float64)

        res = context.compile_internal(builder, eye, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Integer, Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_eye`` `numba/targets/arrayobj.py` lines 2878-2887

.. code-block:: python

    @lower_builtin(numpy.eye, types.Integer, types.Integer,
               types.Integer)
    def numpy_eye(context, builder, sig, args):

        def eye(n, m, k):
            return numpy.eye(n, m, k, numpy.float64)

        res = context.compile_internal(builder, eye, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Integer, Integer, Integer, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_eye`` `numba/targets/arrayobj.py` lines 2888-2906

.. code-block:: python

    @lower_builtin(numpy.eye, types.Integer, types.Integer,
               types.Integer, types.DTypeSpec)
    def numpy_eye(context, builder, sig, args):

        def eye(n, m, k, dtype):
            arr = numpy.zeros((n, m), dtype)
            if k >= 0:
                d = min(n, m - k)
                for i in range(d):
                    arr[i, i + k] = 1
            else:
                d = min(n + k, m)
                for i in range(d):
                    arr[i - k, i] = 1
            return arr

        res = context.compile_internal(builder, eye, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'list.count'``
---------------------------

signature `(List, any)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``list_count`` `numba/targets/listobj.py` lines 745-756

.. code-block:: python

    @lower_builtin("list.count", types.List, types.Any)
    def list_count(context, builder, sig, args):

        def list_count_impl(lst, value):
            res = 0
            for elem in lst:
                if elem == value:
                    res += 1
            return res

        return context.compile_internal(builder, list_count_impl, sig, args)


Lower Impl ``'random.expovariate'``
-----------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``expovariate_impl`` `numba/targets/randomimpl.py` lines 565-584

.. code-block:: python

    @lower("random.expovariate",
               types.Float)
    def expovariate_impl(context, builder, sig, args):
        _random = random.random
        _log = math.log

        def expovariate_impl(lambd):
            """Exponential distribution.  Taken from CPython.
            """
            # lambd: rate lambd = 1/mean
            # ('lambda' is a Python reserved word)

            # we use 1-random() instead of random() to preclude the
            # possibility of taking the log of zero.
            return -_log(1.0 - _random()) / lambd

        res = context.compile_internal(builder, expovariate_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``cmath.atanh``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``atanh_impl`` `numba/targets/cmathimpl.py` lines 471-524

.. code-block:: python

    @lower(cmath.atanh, types.Complex)
    def atanh_impl(context, builder, sig, args):
        LN_4 = math.log(4)
        THRES_LARGE = math.sqrt(mathimpl.FLT_MAX / 4)
        THRES_SMALL = math.sqrt(mathimpl.FLT_MIN)
        PI_12 = math.pi / 2

        def atanh_impl(z):
            """cmath.atanh(z)"""
            # CPython's algorithm (see c_atanh() in cmathmodule.c)
            if z.real < 0.:
                # Reduce to case where z.real >= 0., using atanh(z) = -atanh(-z).
                negate = True
                z = -z
            else:
                negate = False

            ay = abs(z.imag)
            if math.isnan(z.real) or z.real > THRES_LARGE or ay > THRES_LARGE:
                if math.isinf(z.imag):
                    real = math.copysign(0., z.real)
                elif math.isinf(z.real):
                    real = 0.
                else:
                    # may be safe from overflow, depending on hypot's implementation...
                    h = math.hypot(z.real * 0.5, z.imag * 0.5)
                    real = z.real/4./h/h
                imag = -math.copysign(PI_12, -z.imag)
            elif z.real == 1. and ay < THRES_SMALL:
                # C99 standard says:  atanh(1+/-0.) should be inf +/- 0j
                if ay == 0.:
                    real = INF
                    imag = z.imag
                else:
                    real = -math.log(math.sqrt(ay) /
                                     math.sqrt(math.hypot(ay, 2.)))
                    imag = math.copysign(math.atan2(2., -ay) / 2, z.imag)
            else:
                sqay = ay * ay
                zr1 = 1 - z.real
                real = math.log1p(4. * z.real / (zr1 * zr1 + sqay)) * 0.25
                imag = -math.atan2(-2. * z.imag,
                                   zr1 * (1 + z.real) - sqay) * 0.5

            if math.isnan(z.imag):
                imag = NAN
            if negate:
                return complex(-real, -imag)
            else:
                return complex(real, imag)

        res = context.compile_internal(builder, atanh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'array.reshape'``
------------------------------

signature `(Array, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_reshape`` `numba/targets/arrayobj.py` lines 1169-1229

.. code-block:: python

    @lower_builtin('array.reshape', types.Array, types.BaseTuple)
    def array_reshape(context, builder, sig, args):
        aryty = sig.args[0]
        retty = sig.return_type
        shapety = sig.args[1]
        shape = args[1]

        ll_intp = context.get_value_type(types.intp)
        ll_shape = lc.Type.array(ll_intp, shapety.count)

        ary = make_array(aryty)(context, builder, args[0])

        # Create a shape array (no heap allocation)
        shape_ary_ty = types.Array(dtype=shapety.dtype, ndim=1, layout='C')

        newshape = cgutils.alloca_once(builder, ll_shape)
        builder.store(shape, newshape)

        shape_ary = make_array(shape_ary_ty)(context, builder)
        shape_itemsize = context.get_constant(types.intp,
                                              context.get_abi_sizeof(ll_intp))
        populate_array(shape_ary,
                       data=builder.bitcast(newshape, ll_intp.as_pointer()),
                       shape=[context.get_constant(types.intp, shapety.count)],
                       strides=[shape_itemsize],
                       itemsize=shape_itemsize,
                       meminfo=None)

        # Compute the original array size
        size = ary.nitems

        # Call our normalizer which will fix the shape array in case of negative
        # shape value
        context.compile_internal(builder, normalize_reshape_value,
                                 typing.signature(types.void,
                                                  types.uintp, shape_ary_ty),
                                 [size, shape_ary._getvalue()])

        # Perform reshape (nocopy)
        newnd = shapety.count
        newstrides = cgutils.alloca_once(builder, ll_shape)

        ok = _attempt_nocopy_reshape(context, builder, aryty, ary, newnd,
                                     newshape, newstrides)
        fail = builder.icmp_unsigned('==', ok, lc.Constant.int(ok.type, 0))

        with builder.if_then(fail):
            msg = "incompatible shape for array"
            context.call_conv.return_user_exc(builder, NotImplementedError, (msg,))

        ret = make_array(retty)(context, builder)
        populate_array(ret,
                       data=ary.data,
                       shape=builder.load(newshape),
                       strides=builder.load(newstrides),
                       itemsize=ary.itemsize,
                       meminfo=ary.meminfo,
                       parent=ary.parent)
        res = ret._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(Array, *any)`
~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_reshape_vararg`` `numba/targets/arrayobj.py` lines 1231-1249

.. code-block:: python

    @lower_builtin('array.reshape', types.Array, types.VarArg(types.Any))
    def array_reshape_vararg(context, builder, sig, args):
        # types
        aryty = sig.args[0]
        dimtys = sig.args[1:]
        # values
        ary = args[0]
        dims = args[1:]
        # coerce all types to intp
        dims = [context.cast(builder, val, ty, types.intp)
                for ty, val in zip(dimtys, dims)]
        # make a tuple
        shape = cgutils.pack_array(builder, dims, dims[0].type)

        shapety = types.UniTuple(dtype=types.intp, count=len(dims))
        new_sig = typing.signature(sig.return_type, aryty, shapety)
        new_args = ary, shape
        return array_reshape(context, builder, new_sig, new_args)


Lower Impl ``_operator.ilshift``
--------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.imod``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.itruediv``
---------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.ior``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``builtins.print``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``print_varargs`` `numba/targets/printimpl.py` lines 70-83

.. code-block:: python

    @lower(print, types.VarArg(types.Any))
    def print_varargs(context, builder, sig, args):
        py = context.get_python_api(builder)
        for i, (argtype, argval) in enumerate(zip(sig.args, args)):
            signature = typing.signature(types.none, argtype)
            imp = context.get_function("print_item", signature)
            imp(builder, [argval])
            if i < len(args) - 1:
                py.print_string(' ')
        py.print_string('\n')

        res = context.get_dummy_value()
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``_operator.ixor``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'reciprocal'>``
-----------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.vonmises'``
-----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``vonmisesvariate_impl`` `numba/targets/randomimpl.py` lines 696-701

.. code-block:: python

    @lower("np.random.vonmises",
               types.Float, types.Float)
    def vonmisesvariate_impl(context, builder, sig, args):
        res = _vonmisesvariate_impl(context, builder, sig, args, np.random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``_operator.iand``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'array.sum'``
--------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_sum`` `numba/targets/arraymath.py` lines 28-42

.. code-block:: python

    @lower_builtin(numpy.sum, types.Array)
    @lower_builtin("array.sum", types.Array)
    def array_sum(context, builder, sig, args):
        zero = sig.return_type(0)

        def array_sum_impl(arr):
            c = zero
            for v in numpy.nditer(arr):
                c += v.item()
            return c

        res = context.compile_internal(builder, array_sum_impl, sig, args,
                                        locals=dict(c=sig.return_type))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``_operator.irshift``
--------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``cmath.sinh``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``sinh_impl`` `numba/targets/cmathimpl.py` lines 307-331

.. code-block:: python

    @lower(cmath.sinh, types.Complex)
    def sinh_impl(context, builder, sig, args):
        def sinh_impl(z):
            """cmath.sinh(z)"""
            x = z.real
            y = z.imag
            if math.isinf(x):
                if math.isnan(y):
                    # x = +/-inf, y = NaN => cmath.sinh(x + y j) = x + NaN * j
                    real = x
                    imag = y
                else:
                    real = math.cos(y)
                    imag = math.sin(y)
                    if real != 0.:
                        real *= x
                    if imag != 0.:
                        imag *= abs(x)
                return complex(real, imag)
            return complex(math.cos(y) * math.sinh(x),
                           math.sin(y) * math.cosh(x))

        res = context.compile_internal(builder, sinh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``_operator.isub``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.iadd``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'random.uniform'``
-------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``uniform_impl`` `numba/targets/randomimpl.py` lines 379-383

.. code-block:: python

    @lower("random.uniform", types.Float, types.Float)
    def uniform_impl(context, builder, sig, args):
        res = uniform_impl(context, builder, sig, args, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'log2'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numba.types.functions.NumberClass``
------------------------------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``number_constructor`` `numba/targets/builtins.py` lines 229-243

.. code-block:: python

    @lower_builtin(types.NumberClass, types.Any)
    def number_constructor(context, builder, sig, args):
        """
        Call a number class, e.g. np.int32(...)
        """
        if isinstance(sig.return_type, types.Array):
            # Array constructor
            impl = context.get_function(numpy.array, sig)
            return impl(builder, args)
        else:
            # Scalar constructor
            [val] = args
            [valty] = sig.args
            return context.cast(builder, val, valty, sig.return_type)


Lower Impl ``'random.paretovariate'``
-------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``paretovariate_impl`` `numba/targets/randomimpl.py` lines 635-648

.. code-block:: python

    @lower("random.paretovariate", types.Float)
    def paretovariate_impl(context, builder, sig, args):
        _random = random.random

        def paretovariate_impl(alpha):
            """Pareto distribution.  Taken from CPython."""
            # Jain, pg. 495
            u = 1.0 - _random()
            return 1.0 / u ** (1.0/alpha)

        res = context.compile_internal(builder, paretovariate_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``_operator.or_``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.ifloordiv``
----------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'np.random.power'``
--------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``power_impl`` `numba/targets/randomimpl.py` lines 1043-1054

.. code-block:: python

    @lower("np.random.power", types.Float)
    def power_impl(context, builder, sig, args):

        def power_impl(a):
            if a <= 0.0:
                raise ValueError("power(): a <= 0")
            return math.pow(1 - math.exp(-np.random.standard_exponential()),
                            1./a)

        res = context.compile_internal(builder, power_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'**='``
--------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``builtins.range``
-----------------------------

signature `(int32)`
~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range1_impl`` `numba/targets/rangeobj.py` lines 23-37

.. code-block:: python

    @lower_builtin(range, int_type)
    def range1_impl(context, builder, sig, args):
        """
        range(stop: int) -> range object
        """
        [stop] = args
        state = RangeState(context, builder)
        state.start = context.get_constant(int_type, 0)
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range2_impl`` `numba/targets/rangeobj.py` lines 38-52

.. code-block:: python

    @lower_builtin(range, int_type, int_type)
    def range2_impl(context, builder, sig, args):
        """
        range(start: int, stop: int) -> range object
        """
        start, stop = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(int32, int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range3_impl`` `numba/targets/rangeobj.py` lines 53-67

.. code-block:: python

    @lower_builtin(range, int_type, int_type, int_type)
    def range3_impl(context, builder, sig, args):
        """
        range(start: int, stop: int, step: int) -> range object
        """
        [start, stop, step] = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = step
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range1_impl`` `numba/targets/rangeobj.py` lines 23-37

.. code-block:: python

    @lower_builtin(range, int_type)
    def range1_impl(context, builder, sig, args):
        """
        range(stop: int) -> range object
        """
        [stop] = args
        state = RangeState(context, builder)
        state.start = context.get_constant(int_type, 0)
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range2_impl`` `numba/targets/rangeobj.py` lines 38-52

.. code-block:: python

    @lower_builtin(range, int_type, int_type)
    def range2_impl(context, builder, sig, args):
        """
        range(start: int, stop: int) -> range object
        """
        start, stop = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(int64, int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range3_impl`` `numba/targets/rangeobj.py` lines 53-67

.. code-block:: python

    @lower_builtin(range, int_type, int_type, int_type)
    def range3_impl(context, builder, sig, args):
        """
        range(start: int, stop: int, step: int) -> range object
        """
        [start, stop, step] = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = step
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range1_impl`` `numba/targets/rangeobj.py` lines 23-37

.. code-block:: python

    @lower_builtin(range, int_type)
    def range1_impl(context, builder, sig, args):
        """
        range(stop: int) -> range object
        """
        [stop] = args
        state = RangeState(context, builder)
        state.start = context.get_constant(int_type, 0)
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range2_impl`` `numba/targets/rangeobj.py` lines 38-52

.. code-block:: python

    @lower_builtin(range, int_type, int_type)
    def range2_impl(context, builder, sig, args):
        """
        range(start: int, stop: int) -> range object
        """
        start, stop = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = context.get_constant(int_type, 1)
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


signature `(uint64, uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.range3_impl`` `numba/targets/rangeobj.py` lines 53-67

.. code-block:: python

    @lower_builtin(range, int_type, int_type, int_type)
    def range3_impl(context, builder, sig, args):
        """
        range(start: int, stop: int, step: int) -> range object
        """
        [start, stop, step] = args
        state = RangeState(context, builder)
        state.start = start
        state.stop = stop
        state.step = step
        return impl_ret_untracked(context,
                                  builder,
                                  range_state_type,
                                  state._getvalue())


Lower Impl ``'-='``
-------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_inplace`` `numba/targets/setobj.py` lines 1262-1267

.. code-block:: python

    @lower_builtin(op, types.Set, types.Set)
    def set_inplace(context, builder, sig, args, op_impl=op_impl):
        assert sig.return_type == sig.args[0]
        op_impl(context, builder, sig, args)
        return impl_ret_borrowed(context, builder, sig.args[0], args[0])


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``_operator.imatmul``
--------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_inplace_impl`` `numba/targets/operatorimpl.py` lines 34-42

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_inplace_impl(context, builder, sig, args):
        first = sig.args[0]
        if first.mutable:
            impl = context.get_function(op + '=', sig)
        else:
            impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'bitwise_or'>``
-----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.sin``
------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``sin_impl`` `numba/targets/cmathimpl.py` lines 297-306

.. code-block:: python

    @lower(cmath.sin, types.Complex)
    def sin_impl(context, builder, sig, args):
        def sin_impl(z):
            """cmath.sin(z) = -j * cmath.sinh(z j)"""
            r = cmath.sinh(complex(-z.imag, z.real))
            return complex(r.imag, -r.real)

        res = context.compile_internal(builder, sin_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'~'``
------------------

signature `(Boolean)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_invert_impl`` `numba/targets/numbers.py` lines 351-358

.. code-block:: python

    def int_invert_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        # Invert before upcasting, for unsigned numbers
        res = builder.xor(val, Constant.all_ones(val.type))
        res = context.cast(builder, res, typ, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_invert_impl`` `numba/targets/numbers.py` lines 351-358

.. code-block:: python

    def int_invert_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        # Invert before upcasting, for unsigned numbers
        res = builder.xor(val, Constant.all_ones(val.type))
        res = context.cast(builder, res, typ, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``register_unary_operator_kernel.<locals>.lower_unary_operator`` `numba/targets/npyimpl.py` lines 462-465

.. code-block:: python

    def lower_unary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.lshift``
-------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.lib.function_base.sinc``
-------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_sinc`` `numba/targets/arraymath.py` lines 633-642

.. code-block:: python

    @lower_builtin(numpy.sinc, types.Array)
    def array_sinc(context, builder, sig, args):
        def array_sinc_impl(arr):
            out = numpy.zeros_like(arr)
            for index, val in numpy.ndenumerate(arr):
                out[index] = numpy.sinc(val)
            return out
        res = context.compile_internal(builder, array_sinc_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Number)`
~~~~~~~~~~~~~~~~~~~~

by ``scalar_sinc`` `numba/targets/arraymath.py` lines 643-654

.. code-block:: python

    @lower_builtin(numpy.sinc, types.Number)
    def scalar_sinc(context, builder, sig, args):
        scalar_dtype = sig.return_type
        def scalar_sinc_impl(val):
            if val == 0.e0: # to match np impl
                val = 1e-20
            val *= numpy.pi # np sinc is the normalised variant
            return numpy.sin(val)/val
        res = context.compile_internal(builder, scalar_sinc_impl, sig, args,
                                       locals=dict(c=scalar_dtype))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'list.index'``
---------------------------

signature `(List, any)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``list_index`` `numba/targets/listobj.py` lines 789-800

.. code-block:: python

    @lower_builtin("list.index", types.List, types.Any)
    def list_index(context, builder, sig, args):

        def list_index_impl(lst, value):
            for i in range(len(lst)):
                if lst[i] == value:
                    return i
            # XXX references are leaked when raising
            raise ValueError("value not in list")

        return context.compile_internal(builder, list_index_impl, sig, args)


signature `(List, any, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_index`` `numba/targets/listobj.py` lines 801-818

.. code-block:: python

    @lower_builtin("list.index", types.List, types.Any,
               types.Integer)
    def list_index(context, builder, sig, args):

        def list_index_impl(lst, value, start):
            n = len(lst)
            if start < 0:
                start += n
                if start < 0:
                    start = 0
            for i in range(start, len(lst)):
                if lst[i] == value:
                    return i
            # XXX references are leaked when raising
            raise ValueError("value not in list")

        return context.compile_internal(builder, list_index_impl, sig, args)


signature `(List, any, Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_index`` `numba/targets/listobj.py` lines 819-840

.. code-block:: python

    @lower_builtin("list.index", types.List, types.Any,
               types.Integer, types.Integer)
    def list_index(context, builder, sig, args):

        def list_index_impl(lst, value, start, stop):
            n = len(lst)
            if start < 0:
                start += n
                if start < 0:
                    start = 0
            if stop < 0:
                stop += n
            if stop > n:
                stop = n
            for i in range(start, stop):
                if lst[i] == value:
                    return i
            # XXX references are leaked when raising
            raise ValueError("value not in list")

        return context.compile_internal(builder, list_index_impl, sig, args)


Lower Impl ``_operator.pos``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'bitwise_xor'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'set.intersection_update'``
----------------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_intersection_update`` `numba/targets/setobj.py` lines 1216-1224

.. code-block:: python

    @lower_builtin("set.intersection_update", types.Set, types.Set)
    def set_intersection_update(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        inst.intersect(other)

        return context.get_dummy_value()


Lower Impl ``_operator.invert``
-------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'set.intersection'``
---------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_intersection`` `numba/targets/setobj.py` lines 1281-1295

.. code-block:: python

    @lower_builtin("&", types.Set, types.Set)
    @lower_builtin("set.intersection", types.Set, types.Set)
    def set_intersection(context, builder, sig, args):
        def intersection_impl(a, b):
            if len(a) < len(b):
                s = a.copy()
                s.intersection_update(b)
                return s
            else:
                s = b.copy()
                s.intersection_update(a)
                return s

        return context.compile_internal(builder, intersection_impl, sig, args)


Lower Impl ``_operator.mod``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'static_getitem'``
-------------------------------

signature `(Array, Const)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_record_getitem`` `numba/targets/arrayobj.py` lines 1623-1630

.. code-block:: python

    @lower_builtin('static_getitem', types.Array, types.Const)
    def array_record_getitem(context, builder, sig, args):
        index = args[1]
        if not isinstance(index, str):
            # This will fallback to normal getitem
            raise NotImplementedError
        return array_record_getattr(context, builder, sig.args[0], args[0], index)


signature `(Record, Const)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``record_getitem`` `numba/targets/arrayobj.py` lines 1692-1699

.. code-block:: python

    @lower_builtin('static_getitem', types.Record, types.Const)
    def record_getitem(context, builder, sig, args):
        """
        Record.__getitem__ redirects to getattr()
        """
        impl = context.get_getattr(sig.args[0], args[1])
        return impl(context, builder, sig.args[0], args[0], args[1])


signature `(BaseTuple, Const)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``static_getitem_tuple`` `numba/targets/tupleobj.py` lines 225-242

.. code-block:: python

    @lower_builtin('static_getitem', types.BaseTuple, types.Const)
    def static_getitem_tuple(context, builder, sig, args):
        tupty, _ = sig.args
        tup, idx = args
        if isinstance(idx, int):
            if idx < 0:
                idx += len(tupty)
            if not 0 <= idx < len(tupty):
                raise IndexError("cannot index at %d in %s" % (idx, tupty))
            res = builder.extract_value(tup, idx)
        elif isinstance(idx, slice):
            items = cgutils.unpack_tuple(builder, tup)[idx]
            res = context.make_tuple(builder, sig.return_type, items)
        else:
            raise NotImplementedError("unexpected index %r for %s"
                                      % (idx, sig.args[0]))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``builtins.sorted``
------------------------------

signature `(IterableType, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``sorted_impl`` `numba/targets/listobj.py` lines 952-965

.. code-block:: python

    @lower_builtin(sorted, types.IterableType)
    @lower_builtin(sorted, types.IterableType, types.Boolean)
    def sorted_impl(context, builder, sig, args):
        if len(args) == 1:
            sig = typing.signature(sig.return_type, *sig.args + (types.boolean,))
            args = tuple(args) + (cgutils.false_bit,)

        def sorted_impl(it, reverse):
            lst = list(it)
            lst.sort(reverse=reverse)
            return lst

        return context.compile_internal(builder, sorted_impl, sig, args)


signature `(IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``sorted_impl`` `numba/targets/listobj.py` lines 952-965

.. code-block:: python

    @lower_builtin(sorted, types.IterableType)
    @lower_builtin(sorted, types.IterableType, types.Boolean)
    def sorted_impl(context, builder, sig, args):
        if len(args) == 1:
            sig = typing.signature(sig.return_type, *sig.args + (types.boolean,))
            args = tuple(args) + (cgutils.false_bit,)

        def sorted_impl(it, reverse):
            lst = list(it)
            lst.sort(reverse=reverse)
            return lst

        return context.compile_internal(builder, sorted_impl, sig, args)


Lower Impl ``_operator.xor``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.and_``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.not_``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'/'``
------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_truediv_impl`` `numba/targets/numbers.py` lines 137-147

.. code-block:: python

    @lower_builtin('/', types.Integer, types.Integer)
    def int_truediv_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        with cgutils.if_zero(builder, b):
            context.error_model.fp_zero_division(builder, ("division by zero",))
        res = builder.fdiv(a, b)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_div_impl`` `numba/targets/numbers.py` lines 474-479

.. code-block:: python

    def real_div_impl(context, builder, sig, args):
        with cgutils.if_zero(builder, args[1]):
            context.error_model.fp_zero_division(builder, ("division by zero",))
        res = builder.fdiv(*args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_div_impl`` `numba/targets/numbers.py` lines 901-931

.. code-block:: python

    def complex_div_impl(context, builder, sig, args):
        def complex_div(a, b):
            # This is CPython's algorithm (in _Py_c_quot()).
            areal = a.real
            aimag = a.imag
            breal = b.real
            bimag = b.imag
            if not breal and not bimag:
                raise ZeroDivisionError("complex division by zero")
            if abs(breal) >= abs(bimag):
                # Divide tops and bottom by b.real
                if not breal:
                    return complex(NAN, NAN)
                ratio = bimag / breal
                denom = breal + bimag * ratio
                return complex(
                    (areal + aimag * ratio) / denom,
                    (aimag - areal * ratio) / denom)
            else:
                # Divide tops and bottom by b.imag
                if not bimag:
                    return complex(NAN, NAN)
                ratio = breal / bimag
                denom = breal * ratio + bimag
                return complex(
                    (a.real * ratio + a.imag) / denom,
                    (a.imag * ratio - a.real) / denom)

        res = context.compile_internal(builder, complex_div, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_timedelta`` `numba/targets/npdatetime.py` lines 247-263

.. code-block:: python

    @lower_builtin('/', *TIMEDELTA_BINOP_SIG)
    @lower_builtin('/?', *TIMEDELTA_BINOP_SIG)
    def timedelta_over_timedelta(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        not_nan = are_not_nat(builder, [va, vb])
        ll_ret_type = context.get_value_type(sig.return_type)
        ret = cgutils.alloca_once(builder, ll_ret_type, name='ret')
        builder.store(Constant.real(ll_ret_type, float('nan')), ret)
        with cgutils.if_likely(builder, not_nan):
            va, vb = normalize_timedeltas(context, builder, va, vb, ta, tb)
            va = builder.sitofp(va, ll_ret_type)
            vb = builder.sitofp(vb, ll_ret_type)
            builder.store(builder.fdiv(va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.rshift``
-------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``numpy.core.fromnumeric.nonzero``
---------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_nonzero`` `numba/targets/arraymath.py` lines 693-751

.. code-block:: python

    @lower_builtin(numpy.nonzero, types.Array)
    @lower_builtin("array.nonzero", types.Array)
    @lower_builtin(numpy.where, types.Array)
    def array_nonzero(context, builder, sig, args):
        aryty = sig.args[0]
        # Return type is a N-tuple of 1D C-contiguous arrays
        retty = sig.return_type
        outaryty = retty.dtype
        ndim = aryty.ndim
        nouts = retty.count

        ary = make_array(aryty)(context, builder, args[0])
        shape = cgutils.unpack_tuple(builder, ary.shape)
        strides = cgutils.unpack_tuple(builder, ary.strides)
        data = ary.data
        layout = aryty.layout

        # First count the number of non-zero elements
        zero = context.get_constant(types.intp, 0)
        one = context.get_constant(types.intp, 1)
        count = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                builder.store(builder.add(builder.load(count), one), count)

        # Then allocate output arrays of the right size
        out_shape = (builder.load(count),)
        outs = [_empty_nd_impl(context, builder, outaryty, out_shape)._getvalue()
                for i in range(nouts)]
        outarys = [make_array(outaryty)(context, builder, out) for out in outs]
        out_datas = [out.data for out in outarys]

        # And fill them up
        index = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                # Store element indices in output arrays
                if not indices:
                    # For a 0-d array, store 0 in the unique output array
                    indices = (zero,)
                cur = builder.load(index)
                for i in range(nouts):
                    ptr = cgutils.get_item_pointer2(builder, out_datas[i],
                                                    out_shape, (),
                                                    'C', [cur])
                    store_item(context, builder, outaryty, indices[i], ptr)
                builder.store(builder.add(cur, one), index)

        tup = context.make_tuple(builder, sig.return_type, outs)
        return impl_ret_new_ref(context, builder, sig.return_type, tup)


Lower Impl ``_operator.mul``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'arctan2'>``
--------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.sub``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``_operator.add``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``math.acosh``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'arctanh'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.truediv``
--------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'in'``
-------------------

signature `(any, Sequence)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``in_seq`` `numba/targets/listobj.py` lines 539-548

.. code-block:: python

    @lower_builtin("in", types.Any, types.Sequence)
    def in_seq(context, builder, sig, args):
        def seq_contains_impl(value, lst):
            for elem in lst:
                if elem == value:
                    return True
            return False

        return context.compile_internal(builder, seq_contains_impl, sig, args)


signature `(any, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``in_set`` `numba/targets/setobj.py` lines 1133-1137

.. code-block:: python

    @lower_builtin("in", types.Any, types.Set)
    def in_set(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[1], args[1])
        return inst.contains(args[0])


Lower Impl ``_operator.floordiv``
---------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'np.random.weibull'``
----------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``weibull_impl`` `numba/targets/randomimpl.py` lines 677-689

.. code-block:: python

    @lower("np.random.weibull", types.Float)
    def weibull_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def weibull_impl(beta):
            # Same as weibullvariate(1.0, beta)
            u = 1.0 - _random()
            return (-_log(u)) ** (1.0/beta)

        res = context.compile_internal(builder, weibull_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'ceil'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'^'``
------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_symmetric_difference`` `numba/targets/setobj.py` lines 1296-1311

.. code-block:: python

    @lower_builtin("^", types.Set, types.Set)
    @lower_builtin("set.symmetric_difference", types.Set, types.Set)
    def set_symmetric_difference(context, builder, sig, args):
        def symmetric_difference_impl(a, b):
            if len(a) > len(b):
                s = a.copy()
                s.symmetric_difference_update(b)
                return s
            else:
                s = b.copy()
                s.symmetric_difference_update(a)
                return s

        return context.compile_internal(builder, symmetric_difference_impl,
                                        sig, args)


signature `(Boolean, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_xor_impl`` `numba/targets/numbers.py` lines 326-333

.. code-block:: python

    def int_xor_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.xor(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_xor_impl`` `numba/targets/numbers.py` lines 326-333

.. code-block:: python

    def int_xor_impl(context, builder, sig, args):
        [at, bt] = sig.args
        [av, bv] = args
        cav = context.cast(builder, av, at, sig.return_type)
        cbc = context.cast(builder, bv, bt, sig.return_type)
        res = builder.xor(cav, cbc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``_operator.matmul``
-------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``<ufunc 'conjugate'>``
----------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'copysign'>``
---------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``builtins.complex``
-------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``complex_impl`` `numba/targets/builtins.py` lines 201-227

.. code-block:: python

    @lower_builtin(complex, types.VarArg(types.Any))
    def complex_impl(context, builder, sig, args):
        complex_type = sig.return_type
        float_type = complex_type.underlying_float
        if len(sig.args) == 1:
            [argty] = sig.args
            [arg] = args
            if isinstance(argty, types.Complex):
                # Cast Complex* to Complex*
                res = context.cast(builder, arg, argty, complex_type)
                return impl_ret_untracked(context, builder, sig.return_type, res)
            else:
                real = context.cast(builder, arg, argty, float_type)
                imag = context.get_constant(float_type, 0)

        elif len(sig.args) == 2:
            [realty, imagty] = sig.args
            [real, imag] = args
            real = context.cast(builder, real, realty, float_type)
            imag = context.cast(builder, imag, imagty, float_type)

        cmplx = context.make_complex(builder, complex_type)
        cmplx.real = real
        cmplx.imag = imag
        res = cmplx._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``_operator.contains``
---------------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'print_item'``
---------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_print_impl`` `numba/targets/printimpl.py` lines 17-29

.. code-block:: python

    @lower("print_item", types.Integer)
    def int_print_impl(context, builder, sig, args):
        [x] = args
        py = context.get_python_api(builder)
        if sig.args[0].signed:
            intobj = py.long_from_signed_int(x)
        else:
            intobj = py.long_from_unsigned_int(x)
        py.print_object(intobj)
        py.decref(intobj)
        res = context.get_dummy_value()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``real_print_impl`` `numba/targets/printimpl.py` lines 31-41

.. code-block:: python

    @lower("print_item", types.Float)
    def real_print_impl(context, builder, sig, args):
        [x] = args
        py = context.get_python_api(builder)
        szval = context.cast(builder, x, sig.args[0], types.float64)
        intobj = py.float_from_double(szval)
        py.print_object(intobj)
        py.decref(intobj)
        res = context.get_dummy_value()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Boolean)`
~~~~~~~~~~~~~~~~~~~~~

by ``bool_print_impl`` `numba/targets/printimpl.py` lines 43-52

.. code-block:: python

    @lower("print_item", types.Boolean)
    def bool_print_impl(context, builder, sig, args):
        [x] = args
        py = context.get_python_api(builder)
        boolobj = py.bool_from_bool(x)
        py.print_object(boolobj)
        py.decref(boolobj)
        res = context.get_dummy_value()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(CharSeq)`
~~~~~~~~~~~~~~~~~~~~~

by ``print_charseq`` `numba/targets/printimpl.py` lines 54-68

.. code-block:: python

    @lower("print_item", types.CharSeq)
    def print_charseq(context, builder, sig, args):
        [tx] = sig.args
        [x] = args
        py = context.get_python_api(builder)
        xp = cgutils.alloca_once(builder, x.type)
        builder.store(x, xp)
        byteptr = builder.bitcast(xp, Type.pointer(Type.int(8)))
        size = context.get_constant(types.intp, tx.count)
        cstr = py.bytes_from_string_and_size(byteptr, size)
        py.print_object(cstr)
        py.decref(cstr)
        res = context.get_dummy_value()
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``builtins.next``
----------------------------

signature `(IteratorType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``next_impl`` `numba/targets/builtins.py` lines 279-290

.. code-block:: python

    @lower_builtin(next, types.IteratorType)
    def next_impl(context, builder, sig, args):
        iterty, = sig.args
        iterval, = args

        res = call_iternext(context, builder, iterty, iterval)

        with builder.if_then(builder.not_(res.is_valid()), likely=False):
            context.call_conv.return_user_exc(builder, StopIteration, ())

        return res.yielded_value()


Lower Impl ``<ufunc 'cos'>``
----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.nditer``
---------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``make_array_nditer`` `numba/targets/arrayobj.py` lines 2558-2576

.. code-block:: python

    @lower_builtin(numpy.nditer, types.Any)
    def make_array_nditer(context, builder, sig, args):
        """
        nditer(...)
        """
        nditerty = sig.return_type
        arrtys = nditerty.arrays

        if isinstance(sig.args[0], types.BaseTuple):
            arrays = cgutils.unpack_tuple(builder, args[0])
        else:
            arrays = [args[0]]

        nditer = make_nditer_cls(nditerty)(context, builder)
        nditer.init_specific(context, builder, arrtys, arrays)

        res = nditer._getvalue()
        return impl_ret_borrowed(context, builder, nditerty, res)


Lower Impl ``builtins.pow``
---------------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_power_impl`` `numba/targets/numbers.py` lines 650-660

.. code-block:: python

    def real_power_impl(context, builder, sig, args):
        x, y = args
        module = builder.module
        if context.implement_powi_as_math_call:
            imp = context.get_function(math.pow, sig)
            res = imp(builder, args)
        else:
            fn = lc.Function.intrinsic(module, lc.INTR_POW, [y.type])
            res = builder.call(fn, (x, y))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex128_power_impl`` `numba/targets/numbers.py` lines 805-843

.. code-block:: python

    @lower_builtin("**", types.Complex, types.Complex)
    @lower_builtin(pow, types.Complex, types.Complex)
    def complex128_power_impl(context, builder, sig, args):
        [ca, cb] = args
        ty = sig.args[0]
        fty = ty.underlying_float
        a = context.make_helper(builder, ty, value=ca)
        b = context.make_helper(builder, ty, value=cb)
        c = context.make_helper(builder, ty)
        module = builder.module
        pa = a._getpointer()
        pb = b._getpointer()
        pc = c._getpointer()

        # Optimize for square because cpow looses a lot of precsiion
        TWO = context.get_constant(fty, 2)
        ZERO = context.get_constant(fty, 0)

        b_real_is_two = builder.fcmp(lc.FCMP_OEQ, b.real, TWO)
        b_imag_is_zero = builder.fcmp(lc.FCMP_OEQ, b.imag, ZERO)
        b_is_two = builder.and_(b_real_is_two, b_imag_is_zero)

        with builder.if_else(b_is_two) as (then, otherwise):
            with then:
                # Lower as multiplication
                res = complex_mul_impl(context, builder, sig, (ca, ca))
                cres = context.make_helper(builder, ty, value=res)
                c.real = cres.real
                c.imag = cres.imag

            with otherwise:
                # Lower with call to external function
                fnty = Type.function(Type.void(), [pa.type] * 3)
                cpow = module.get_or_insert_function(fnty, name="numba.math.cpow")
                builder.call(cpow, (pa, pb, pc))

        res = builder.load(pc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'np.random.logistic'``
-----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``logistic_impl`` `numba/targets/randomimpl.py` lines 918-932

.. code-block:: python

    @lower("np.random.logistic")
    @lower("np.random.logistic", types.Float)
    @lower("np.random.logistic", types.Float, types.Float)
    def logistic_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def logistic_impl(loc, scale):
            U = _random()
            return loc + scale * _log(U / (1.0 - U))

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, logistic_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``logistic_impl`` `numba/targets/randomimpl.py` lines 918-932

.. code-block:: python

    @lower("np.random.logistic")
    @lower("np.random.logistic", types.Float)
    @lower("np.random.logistic", types.Float, types.Float)
    def logistic_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def logistic_impl(loc, scale):
            U = _random()
            return loc + scale * _log(U / (1.0 - U))

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, logistic_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``logistic_impl`` `numba/targets/randomimpl.py` lines 918-932

.. code-block:: python

    @lower("np.random.logistic")
    @lower("np.random.logistic", types.Float)
    @lower("np.random.logistic", types.Float, types.Float)
    def logistic_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def logistic_impl(loc, scale):
            U = _random()
            return loc + scale * _log(U / (1.0 - U))

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, logistic_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'np.random.randint'``
----------------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``randint_impl_2`` `numba/targets/randomimpl.py` lines 364-371

.. code-block:: python

    @lower("np.random.randint", types.Integer)
    def randint_impl_2(context, builder, sig, args):
        stop, = args
        start = ir.Constant(stop.type, 0)
        step = ir.Constant(stop.type, 1)
        res = _randrange_impl(context, builder, start, stop, step, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``randrange_impl_2`` `numba/targets/randomimpl.py` lines 372-378

.. code-block:: python

    @lower("np.random.randint", types.Integer, types.Integer)
    def randrange_impl_2(context, builder, sig, args):
        start, stop = args
        step = ir.Constant(start.type, 1)
        res = _randrange_impl(context, builder, start, stop, step, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'/='``
-------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``'np.random.gamma'``
--------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``gammavariate_impl`` `numba/targets/randomimpl.py` lines 457-464

.. code-block:: python

    @lower("np.random.standard_gamma", types.Float)
    @lower("np.random.gamma", types.Float)
    @lower("np.random.gamma", types.Float, types.Float)
    def gammavariate_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (None, 1.0))
        res = _gammavariate_impl(context, builder, sig, args, np.random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``gammavariate_impl`` `numba/targets/randomimpl.py` lines 457-464

.. code-block:: python

    @lower("np.random.standard_gamma", types.Float)
    @lower("np.random.gamma", types.Float)
    @lower("np.random.gamma", types.Float, types.Float)
    def gammavariate_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (None, 1.0))
        res = _gammavariate_impl(context, builder, sig, args, np.random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'<'``
------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_lt`` `numba/targets/listobj.py` lines 685-699

.. code-block:: python

    @lower_builtin('<', types.List, types.List)
    def list_lt(context, builder, sig, args):

        def list_lt_impl(a, b):
            m = len(a)
            n = len(b)
            for i in range(min(m, n)):
                if a[i] < b[i]:
                    return True
                elif a[i] > b[i]:
                    return False
            return m < n

        return context.compile_internal(builder, list_lt_impl, sig, args)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_lt`` `numba/targets/setobj.py` lines 1367-1373

.. code-block:: python

    @lower_builtin("<", types.Set, types.Set)
    def set_lt(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        return inst.issubset(other, strict=True)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ult_impl`` `numba/targets/numbers.py` lines 243-246

.. code-block:: python

    def int_ult_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint8, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ult_impl`` `numba/targets/numbers.py` lines 243-246

.. code-block:: python

    def int_ult_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint32, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ult_impl`` `numba/targets/numbers.py` lines 243-246

.. code-block:: python

    def int_ult_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint16, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ult_impl`` `numba/targets/numbers.py` lines 243-246

.. code-block:: python

    def int_ult_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ult_impl`` `numba/targets/numbers.py` lines 243-246

.. code-block:: python

    def int_ult_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int8, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_slt_impl`` `numba/targets/numbers.py` lines 223-226

.. code-block:: python

    def int_slt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_slt_impl`` `numba/targets/numbers.py` lines 223-226

.. code-block:: python

    def int_slt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_slt_impl`` `numba/targets/numbers.py` lines 223-226

.. code-block:: python

    def int_slt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int16, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_slt_impl`` `numba/targets/numbers.py` lines 223-226

.. code-block:: python

    def int_slt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_lt_impl`` `numba/targets/numbers.py` lines 662-665

.. code-block:: python

    def real_lt_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_OLT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_lt`` `numba/targets/tupleobj.py` lines 67-71

.. code-block:: python

    @lower_builtin('<', types.BaseTuple, types.BaseTuple)
    def tuple_lt(context, builder, sig, args):
        res = tuple_cmp_ordered(context, builder, '<', sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_ordering_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 291-306

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaT with something else
                # (i.e. NaT is <= everything else, since it's the smallest
                #  int64 value)
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'%'``
------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_rem_impl`` `numba/targets/numbers.py` lines 149-175

.. code-block:: python

    @lower_builtin('%', types.Integer, types.Integer)
    def int_rem_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = cgutils.alloca_once(builder, a.type)

        with builder.if_else(cgutils.is_scalar_zero(builder, b), likely=False
                             ) as (if_zero, if_non_zero):
            with if_zero:
                if not context.error_model.fp_zero_division(
                    builder, ("modulo by zero",)):
                    # No exception raised => return 0
                    # XXX We should also set the FPU exception status, but
                    # there's no easy way to do that from LLVM.
                    builder.store(b, res)
            with if_non_zero:
                if sig.return_type.signed:
                    _, rem = int_divmod(context, builder, a, b)
                else:
                    rem = builder.urem(a, b)
                builder.store(rem, res)

        return impl_ret_untracked(context, builder, sig.return_type,
                                  builder.load(res))


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_mod_impl`` `numba/targets/numbers.py` lines 612-629

.. code-block:: python

    def real_mod_impl(context, builder, sig, args):
        x, y = args
        res = cgutils.alloca_once(builder, x.type)
        with builder.if_else(cgutils.is_scalar_zero(builder, y), likely=False
                             ) as (if_zero, if_non_zero):
            with if_zero:
                if not context.error_model.fp_zero_division(
                    builder, ("modulo by zero",)):
                    # No exception raised => compute the nan result,
                    # and set the FP exception word for Numpy warnings.
                    rem = builder.frem(x, y)
                    builder.store(rem, res)
            with if_non_zero:
                _, rem = real_divmod(context, builder, x, y)
                builder.store(rem, res)
        return impl_ret_untracked(context, builder, sig.return_type,
                                  builder.load(res))


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'deg2rad'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'set.copy'``
-------------------------

signature `(Set)`
~~~~~~~~~~~~~~~~~

by ``set_copy`` `numba/targets/setobj.py` lines 1201-1206

.. code-block:: python

    @lower_builtin("set.copy", types.Set)
    def set_copy(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = inst.copy()
        return impl_ret_new_ref(context, builder, sig.return_type, other.value)


Lower Impl ``<ufunc 'fmin'>``
-----------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.max'``
--------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_max`` `numba/targets/arraymath.py` lines 185-201

.. code-block:: python

    @lower_builtin(numpy.max, types.Array)
    @lower_builtin("array.max", types.Array)
    def array_max(context, builder, sig, args):
        def array_max_impl(arry):
            it = numpy.nditer(arry)
            for view in it:
                max_value = view.item()
                break

            for view in it:
                v = view.item()
                if v > max_value:
                    max_value = v
            return max_value
        res = context.compile_internal(builder, array_max_impl, sig, args)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``'iternext'``
-------------------------

signature `(ArrayIterator)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(NumpyFlatType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(NumpyNdEnumerateType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(NumpyNdIndexType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(NumpyNdIterType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(ListIter)`
~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(SetIter)`
~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(EnumerateType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(ZipType)`
~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(Generator)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(range_iter_int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(range_iter_int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(range_iter_uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


signature `(UniTupleIter)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_impl.<locals>.wrapper`` `numba/targets/imputils.py` lines 302-309

.. code-block:: python

    def wrapper(context, builder, sig, args):
        pair_type = sig.return_type
        pairobj = context.make_helper(builder, pair_type)
        func(context, builder, sig, args,
             _IternextResult(context, builder, pairobj))
        return impl_ret_borrowed(context, builder,
                                 pair_type, pairobj._getvalue())


Lower Impl ``'+'``
------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_add`` `numba/targets/listobj.py` lines 557-578

.. code-block:: python

    @lower_builtin("+", types.List, types.List)
    def list_add(context, builder, sig, args):
        a = ListInstance(context, builder, sig.args[0], args[0])
        b = ListInstance(context, builder, sig.args[1], args[1])

        a_size = a.size
        b_size = b.size
        nitems = builder.add(a_size, b_size)
        dest = ListInstance.allocate(context, builder, sig.return_type, nitems)
        dest.size = nitems

        with cgutils.for_range(builder, a_size) as loop:
            value = a.getitem(loop.index)
            value = context.cast(builder, value, a.dtype, dest.dtype)
            dest.setitem(loop.index, value)
        with cgutils.for_range(builder, b_size) as loop:
            value = b.getitem(loop.index)
            value = context.cast(builder, value, b.dtype, dest.dtype)
            dest.setitem(builder.add(loop.index, a_size), value)

        return impl_ret_new_ref(context, builder, sig.return_type, dest.value)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_add_impl`` `numba/targets/numbers.py` lines 35-42

.. code-block:: python

    def int_add_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = builder.add(a, b, flags=_int_arith_flags(sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_positive_impl`` `numba/targets/numbers.py` lines 344-349

.. code-block:: python

    def int_positive_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        res = context.cast(builder, val, typ, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_add_impl`` `numba/targets/numbers.py` lines 459-462

.. code-block:: python

    def real_add_impl(context, builder, sig, args):
        res = builder.fadd(*args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``real_positive_impl`` `numba/targets/numbers.py` lines 705-710

.. code-block:: python

    def real_positive_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        res = context.cast(builder, val, typ, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_add_impl`` `numba/targets/numbers.py` lines 844-858

.. code-block:: python

    def complex_add_impl(context, builder, sig, args):
        [cx, cy] = args
        ty = sig.args[0]
        x = context.make_complex(builder, ty, value=cx)
        y = context.make_complex(builder, ty, value=cy)
        z = context.make_complex(builder, ty)
        a = x.real
        b = x.imag
        c = y.real
        d = y.imag
        z.real = builder.fadd(a, c)
        z.imag = builder.fadd(b, d)
        res = z._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``complex_positive_impl`` `numba/targets/numbers.py` lines 945-948

.. code-block:: python

    def complex_positive_impl(context, builder, sig, args):
        [val] = args
        return impl_ret_untracked(context, builder, sig.return_type, val)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_add`` `numba/targets/tupleobj.py` lines 21-25

.. code-block:: python

    @lower_builtin('+', types.BaseTuple, types.BaseTuple)
    def tuple_add(context, builder, sig, args):
        left, right = [cgutils.unpack_tuple(builder, x) for x in args]
        return context.make_tuple(builder, sig.return_type, left + right)


signature `(NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_pos_impl`` `numba/targets/npdatetime.py` lines 119-123

.. code-block:: python

    @lower_builtin('+', types.NPTimedelta)
    def timedelta_pos_impl(context, builder, sig, args):
        res =args[0]
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_add_impl`` `numba/targets/npdatetime.py` lines 162-173

.. code-block:: python

    @lower_builtin('+', *TIMEDELTA_BINOP_SIG)
    def timedelta_add_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_timedelta_result(builder)
        with cgutils.if_likely(builder, are_not_nat(builder, [va, vb])):
            va = scale_timedelta(context, builder, va, ta, sig.return_type)
            vb = scale_timedelta(context, builder, vb, tb, sig.return_type)
            builder.store(builder.add(va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``datetime_plus_timedelta`` `numba/targets/npdatetime.py` lines 476-485

.. code-block:: python

    @lower_builtin('+', types.NPDatetime, types.NPTimedelta)
    def datetime_plus_timedelta(context, builder, sig, args):
        dt_arg, td_arg = args
        dt_type, td_type = sig.args
        res = _datetime_plus_timedelta(context, builder,
                                        dt_arg, dt_type.unit,
                                        td_arg, td_type.unit,
                                        sig.return_type.unit)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_plus_datetime`` `numba/targets/npdatetime.py` lines 486-495

.. code-block:: python

    @lower_builtin('+', types.NPTimedelta, types.NPDatetime)
    def timedelta_plus_datetime(context, builder, sig, args):
        td_arg, dt_arg = args
        td_type, dt_type = sig.args
        res = _datetime_plus_timedelta(context, builder,
                                        dt_arg, dt_type.unit,
                                        td_arg, td_type.unit,
                                        sig.return_type.unit)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_positive_impl`` `numba/targets/npyimpl.py` lines 505-518

.. code-block:: python

    @lower('+', types.Array)
    def array_positive_impl(context, builder, sig, args):
        '''Lowering function for +(array) expressions.  Defined here
        (numba.targets.npyimpl) since the remaining array-operator
        lowering functions are also registered in this module.
        '''
        class _UnaryPositiveKernel(_Kernel):
            def generate(self, *args):
                [val] = args
                return val

        return numpy_ufunc_kernel(context, builder, sig, args,
                                  _UnaryPositiveKernel, explicit_output=False)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.sort``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``np_sort`` `numba/targets/arrayobj.py` lines 3386-3395

.. code-block:: python

    @lower_builtin(numpy.sort, types.Array)
    def np_sort(context, builder, sig, args):

        def np_sort_impl(a):
            res = a.copy()
            res.sort()
            return res

        return context.compile_internal(builder, np_sort_impl, sig, args)


Lower Impl ``<ufunc 'degrees'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.frexp``
-------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``frexp_impl`` `numba/targets/mathimpl.py` lines 259-274

.. code-block:: python

    @lower(math.frexp, types.Float)
    def frexp_impl(context, builder, sig, args):
        val, = args
        fltty = context.get_data_type(sig.args[0])
        intty = context.get_data_type(sig.return_type[1])
        expptr = cgutils.alloca_once(builder, intty, name='exp')
        fnty = Type.function(fltty, (fltty, Type.pointer(intty)))
        fname = {
            "float": "numba_frexpf",
            "double": "numba_frexp",
            }[str(fltty)]
        fn = builder.module.get_or_insert_function(fnty, name=fname)
        res = builder.call(fn, (val, expptr))
        res = cgutils.make_anonymous_struct(builder, (res, builder.load(expptr)))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'array.std'``
--------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_std`` `numba/targets/arraymath.py` lines 136-143

.. code-block:: python

    @lower_builtin(numpy.std, types.Array)
    @lower_builtin("array.std", types.Array)
    def array_std(context, builder, sig, args):
        def array_std_impl(arry):
            return arry.var() ** 0.5
        res = context.compile_internal(builder, array_std_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'equal'>``
------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.argmax``
--------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_argmax`` `numba/targets/arraymath.py` lines 254-272

.. code-block:: python

    @lower_builtin(numpy.argmax, types.Array)
    @lower_builtin("array.argmax", types.Array)
    def array_argmax(context, builder, sig, args):
        def array_argmax_impl(arry):
            for v in arry.flat:
                max_value = v
                max_idx = 0
                break

            idx = 0
            for v in arry.flat:
                if v > max_value:
                    max_value = v
                    max_idx = idx
                idx += 1
            return max_idx
        res = context.compile_internal(builder, array_argmax_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``numpy.core.multiarray.dot``
----------------------------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``dot_2`` `numba/targets/linalg.py` lines 309-330

.. code-block:: python

    @lower_builtin(numpy.dot, types.Array, types.Array)
    @lower_builtin('@', types.Array, types.Array)
    def dot_2(context, builder, sig, args):
        """
        np.dot(a, b)
        a @ b
        """
        ensure_blas()

        with make_contiguous(context, builder, sig, args) as (sig, args):
            ndims = [x.ndim for x in sig.args[:2]]
            if ndims == [2, 2]:
                return dot_2_mm(context, builder, sig, args)
            elif ndims == [2, 1]:
                return dot_2_mv(context, builder, sig, args)
            elif ndims == [1, 2]:
                return dot_2_vm(context, builder, sig, args)
            elif ndims == [1, 1]:
                return dot_2_vv(context, builder, sig, args)
            else:
                assert 0


signature `(Array, Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``dot_3`` `numba/targets/linalg.py` lines 482-498

.. code-block:: python

    @lower_builtin(numpy.dot, types.Array, types.Array,
                   types.Array)
    def dot_3(context, builder, sig, args):
        """
        np.dot(a, b, out)
        """
        ensure_blas()

        with make_contiguous(context, builder, sig, args) as (sig, args):
            ndims = set(x.ndim for x in sig.args[:2])
            if ndims == set([2]):
                return dot_3_mm(context, builder, sig, args)
            elif ndims == set([1, 2]):
                return dot_3_vm(context, builder, sig, args)
            else:
                assert 0


Lower Impl ``<ufunc 'exp'>``
----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'logaddexp2'>``
-----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'nextafter'>``
----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.round_``
--------------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``scalar_round_unary`` `numba/targets/arraymath.py` lines 559-563

.. code-block:: python

    @lower_builtin(numpy.round, types.Float)
    def scalar_round_unary(context, builder, sig, args):
        res =  _np_round_float(context, builder, sig.args[0], args[0])
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``scalar_round_unary`` `numba/targets/arraymath.py` lines 564-568

.. code-block:: python

    @lower_builtin(numpy.round, types.Integer)
    def scalar_round_unary(context, builder, sig, args):
        res = args[0]
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``scalar_round_unary_complex`` `numba/targets/arraymath.py` lines 569-577

.. code-block:: python

    @lower_builtin(numpy.round, types.Complex)
    def scalar_round_unary_complex(context, builder, sig, args):
        fltty = sig.args[0].underlying_float
        z = context.make_complex(builder, sig.args[0], args[0])
        z.real = _np_round_float(context, builder, fltty, z.real)
        z.imag = _np_round_float(context, builder, fltty, z.imag)
        res = z._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``scalar_round_binary_float`` `numba/targets/arraymath.py` lines 578-608

.. code-block:: python

    @lower_builtin(numpy.round, types.Float, types.Integer)
    @lower_builtin(numpy.round, types.Integer, types.Integer)
    def scalar_round_binary_float(context, builder, sig, args):
        def round_ndigits(x, ndigits):
            if math.isinf(x) or math.isnan(x):
                return x

            # NOTE: this is CPython's algorithm, but perhaps this is overkill
            # when emulating Numpy's behaviour.
            if ndigits >= 0:
                if ndigits > 22:
                    # pow1 and pow2 are each safe from overflow, but
                    # pow1*pow2 ~= pow(10.0, ndigits) might overflow.
                    pow1 = 10.0 ** (ndigits - 22)
                    pow2 = 1e22
                else:
                    pow1 = 10.0 ** ndigits
                    pow2 = 1.0
                y = (x * pow1) * pow2
                if math.isinf(y):
                    return x
                return (numpy.round(y) / pow2) / pow1

            else:
                pow1 = 10.0 ** (-ndigits)
                y = x / pow1
                return numpy.round(y) * pow1

        res = context.compile_internal(builder, round_ndigits, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``scalar_round_binary_float`` `numba/targets/arraymath.py` lines 578-608

.. code-block:: python

    @lower_builtin(numpy.round, types.Float, types.Integer)
    @lower_builtin(numpy.round, types.Integer, types.Integer)
    def scalar_round_binary_float(context, builder, sig, args):
        def round_ndigits(x, ndigits):
            if math.isinf(x) or math.isnan(x):
                return x

            # NOTE: this is CPython's algorithm, but perhaps this is overkill
            # when emulating Numpy's behaviour.
            if ndigits >= 0:
                if ndigits > 22:
                    # pow1 and pow2 are each safe from overflow, but
                    # pow1*pow2 ~= pow(10.0, ndigits) might overflow.
                    pow1 = 10.0 ** (ndigits - 22)
                    pow2 = 1e22
                else:
                    pow1 = 10.0 ** ndigits
                    pow2 = 1.0
                y = (x * pow1) * pow2
                if math.isinf(y):
                    return x
                return (numpy.round(y) / pow2) / pow1

            else:
                pow1 = 10.0 ** (-ndigits)
                y = x / pow1
                return numpy.round(y) * pow1

        res = context.compile_internal(builder, round_ndigits, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``scalar_round_binary_complex`` `numba/targets/arraymath.py` lines 609-617

.. code-block:: python

    @lower_builtin(numpy.round, types.Complex, types.Integer)
    def scalar_round_binary_complex(context, builder, sig, args):
        def round_ndigits(z, ndigits):
            return complex(numpy.round(z.real, ndigits),
                           numpy.round(z.imag, ndigits))

        res = context.compile_internal(builder, round_ndigits, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Integer, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_round`` `numba/targets/arraymath.py` lines 619-631

.. code-block:: python

    @lower_builtin(numpy.round, types.Array, types.Integer,
               types.Array)
    def array_round(context, builder, sig, args):
        def array_round_impl(arr, decimals, out):
            if arr.shape != out.shape:
                raise ValueError("invalid output shape")
            for index, val in numpy.ndenumerate(arr):
                out[index] = numpy.round(val, decimals)
            return out

        res = context.compile_internal(builder, array_round_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'>>'``
-------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_shr_impl`` `numba/targets/numbers.py` lines 296-306

.. code-block:: python

    def int_shr_impl(context, builder, sig, args):
        [valty, amtty] = sig.args
        [val, amt] = args
        val = context.cast(builder, val, valty, sig.return_type)
        amt = context.cast(builder, amt, amtty, sig.return_type)
        if sig.return_type.signed:
            res = builder.ashr(val, amt)
        else:
            res = builder.lshr(val, amt)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'exp2'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.floor``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``numpy.core.fromnumeric.mean``
------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_mean`` `numba/targets/arraymath.py` lines 102-118

.. code-block:: python

    @lower_builtin(numpy.mean, types.Array)
    @lower_builtin("array.mean", types.Array)
    def array_mean(context, builder, sig, args):
        zero = sig.return_type(0)

        def array_mean_impl(arr):
            # Can't use the naive `arr.sum() / arr.size`, as it would return
            # a wrong result on integer sum overflow.
            c = zero
            for v in numpy.nditer(arr):
                c += v.item()
            return c / arr.size

        res = context.compile_internal(builder, array_mean_impl, sig, args,
                                       locals=dict(c=sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'random.getrandbits'``
-----------------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``getrandbits_impl`` `numba/targets/randomimpl.py` lines 276-287

.. code-block:: python

    @lower("random.getrandbits", types.Integer)
    def getrandbits_impl(context, builder, sig, args):
        nbits, = args
        too_large = builder.icmp_unsigned(">=", nbits, const_int(65))
        too_small = builder.icmp_unsigned("==", nbits, const_int(0))
        with cgutils.if_unlikely(builder, builder.or_(too_large, too_small)):
            msg = "getrandbits() limited to 64 bits"
            context.call_conv.return_user_exc(builder, OverflowError, (msg,))
        state_ptr = get_state_ptr(context, builder, "py")
        res = get_next_int(context, builder, state_ptr, nbits)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'expm1'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.std``
-----------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_std`` `numba/targets/arraymath.py` lines 136-143

.. code-block:: python

    @lower_builtin(numpy.std, types.Array)
    @lower_builtin("array.std", types.Array)
    def array_std(context, builder, sig, args):
        def array_std_impl(arry):
            return arry.var() ** 0.5
        res = context.compile_internal(builder, array_std_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``cmath.acos``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``acos_impl`` `numba/targets/cmathimpl.py` lines 371-396

.. code-block:: python

    @lower(cmath.acos, types.Complex)
    def acos_impl(context, builder, sig, args):
        LN_4 = math.log(4)
        THRES = mathimpl.FLT_MAX / 4

        def acos_impl(z):
            """cmath.acos(z)"""
            # CPython's algorithm (see c_acos() in cmathmodule.c)
            if abs(z.real) > THRES or abs(z.imag) > THRES:
                # Avoid unnecessary overflow for large arguments
                # (also handles infinities gracefully)
                real = math.atan2(abs(z.imag), z.real)
                imag = math.copysign(
                    math.log(math.hypot(z.real * 0.5, z.imag * 0.5)) + LN_4,
                    -z.imag)
                return complex(real, imag)
            else:
                s1 = cmath.sqrt(complex(1. - z.real, -z.imag))
                s2 = cmath.sqrt(complex(1. + z.real, z.imag))
                real = 2. * math.atan2(s1.real, s2.real)
                imag = math.asinh(s2.real * s1.imag - s2.imag * s1.real)
                return complex(real, imag)

        res = context.compile_internal(builder, acos_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``builtins.set``
---------------------------

signature `()`
~~~~~~~~~~~~~~

by ``set_empty_constructor`` `numba/targets/setobj.py` lines 1103-1108

.. code-block:: python

    @lower_builtin(set)
    def set_empty_constructor(context, builder, sig, args):
        set_type = sig.return_type
        inst = SetInstance.allocate(context, builder, set_type)
        return impl_ret_new_ref(context, builder, set_type, inst.value)


signature `(IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``set_constructor`` `numba/targets/setobj.py` lines 1109-1123

.. code-block:: python

    @lower_builtin(set, types.IterableType)
    def set_constructor(context, builder, sig, args):
        set_type = sig.return_type
        items_type, = sig.args
        items, = args

        # If the argument has a len(), preallocate the set so as to
        # avoid resizes.
        n = call_len(context, builder, items_type, items)
        inst = SetInstance.allocate(context, builder, set_type, n)
        with for_iter(context, builder, items_type, items) as loop:
            inst.add(loop.value)

        return impl_ret_new_ref(context, builder, set_type, inst.value)


Lower Impl ``'@'``
------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``dot_2`` `numba/targets/linalg.py` lines 309-330

.. code-block:: python

    @lower_builtin(numpy.dot, types.Array, types.Array)
    @lower_builtin('@', types.Array, types.Array)
    def dot_2(context, builder, sig, args):
        """
        np.dot(a, b)
        a @ b
        """
        ensure_blas()

        with make_contiguous(context, builder, sig, args) as (sig, args):
            ndims = [x.ndim for x in sig.args[:2]]
            if ndims == [2, 2]:
                return dot_2_mm(context, builder, sig, args)
            elif ndims == [2, 1]:
                return dot_2_mv(context, builder, sig, args)
            elif ndims == [1, 2]:
                return dot_2_vm(context, builder, sig, args)
            elif ndims == [1, 1]:
                return dot_2_vv(context, builder, sig, args)
            else:
                assert 0


Lower Impl ``numpy.core.fromnumeric.var``
-----------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_var`` `numba/targets/arraymath.py` lines 119-134

.. code-block:: python

    @lower_builtin(numpy.var, types.Array)
    @lower_builtin("array.var", types.Array)
    def array_var(context, builder, sig, args):
        def array_var_impl(arr):
            # Compute the mean
            m = arr.mean()

            # Compute the sum of square diffs
            ssd = 0
            for v in numpy.nditer(arr):
                ssd += (v.item() - m) ** 2
            return ssd / arr.size

        res = context.compile_internal(builder, array_var_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'fabs'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'<<='``
--------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``'static_setitem'``
-------------------------------

signature `(Record, Const, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``record_setitem`` `numba/targets/arrayobj.py` lines 1700-1711

.. code-block:: python

    @lower_builtin('static_setitem', types.Record, types.Const, types.Any)
    def record_setitem(context, builder, sig, args):
        """
        Record.__setitem__ redirects to setattr()
        """
        recty, _, valty = sig.args
        rec, idx, val = args
        getattr_sig = signature(sig.return_type, recty, valty)
        impl = context.get_setattr(idx, getattr_sig)
        assert impl is not None
        return impl(builder, (rec, val))


Lower Impl ``'<='``
-------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_le`` `numba/targets/listobj.py` lines 670-684

.. code-block:: python

    @lower_builtin('<=', types.List, types.List)
    def list_le(context, builder, sig, args):

        def list_le_impl(a, b):
            m = len(a)
            n = len(b)
            for i in range(min(m, n)):
                if a[i] < b[i]:
                    return True
                elif a[i] > b[i]:
                    return False
            return m <= n

        return context.compile_internal(builder, list_le_impl, sig, args)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_issubset`` `numba/targets/setobj.py` lines 1337-1344

.. code-block:: python

    @lower_builtin("<=", types.Set, types.Set)
    @lower_builtin("set.issubset", types.Set, types.Set)
    def set_issubset(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        return inst.issubset(other)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ule_impl`` `numba/targets/numbers.py` lines 248-251

.. code-block:: python

    def int_ule_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint8, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ule_impl`` `numba/targets/numbers.py` lines 248-251

.. code-block:: python

    def int_ule_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint32, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ule_impl`` `numba/targets/numbers.py` lines 248-251

.. code-block:: python

    def int_ule_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint16, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ule_impl`` `numba/targets/numbers.py` lines 248-251

.. code-block:: python

    def int_ule_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ule_impl`` `numba/targets/numbers.py` lines 248-251

.. code-block:: python

    def int_ule_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_ULE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int8, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sle_impl`` `numba/targets/numbers.py` lines 228-231

.. code-block:: python

    def int_sle_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sle_impl`` `numba/targets/numbers.py` lines 228-231

.. code-block:: python

    def int_sle_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sle_impl`` `numba/targets/numbers.py` lines 228-231

.. code-block:: python

    def int_sle_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int16, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sle_impl`` `numba/targets/numbers.py` lines 228-231

.. code-block:: python

    def int_sle_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SLE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_le_impl`` `numba/targets/numbers.py` lines 667-670

.. code-block:: python

    def real_le_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_OLE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_le`` `numba/targets/tupleobj.py` lines 72-76

.. code-block:: python

    @lower_builtin('<=', types.BaseTuple, types.BaseTuple)
    def tuple_le(context, builder, sig, args):
        res = tuple_cmp_ordered(context, builder, '<=', sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_ordering_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 291-306

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaT with something else
                # (i.e. NaT is <= everything else, since it's the smallest
                #  int64 value)
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.log10``
-------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.log``
-----------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'floor'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'getiter'``
------------------------

signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``getiter_array`` `numba/targets/arrayobj.py` lines 243-265

.. code-block:: python

    @lower_builtin('getiter', types.Buffer)
    def getiter_array(context, builder, sig, args):
        [arrayty] = sig.args
        [array] = args

        iterobj = context.make_helper(builder, sig.return_type)

        zero = context.get_constant(types.intp, 0)
        indexptr = cgutils.alloca_once_value(builder, zero)

        iterobj.index = indexptr
        iterobj.array = array

        # Incref array
        if context.enable_nrt:
            context.nrt_incref(builder, arrayty, array)

        res = iterobj._getvalue()

        # Note: a decref on the iterator will dereference all internal MemInfo*
        out = impl_ret_new_ref(context, builder, sig.return_type, res)
        return out


signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``getiter_list`` `numba/targets/listobj.py` lines 385-389

.. code-block:: python

    @lower_builtin('getiter', types.List)
    def getiter_list(context, builder, sig, args):
        inst = ListIterInstance.from_list(context, builder, sig.return_type, args[0])
        return impl_ret_borrowed(context, builder, sig.return_type, inst.value)


signature `(Set)`
~~~~~~~~~~~~~~~~~

by ``getiter_set`` `numba/targets/setobj.py` lines 1138-1142

.. code-block:: python

    @lower_builtin('getiter', types.Set)
    def getiter_set(context, builder, sig, args):
        inst = SetIterInstance.from_set(context, builder, sig.return_type, args[0])
        return impl_ret_borrowed(context, builder, sig.return_type, inst.value)


signature `(IteratorType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iterator_getiter`` `numba/targets/iterators.py` lines 12-16

.. code-block:: python

    @lower_builtin('getiter', types.IteratorType)
    def iterator_getiter(context, builder, sig, args):
        [it] = args
        return impl_ret_borrowed(context, builder, sig.return_type, it)


signature `(range_state_int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.getiter_range32_impl`` `numba/targets/rangeobj.py` lines 68-77

.. code-block:: python

    @lower_builtin('getiter', range_state_type)
    def getiter_range32_impl(context, builder, sig, args):
        """
        range.__iter__
        """
        (value,) = args
        state = RangeState(context, builder, value)
        res = RangeIter.from_range_state(context, builder, state)._getvalue()
        return impl_ret_untracked(context, builder, range_iter_type, res)


signature `(range_state_int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.getiter_range32_impl`` `numba/targets/rangeobj.py` lines 68-77

.. code-block:: python

    @lower_builtin('getiter', range_state_type)
    def getiter_range32_impl(context, builder, sig, args):
        """
        range.__iter__
        """
        (value,) = args
        state = RangeState(context, builder, value)
        res = RangeIter.from_range_state(context, builder, state)._getvalue()
        return impl_ret_untracked(context, builder, range_iter_type, res)


signature `(range_state_uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_range_impl.<locals>.getiter_range32_impl`` `numba/targets/rangeobj.py` lines 68-77

.. code-block:: python

    @lower_builtin('getiter', range_state_type)
    def getiter_range32_impl(context, builder, sig, args):
        """
        range.__iter__
        """
        (value,) = args
        state = RangeState(context, builder, value)
        res = RangeIter.from_range_state(context, builder, state)._getvalue()
        return impl_ret_untracked(context, builder, range_iter_type, res)


signature `(NamedUniTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``getiter_unituple`` `numba/targets/tupleobj.py` lines 146-163

.. code-block:: python

    @lower_builtin('getiter', types.UniTuple)
    @lower_builtin('getiter', types.NamedUniTuple)
    def getiter_unituple(context, builder, sig, args):
        [tupty] = sig.args
        [tup] = args

        iterval = context.make_helper(builder, types.UniTupleIter(tupty))

        index0 = context.get_constant(types.intp, 0)
        indexptr = cgutils.alloca_once(builder, index0.type)
        builder.store(index0, indexptr)

        iterval.index = indexptr
        iterval.tuple = tup

        res = iterval._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(UniTuple)`
~~~~~~~~~~~~~~~~~~~~~~

by ``getiter_unituple`` `numba/targets/tupleobj.py` lines 146-163

.. code-block:: python

    @lower_builtin('getiter', types.UniTuple)
    @lower_builtin('getiter', types.NamedUniTuple)
    def getiter_unituple(context, builder, sig, args):
        [tupty] = sig.args
        [tup] = args

        iterval = context.make_helper(builder, types.UniTupleIter(tupty))

        index0 = context.get_constant(types.intp, 0)
        indexptr = cgutils.alloca_once(builder, index0.type)
        builder.store(index0, indexptr)

        iterval.index = indexptr
        iterval.tuple = tup

        res = iterval._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'floor_divide'>``
-------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'square'>``
-------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'//'``
-------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_floordiv_impl`` `numba/targets/numbers.py` lines 108-135

.. code-block:: python

    @lower_builtin('/?', types.Integer, types.Integer)
    @lower_builtin('//', types.Integer, types.Integer)
    def int_floordiv_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = cgutils.alloca_once(builder, a.type)

        with builder.if_else(cgutils.is_scalar_zero(builder, b), likely=False
                             ) as (if_zero, if_non_zero):
            with if_zero:
                if not context.error_model.fp_zero_division(
                    builder, ("integer division by zero",)):
                    # No exception raised => return 0
                    # XXX We should also set the FPU exception status, but
                    # there's no easy way to do that from LLVM.
                    builder.store(b, res)
            with if_non_zero:
                if sig.return_type.signed:
                    quot, _ = int_divmod(context, builder, a, b)
                else:
                    quot = builder.udiv(a, b)
                builder.store(quot, res)

        return impl_ret_untracked(context, builder, sig.return_type,
                                  builder.load(res))


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_floordiv_impl`` `numba/targets/numbers.py` lines 631-648

.. code-block:: python

    def real_floordiv_impl(context, builder, sig, args):
        x, y = args
        res = cgutils.alloca_once(builder, x.type)
        with builder.if_else(cgutils.is_scalar_zero(builder, y), likely=False
                             ) as (if_zero, if_non_zero):
            with if_zero:
                if not context.error_model.fp_zero_division(
                    builder, ("division by zero",)):
                    # No exception raised => compute the +/-inf or nan result,
                    # and set the FP exception word for Numpy warnings.
                    quot = builder.fdiv(x, y)
                    builder.store(quot, res)
            with if_non_zero:
                quot, _ = real_divmod(context, builder, x, y)
                builder.store(quot, res)
        return impl_ret_untracked(context, builder, sig.return_type,
                                  builder.load(res))


signature `(NPTimedelta, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_over_number`` `numba/targets/npdatetime.py` lines 220-246

.. code-block:: python

    @lower_builtin('/', types.NPTimedelta, types.Integer)
    @lower_builtin('//', types.NPTimedelta, types.Integer)
    @lower_builtin('/?', types.NPTimedelta, types.Integer)
    @lower_builtin('/', types.NPTimedelta, types.Float)
    @lower_builtin('//', types.NPTimedelta, types.Float)
    @lower_builtin('/?', types.NPTimedelta, types.Float)
    def timedelta_over_number(context, builder, sig, args):
        td_arg, number_arg = args
        number_type = sig.args[1]
        ret = alloc_timedelta_result(builder)
        ok = builder.and_(is_not_nat(builder, td_arg),
                          builder.not_(cgutils.is_scalar_zero_or_nan(builder, number_arg)))
        with cgutils.if_likely(builder, ok):
            # Denominator is non-zero, non-NaN
            if isinstance(number_type, types.Float):
                val = builder.sitofp(td_arg, number_arg.type)
                val = builder.fdiv(val, number_arg)
                val = builder.fptosi(val, TIMEDELTA64)
            else:
                val = builder.sdiv(td_arg, number_arg)
            # The scaling is required for ufuncs np.*divide() with an explicit
            # output in a different unit.
            val = scale_timedelta(context, builder, val, sig.args[0], sig.return_type)
            builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.acos``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'np.random.lognormal'``
------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``np_lognormal_impl`` `numba/targets/randomimpl.py` lines 610-618

.. code-block:: python

    @lower("np.random.lognormal")
    @lower("np.random.lognormal", types.Float)
    @lower("np.random.lognormal", types.Float, types.Float)
    def np_lognormal_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _lognormvariate_impl(context, builder, sig, args,
                                    np.random.normal)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``np_lognormal_impl`` `numba/targets/randomimpl.py` lines 610-618

.. code-block:: python

    @lower("np.random.lognormal")
    @lower("np.random.lognormal", types.Float)
    @lower("np.random.lognormal", types.Float, types.Float)
    def np_lognormal_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _lognormvariate_impl(context, builder, sig, args,
                                    np.random.normal)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``np_lognormal_impl`` `numba/targets/randomimpl.py` lines 610-618

.. code-block:: python

    @lower("np.random.lognormal")
    @lower("np.random.lognormal", types.Float)
    @lower("np.random.lognormal", types.Float, types.Float)
    def np_lognormal_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _lognormvariate_impl(context, builder, sig, args,
                                    np.random.normal)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'random.randint'``
-------------------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``randint_impl_1`` `numba/targets/randomimpl.py` lines 356-363

.. code-block:: python

    @lower("random.randint", types.Integer, types.Integer)
    def randint_impl_1(context, builder, sig, args):
        start, stop = args
        step = ir.Constant(start.type, 1)
        stop = builder.add(stop, step)
        res = _randrange_impl(context, builder, start, stop, step, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'fmax'>``
-----------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.atan``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'set.clear'``
--------------------------

signature `(Set)`
~~~~~~~~~~~~~~~~~

by ``set_clear`` `numba/targets/setobj.py` lines 1195-1200

.. code-block:: python

    @lower_builtin("set.clear", types.Set)
    def set_clear(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        inst.clear()
        return context.get_dummy_value()


Lower Impl ``math.atanh``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.asin``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.asinh``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``builtins.list``
----------------------------

signature `(IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_constructor`` `numba/targets/listobj.py` lines 366-375

.. code-block:: python

    @lower_builtin(list, types.IterableType)
    def list_constructor(context, builder, sig, args):

        def list_impl(iterable):
            res = []
            res.extend(iterable)
            return res

        return context.compile_internal(builder, list_impl, sig, args)


Lower Impl ``math.sinh``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'set.difference_update'``
--------------------------------------

signature `(Set, IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``set_difference_update`` `numba/targets/setobj.py` lines 1207-1215

.. code-block:: python

    @lower_builtin("set.difference_update", types.Set, types.IterableType)
    def set_difference_update(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        inst.difference(other)

        return context.get_dummy_value()


Lower Impl ``cmath.acosh``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``acosh_impl`` `numba/targets/cmathimpl.py` lines 397-422

.. code-block:: python

    @lower(cmath.acosh, types.Complex)
    def acosh_impl(context, builder, sig, args):
        LN_4 = math.log(4)
        THRES = mathimpl.FLT_MAX / 4

        def acosh_impl(z):
            """cmath.acosh(z)"""
            # CPython's algorithm (see c_acosh() in cmathmodule.c)
            if abs(z.real) > THRES or abs(z.imag) > THRES:
                # Avoid unnecessary overflow for large arguments
                # (also handles infinities gracefully)
                real = math.log(math.hypot(z.real * 0.5, z.imag * 0.5)) + LN_4
                imag = math.atan2(z.imag, z.real)
                return complex(real, imag)
            else:
                s1 = cmath.sqrt(complex(z.real - 1., z.imag))
                s2 = cmath.sqrt(complex(z.real + 1., z.imag))
                real = math.asinh(s1.real * s2.real + s1.imag * s2.imag)
                imag = 2. * math.atan2(s1.imag, s2.real)
                return complex(real, imag)
            # Condensed formula (NumPy)
            #return cmath.log(z + cmath.sqrt(z + 1.) * cmath.sqrt(z - 1.))

        res = context.compile_internal(builder, acosh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'list.append'``
----------------------------

signature `(List, any)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``list_append`` `numba/targets/listobj.py` lines 719-730

.. code-block:: python

    @lower_builtin("list.append", types.List, types.Any)
    def list_append(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        item = args[1]

        n = inst.size
        new_size = builder.add(n, ir.Constant(n.type, 1))
        inst.resize(new_size)
        inst.setitem(n, item)

        return context.get_dummy_value()


Lower Impl ``math.tanh``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'fmod'>``
-----------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.sqrt``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.tan``
-----------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``'np.random.random'``
---------------------------------

signature `()`
~~~~~~~~~~~~~~

by ``random_impl`` `numba/targets/randomimpl.py` lines 199-204

.. code-block:: python

    @lower("np.random.random")
    def random_impl(context, builder, sig, args):
        state_ptr = get_state_ptr(context, builder, "np")
        res = get_next_double(context, builder, state_ptr)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``builtins.iter``
----------------------------

signature `(IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iter_impl`` `numba/targets/builtins.py` lines 271-277

.. code-block:: python

    @lower_builtin(iter, types.IterableType)
    def iter_impl(context, builder, sig, args):
        ty, = sig.args
        val, = args
        iterval = call_getiter(context, builder, ty, val)
        return iterval


Lower Impl ``cmath.asinh``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``asinh_impl`` `numba/targets/cmathimpl.py` lines 423-446

.. code-block:: python

    @lower(cmath.asinh, types.Complex)
    def asinh_impl(context, builder, sig, args):
        LN_4 = math.log(4)
        THRES = mathimpl.FLT_MAX / 4

        def asinh_impl(z):
            """cmath.asinh(z)"""
            # CPython's algorithm (see c_asinh() in cmathmodule.c)
            if abs(z.real) > THRES or abs(z.imag) > THRES:
                real = math.copysign(
                    math.log(math.hypot(z.real * 0.5, z.imag * 0.5)) + LN_4,
                    z.real)
                imag = math.atan2(z.imag, abs(z.real))
                return complex(real, imag)
            else:
                s1 = cmath.sqrt(complex(1. + z.imag, -z.real))
                s2 = cmath.sqrt(complex(1. - z.imag, z.real))
                real = math.asinh(s1.real * s2.imag - s2.real * s1.imag)
                imag = math.atan2(z.imag, s1.real * s2.real - s1.imag * s2.imag)
                return complex(real, imag)

        res = context.compile_internal(builder, asinh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'np.random.negative_binomial'``
--------------------------------------------

signature `(int64, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``negative_binomial_impl`` `numba/targets/randomimpl.py` lines 964-979

.. code-block:: python

    @lower("np.random.negative_binomial", types.int64, types.Float)
    def negative_binomial_impl(context, builder, sig, args):
        _gamma = np.random.gamma
        _poisson = np.random.poisson

        def negative_binomial_impl(n, p):
            if n <= 0:
                raise ValueError("negative_binomial(): n <= 0")
            if p < 0.0 or p > 1.0:
                raise ValueError("negative_binomial(): p outside of [0, 1]")
            Y = _gamma(n, (1.0 - p) / p)
            return _poisson(Y)

        res = context.compile_internal(builder, negative_binomial_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'array.view'``
---------------------------

signature `(Array, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_view`` `numba/targets/arrayobj.py` lines 1419-1445

.. code-block:: python

    @lower_builtin('array.view', types.Array, types.DTypeSpec)
    def array_view(context, builder, sig, args):
        aryty = sig.args[0]
        retty = sig.return_type

        ary = make_array(aryty)(context, builder, args[0])
        ret = make_array(retty)(context, builder)
        # Copy all fields, casting the "data" pointer appropriately
        fields = set(ret._datamodel._fields)
        for k in sorted(fields):
            val = getattr(ary, k)
            if k == 'data':
                ptrty = ret.data.type
                ret.data = builder.bitcast(val, ptrty)
            else:
                setattr(ret, k, val)

        ok = _change_dtype(context, builder, aryty, retty, ret)
        fail = builder.icmp_unsigned('==', ok, lc.Constant.int(ok.type, 0))

        with builder.if_then(fail):
            msg = "new type not compatible with array"
            context.call_conv.return_user_exc(builder, ValueError, (msg,))

        res = ret._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``builtins.len``
---------------------------

signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``array_len`` `numba/targets/arrayobj.py` lines 483-492

.. code-block:: python

    @lower_builtin(len, types.Buffer)
    def array_len(context, builder, sig, args):
        (aryty,) = sig.args
        (ary,) = args
        arystty = make_array(aryty)
        ary = arystty(context, builder, ary)
        shapeary = ary.shape
        res = builder.extract_value(shapeary, 0)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NumpyFlatType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``iternext_numpy_getitem`` `numba/targets/arrayobj.py` lines 2466-2475

.. code-block:: python

    @lower_builtin(len, types.NumpyFlatType)
    def iternext_numpy_getitem(context, builder, sig, args):
        flatiterty = sig.args[0]
        flatitercls = make_array_flat_cls(flatiterty)
        flatiter = flatitercls(context, builder, value=args[0])

        arrcls = context.make_array(flatiterty.array_type)
        arr = arrcls(context, builder, value=builder.load(flatiter.array))
        return arr.nitems


signature `(ConstSized)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``constsized_len`` `numba/targets/builtins.py` lines 305-311

.. code-block:: python

    @lower_builtin(len, types.ConstSized)
    def constsized_len(context, builder, sig, args):
        [ty] = sig.args
        retty = sig.return_type
        res = context.get_constant(retty, len(ty.types))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_len`` `numba/targets/listobj.py` lines 380-384

.. code-block:: python

    @lower_builtin(len, types.List)
    def list_len(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        return inst.size


signature `(Set)`
~~~~~~~~~~~~~~~~~

by ``set_len`` `numba/targets/setobj.py` lines 1128-1132

.. code-block:: python

    @lower_builtin(len, types.Set)
    def set_len(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        return inst.get_size()


Lower Impl ``builtins.min``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``min_impl`` `numba/targets/builtins.py` lines 109-132

.. code-block:: python

    @lower_builtin(min, types.VarArg(types.Any))
    def min_impl(context, builder, sig, args):
        argtys = sig.args
        for a in argtys:
            if a not in types.number_domain:
                raise AssertionError("only implemented for numeric types")

        def domax(a, b):
            at, av = a
            bt, bv = b
            ty = context.typing_context.unify_types(at, bt)
            assert ty is not None
            cav = context.cast(builder, av, at, ty)
            cbv = context.cast(builder, bv, bt, ty)
            cmpsig = typing.signature(types.boolean, ty, ty)
            le = context.get_function("<=", cmpsig)
            pred = le(builder, (cav, cbv))
            res = builder.select(pred, cav, cbv)
            return ty, res

        typvals = zip(argtys, args)
        resty, resval = reduce(domax, typvals)
        return impl_ret_borrowed(context, builder, sig.return_type, resval)


Lower Impl ``builtins.max``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``max_impl`` `numba/targets/builtins.py` lines 84-107

.. code-block:: python

    @lower_builtin(max, types.VarArg(types.Any))
    def max_impl(context, builder, sig, args):
        argtys = sig.args
        for a in argtys:
            if a not in types.number_domain:
                raise AssertionError("only implemented for numeric types")

        def domax(a, b):
            at, av = a
            bt, bv = b
            ty = context.typing_context.unify_types(at, bt)
            assert ty is not None
            cav = context.cast(builder, av, at, ty)
            cbv = context.cast(builder, bv, bt, ty)
            cmpsig = typing.signature(types.boolean, ty, ty)
            ge = context.get_function(">=", cmpsig)
            pred = ge(builder, (cav, cbv))
            res = builder.select(pred, cav, cbv)
            return ty, res

        typvals = zip(argtys, args)
        resty, resval = reduce(domax, typvals)
        return impl_ret_borrowed(context, builder, sig.return_type, resval)


Lower Impl ``math.log1p``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'greater'>``
--------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.exp``
-----------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.expm1``
-------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``math.cosh``
------------------------

signature `(float32)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64)`
~~~~~~~~~~~~~~~~~~~~~

by ``_float_input_unary_math_extern_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 134-144

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        mod = builder.module
        lty = context.get_value_type(input_type)
        fnty = Type.function(lty, [lty])
        fn = cgutils.insert_pure_function(builder.module, fnty, name=extern_func)
        res = builder.call(fn, (val,))
        if restype is not None:
            res = context.cast(builder, res, input_type, restype)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``numpy.linalg.linalg.inv``
--------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``inv`` `numba/targets/linalg.py` lines 680-692

.. code-block:: python

    @lower_builtin(numpy.linalg.inv, types.Array)
    def inv(context, builder, sig, args):
        """
        np.linalg.inv(a)
        """
        ensure_lapack()

        ndims = sig.args[0].ndim
        if ndims == 2:
            return mat_inv(context, builder, sig, args)
        else:
            assert 0


Lower Impl ``'list.remove'``
----------------------------

signature `(List, any)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``list_remove`` `numba/targets/listobj.py` lines 888-900

.. code-block:: python

    @lower_builtin("list.remove", types.List, types.Any)
    def list_remove(context, builder, sig, args):

        def list_remove_impl(lst, value):
            for i in range(len(lst)):
                if lst[i] == value:
                    lst.pop(i)
                    return
            # XXX references are leaked when raising
            raise ValueError("list.remove(x): x not in list")

        return context.compile_internal(builder, list_remove_impl, sig, args)


Lower Impl ``<ufunc 'greater_equal'>``
--------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.transpose'``
--------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_transpose`` `numba/targets/arrayobj.py` lines 1083-1086

.. code-block:: python

    @lower_builtin('array.transpose', types.Array)
    def array_transpose(context, builder, sig, args):
        return array_T(context, builder, sig.args[0], args[0])


Lower Impl ``'random.triangular'``
----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``triangular_impl_2`` `numba/targets/randomimpl.py` lines 396-415

.. code-block:: python

    @lower("random.triangular", types.Float, types.Float)
    def triangular_impl_2(context, builder, sig, args):
        fltty = sig.return_type
        low, high = args
        state_ptr = get_state_ptr(context, builder, "py")
        randval = get_next_double(context, builder, state_ptr)

        def triangular_impl_2(randval, low, high):
            u = randval
            c = 0.5
            if u > c:
                u = 1.0 - u
                low, high = high, low
            return low + (high - low) * math.sqrt(u * c)

        res = context.compile_internal(builder, triangular_impl_2,
                                        signature(*(fltty,) * 4),
                                        (randval, low, high))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``triangular_impl_3`` `numba/targets/randomimpl.py` lines 416-422

.. code-block:: python

    @lower("random.triangular", types.Float,
               types.Float, types.Float)
    def triangular_impl_3(context, builder, sig, args):
        low, high, mode = args
        res = _triangular_impl_3(context, builder, sig, low, high, mode, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'set.update'``
---------------------------

signature `(Set, IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``set_update`` `numba/targets/setobj.py` lines 1234-1255

.. code-block:: python

    @lower_builtin("set.update", types.Set, types.IterableType)
    def set_update(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        items_type = sig.args[1]
        items = args[1]

        # If the argument has a len(), assume there are few collisions and
        # presize to len(set) + len(items)
        n = call_len(context, builder, items_type, items)
        if n is not None:
            new_size = builder.add(inst.payload.used, n)
            inst.upsize(new_size)

        with for_iter(context, builder, items_type, items) as loop:
            inst.add(loop.value)

        if n is not None:
            # If we pre-grew the set, downsize in case there were many collisions
            inst.downsize(inst.payload.used)

        return context.get_dummy_value()


Lower Impl ``'set.isdisjoint'``
-------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_isdisjoint`` `numba/targets/setobj.py` lines 1330-1336

.. code-block:: python

    @lower_builtin("set.isdisjoint", types.Set, types.Set)
    def set_isdisjoint(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        return inst.isdisjoint(other)


Lower Impl ``'np.random.pareto'``
---------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``pareto_impl`` `numba/targets/randomimpl.py` lines 649-660

.. code-block:: python

    @lower("np.random.pareto", types.Float)
    def pareto_impl(context, builder, sig, args):
        _random = np.random.random

        def pareto_impl(alpha):
            # Same as paretovariate() - 1.
            u = 1.0 - _random()
            return 1.0 / u ** (1.0/alpha) - 1

        res = context.compile_internal(builder, pareto_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'invert'>``
-------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.standard_t'``
-------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``standard_t_impl`` `numba/targets/randomimpl.py` lines 1082-1093

.. code-block:: python

    @lower("np.random.standard_t", types.Float)
    def standard_t_impl(context, builder, sig, args):

        def standard_t_impl(df):
            N = np.random.standard_normal()
            G = np.random.standard_gamma(df / 2.0)
            X = math.sqrt(df / 2.0) * N / math.sqrt(G)
            return X

        res = context.compile_internal(builder, standard_t_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'=='``
-------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_eq`` `numba/targets/listobj.py` lines 638-661

.. code-block:: python

    @lower_builtin('==', types.List, types.List)
    def list_eq(context, builder, sig, args):
        aty, bty = sig.args
        a = ListInstance(context, builder, aty, args[0])
        b = ListInstance(context, builder, bty, args[1])

        a_size = a.size
        same_size = builder.icmp_signed('==', a_size, b.size)

        res = cgutils.alloca_once_value(builder, same_size)

        with builder.if_then(same_size):
            with cgutils.for_range(builder, a_size) as loop:
                v = a.getitem(loop.index)
                w = b.getitem(loop.index)
                itemres = context.generic_compare(builder, '==',
                                                  (aty.dtype, bty.dtype), (v, w))
                with builder.if_then(builder.not_(itemres)):
                    # Exit early
                    builder.store(cgutils.false_bit, res)
                    loop.do_break()

        return builder.load(res)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_isdisjoint`` `numba/targets/setobj.py` lines 1353-1359

.. code-block:: python

    @lower_builtin("==", types.Set, types.Set)
    def set_isdisjoint(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        return inst.equals(other)


signature `(EnumMember, EnumMember)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``enum_eq`` `numba/targets/enumimpl.py` lines 12-19

.. code-block:: python

    @lower_builtin('==', types.EnumMember, types.EnumMember)
    def enum_eq(context, builder, sig, args):
        tu, tv = sig.args
        u, v = args
        res = context.generic_compare(builder, "==",
                                      (tu.dtype, tv.dtype), (u, v))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_eq_impl`` `numba/targets/numbers.py` lines 263-266

.. code-block:: python

    def int_eq_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_EQ, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_eq_impl`` `numba/targets/numbers.py` lines 263-266

.. code-block:: python

    def int_eq_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_EQ, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_eq_impl`` `numba/targets/numbers.py` lines 682-685

.. code-block:: python

    def real_eq_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_OEQ, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_eq_impl`` `numba/targets/numbers.py` lines 950-960

.. code-block:: python

    def complex_eq_impl(context, builder, sig, args):
        [cx, cy] = args
        typ = sig.args[0]
        x = context.make_complex(builder, typ, value=cx)
        y = context.make_complex(builder, typ, value=cy)

        reals_are_eq = builder.fcmp(lc.FCMP_OEQ, x.real, y.real)
        imags_are_eq = builder.fcmp(lc.FCMP_OEQ, x.imag, y.imag)
        res = builder.and_(reals_are_eq, imags_are_eq)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_eq`` `numba/targets/tupleobj.py` lines 47-61

.. code-block:: python

    @lower_builtin('==', types.BaseTuple, types.BaseTuple)
    def tuple_eq(context, builder, sig, args):
        tu, tv = sig.args
        u, v = args
        if len(tu.types) != len(tv.types):
            res = context.get_constant(types.boolean, False)
            return impl_ret_untracked(context, builder, sig.return_type, res)
        res = context.get_constant(types.boolean, True)
        for i, (ta, tb) in enumerate(zip(tu.types, tv.types)):
            a = builder.extract_value(u, i)
            b = builder.extract_value(v, i)
            pred = context.generic_compare(builder, "==", (ta, tb), (a, b))
            res = builder.and_(res, pred)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 268-286

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                try:
                    norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                except RuntimeError:
                    # Cannot normalize units => the values are unequal (except if NaT)
                    builder.store(default_value, ret)
                else:
                    builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaTs
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'__array_wrap__'``
-------------------------------

signature `(SmartArrayType, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_wrap_array`` `numba/targets/smartarray.py` lines 26-31

.. code-block:: python

    @lower_builtin('__array_wrap__', types.SmartArrayType, types.Array)
    def array_wrap_array(context, builder, sig, args):
        dest = context.make_helper(builder, sig.return_type)
        dest.data = args[1]
        return impl_ret_borrowed(context, builder, sig.return_type, dest._getvalue())


Lower Impl ``builtins.hash``
----------------------------

signature `(Boolean)`
~~~~~~~~~~~~~~~~~~~~~

by ``hash_int`` `numba/targets/numbers.py` lines 1060-1074

.. code-block:: python

    @lower_builtin(hash, types.Integer)
    @lower_builtin(hash, types.Boolean)
    def hash_int(context, builder, sig, args):
        ty, = sig.args
        retty = sig.return_type
        val, = args

        if isinstance(ty, types.Integer) and ty.bitwidth > retty.bitwidth:
            # Value is wider than hash => fold MSB into LSB
            nbits = ty.bitwidth - retty.bitwidth
            val = builder.add(val,
                              builder.lshr(val, ir.Constant(val.type, nbits)))

        return context.cast(builder, val, ty, retty)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``hash_int`` `numba/targets/numbers.py` lines 1060-1074

.. code-block:: python

    @lower_builtin(hash, types.Integer)
    @lower_builtin(hash, types.Boolean)
    def hash_int(context, builder, sig, args):
        ty, = sig.args
        retty = sig.return_type
        val, = args

        if isinstance(ty, types.Integer) and ty.bitwidth > retty.bitwidth:
            # Value is wider than hash => fold MSB into LSB
            nbits = ty.bitwidth - retty.bitwidth
            val = builder.add(val,
                              builder.lshr(val, ir.Constant(val.type, nbits)))

        return context.cast(builder, val, ty, retty)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``hash_float`` `numba/targets/numbers.py` lines 1075-1109

.. code-block:: python

    @lower_builtin(hash, types.Float)
    def hash_float(context, builder, sig, args):
        ty, = sig.args
        retty = sig.return_type
        val, = args

        # NOTE: CPython's algorithm is more involved as it seeks to maintain
        # the invariant that hash(float(x)) == hash(x) for every integer x
        # exactly representable as a float.
        # Numba doesn't care as it doesn't support heterogenous associative
        # containers.

        intty = types.Integer("int%d" % ty.bitwidth)
        ll_intty = ir.IntType(ty.bitwidth)

        # XXX Disabled as llvm.canonicalize doesn't work:
        # http://lists.llvm.org/pipermail/llvm-dev/2016-February/095746.html
        #func_name = "llvm.canonicalize.f%d" % (ty.bitwidth,)
        #fnty = ir.FunctionType(val.type, (val.type,))
        #fn = builder.module.get_or_insert_function(fnty, func_name)
        #val = builder.call(fn, (val,))

        # Take the float's binary representation as an int
        val_p = cgutils.alloca_once_value(builder, val)
        # y = *(int *)(&val)
        y = builder.load(builder.bitcast(val_p, ll_intty.as_pointer()))

        if intty.bitwidth > retty.bitwidth:
            # Value is wider than hash => fold MSB into LSB
            nbits = intty.bitwidth - retty.bitwidth
            y = builder.add(y,
                            builder.lshr(y, ir.Constant(y.type, nbits)))

        return context.cast(builder, y, intty, retty)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``hash_complex`` `numba/targets/numbers.py` lines 1110-1123

.. code-block:: python

    @lower_builtin(hash, types.Complex)
    def hash_complex(context, builder, sig, args):
        ty, = sig.args
        val, = args
        fltty = ty.underlying_float

        z = context.make_complex(builder, ty, val)
        float_hash_sig = typing.signature(sig.return_type, fltty)
        h_real = hash_float(context, builder, float_hash_sig, (z.real,))
        h_imag = hash_float(context, builder, float_hash_sig, (z.imag,))
        mult = ir.Constant(h_imag.type, 1000003)

        return builder.add(h_real, builder.mul(h_imag, mult))


signature `(BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~

by ``hash_tuple`` `numba/targets/tupleobj.py` lines 87-110

.. code-block:: python

    @lower_builtin(hash, types.BaseTuple)
    def hash_tuple(context, builder, sig, args):
        tupty, = sig.args
        tup, = args
        lty = context.get_value_type(sig.return_type)

        h = ir.Constant(lty, 0x345678)
        mult = ir.Constant(lty, 1000003)
        n = ir.Constant(lty, len(tupty))

        for i, ty in enumerate(tupty.types):
            # h = h * mult
            h = builder.mul(h, mult)
            val = builder.extract_value(tup, i)
            hash_impl = context.get_function(hash,
                                             typing.signature(sig.return_type, ty))
            h_val = hash_impl(builder, (val,))
            # h = h ^ hash(val)
            h = builder.xor(h, h_val)
            # Perturb: mult = mult + len(tup)
            mult = builder.add(mult, n)

        return h


Lower Impl ``'np.random.laplace'``
----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``laplace_impl`` `numba/targets/randomimpl.py` lines 899-916

.. code-block:: python

    @lower("np.random.laplace")
    @lower("np.random.laplace", types.Float)
    @lower("np.random.laplace", types.Float, types.Float)
    def laplace_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def laplace_impl(loc, scale):
            U = _random()
            if U < 0.5:
                return loc + scale * _log(U + U)
            else:
                return loc - scale * _log(2.0 - U - U)

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, laplace_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``laplace_impl`` `numba/targets/randomimpl.py` lines 899-916

.. code-block:: python

    @lower("np.random.laplace")
    @lower("np.random.laplace", types.Float)
    @lower("np.random.laplace", types.Float, types.Float)
    def laplace_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def laplace_impl(loc, scale):
            U = _random()
            if U < 0.5:
                return loc + scale * _log(U + U)
            else:
                return loc - scale * _log(2.0 - U - U)

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, laplace_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``laplace_impl`` `numba/targets/randomimpl.py` lines 899-916

.. code-block:: python

    @lower("np.random.laplace")
    @lower("np.random.laplace", types.Float)
    @lower("np.random.laplace", types.Float, types.Float)
    def laplace_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def laplace_impl(loc, scale):
            U = _random()
            if U < 0.5:
                return loc + scale * _log(U + U)
            else:
                return loc - scale * _log(2.0 - U - U)

        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = context.compile_internal(builder, laplace_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'array.argmin'``
-----------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_argmin`` `numba/targets/arraymath.py` lines 203-252

.. code-block:: python

    @lower_builtin(numpy.argmin, types.Array)
    @lower_builtin("array.argmin", types.Array)
    def array_argmin(context, builder, sig, args):
        ty = sig.args[0].dtype
        # NOTE: Under Numpy < 1.10, argmin() is inconsistent with min() on NaT values:
        # https://github.com/numpy/numpy/issues/6030

        if (numpy_version >= (1, 10) and
            isinstance(ty, (types.NPDatetime, types.NPTimedelta))):
            # NaT is smaller than every other value, but it is
            # ignored as far as argmin() is concerned.
            nat = ty('NaT')

            def array_argmin_impl(arry):
                min_value = nat
                min_idx = 0
                it = arry.flat
                idx = 0
                for v in it:
                    if v != nat:
                        min_value = v
                        min_idx = idx
                        idx += 1
                        break
                    idx += 1

                for v in it:
                    if v != nat and v < min_value:
                        min_value = v
                        min_idx = idx
                    idx += 1
                return min_idx

        else:
            def array_argmin_impl(arry):
                for v in arry.flat:
                    min_value = v
                    min_idx = 0
                    break

                idx = 0
                for v in arry.flat:
                    if v < min_value:
                        min_value = v
                        min_idx = idx
                    idx += 1
                return min_idx
        res = context.compile_internal(builder, array_argmin_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``math.fabs``
------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``unary_math_intr.<locals>.float_impl`` `numba/targets/mathimpl.py` lines 121-125

.. code-block:: python

    @lower(fn, types.Float)
    def float_impl(context, builder, sig, args):
        res = call_fp_intrinsic(builder, intrcode, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``_unary_int_input_wrapper_impl.<locals>.implementer`` `numba/targets/mathimpl.py` lines 104-113

.. code-block:: python

    def implementer(context, builder, sig, args):
        [val] = args
        input_type = sig.args[0]
        if input_type.signed:
            fpval = builder.sitofp(val, Type.double())
        else:
            fpval = builder.uitofp(val, Type.double())
        sig = signature(types.float64, types.float64)
        return wrapped_impl(context, builder, sig, [fpval])


Lower Impl ``<ufunc 'isfinite'>``
---------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.tanh``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``tanh_impl`` `numba/targets/cmathimpl.py` lines 343-369

.. code-block:: python

    @lower(cmath.tanh, types.Complex)
    def tanh_impl(context, builder, sig, args):
        def tanh_impl(z):
            """cmath.tanh(z)"""
            x = z.real
            y = z.imag
            if math.isinf(x):
                real = math.copysign(1., x)
                if math.isinf(y):
                    imag = 0.
                else:
                    imag = math.copysign(0., math.sin(2. * y))
                return complex(real, imag)
            # This is CPython's algorithm (see c_tanh() in cmathmodule.c).
            # XXX how to force float constants into single precision?
            tx = math.tanh(x)
            ty = math.tan(y)
            cx = 1. / math.cosh(x)
            txty = tx * ty
            denom = 1. + txty * txty
            return complex(
                tx * (1. + ty * ty) / denom,
                ((ty / denom) * cx) * cx)

        res = context.compile_internal(builder, tanh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'np.random.exponential'``
--------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``exponential_impl`` `numba/targets/randomimpl.py` lines 585-596

.. code-block:: python

    @lower("np.random.exponential", types.Float)
    def exponential_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def exponential_impl(scale):
            return -_log(1.0 - _random()) * scale

        res = context.compile_internal(builder, exponential_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``exponential_impl`` `numba/targets/randomimpl.py` lines 597-609

.. code-block:: python

    @lower("np.random.standard_exponential")
    @lower("np.random.exponential")
    def exponential_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def exponential_impl():
            return -_log(1.0 - _random())

        res = context.compile_internal(builder, exponential_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'isinf'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'list.sort'``
--------------------------

signature `(List, Boolean)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_sort`` `numba/targets/listobj.py` lines 935-951

.. code-block:: python

    @lower_builtin("list.sort", types.List)
    @lower_builtin("list.sort", types.List, types.Boolean)
    def list_sort(context, builder, sig, args):
        load_sorts()

        if len(args) == 1:
            sig = typing.signature(sig.return_type, *sig.args + (types.boolean,))
            args = tuple(args) + (cgutils.false_bit,)

        def list_sort_impl(lst, reverse):
            if reverse:
                return run_reversed_sort(lst)
            else:
                return run_default_sort(lst)

        return context.compile_internal(builder, list_sort_impl, sig, args)


signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_sort`` `numba/targets/listobj.py` lines 935-951

.. code-block:: python

    @lower_builtin("list.sort", types.List)
    @lower_builtin("list.sort", types.List, types.Boolean)
    def list_sort(context, builder, sig, args):
        load_sorts()

        if len(args) == 1:
            sig = typing.signature(sig.return_type, *sig.args + (types.boolean,))
            args = tuple(args) + (cgutils.false_bit,)

        def list_sort_impl(lst, reverse):
            if reverse:
                return run_reversed_sort(lst)
            else:
                return run_default_sort(lst)

        return context.compile_internal(builder, list_sort_impl, sig, args)


Lower Impl ``'set.issubset'``
-----------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_issubset`` `numba/targets/setobj.py` lines 1337-1344

.. code-block:: python

    @lower_builtin("<=", types.Set, types.Set)
    @lower_builtin("set.issubset", types.Set, types.Set)
    def set_issubset(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        return inst.issubset(other)


Lower Impl ``cmath.tan``
------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``tan_impl`` `numba/targets/cmathimpl.py` lines 333-342

.. code-block:: python

    @lower(cmath.tan, types.Complex)
    def tan_impl(context, builder, sig, args):
        def tan_impl(z):
            """cmath.tan(z) = -j * cmath.tanh(z j)"""
            r = cmath.tanh(complex(-z.imag, z.real))
            return complex(r.imag, -r.real)

        res = context.compile_internal(builder, tan_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'random.gammavariate'``
------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``gammavariate_impl`` `numba/targets/randomimpl.py` lines 451-456

.. code-block:: python

    @lower("random.gammavariate",
               types.Float, types.Float)
    def gammavariate_impl(context, builder, sig, args):
        res = _gammavariate_impl(context, builder, sig, args, random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'isnan'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.standard_normal'``
------------------------------------------

signature `()`
~~~~~~~~~~~~~~

by ``np_gauss_impl`` `numba/targets/randomimpl.py` lines 213-221

.. code-block:: python

    @lower("np.random.standard_normal")
    @lower("np.random.normal")
    @lower("np.random.normal", types.Float)
    @lower("np.random.normal", types.Float, types.Float)
    def np_gauss_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (0.0, 1.0))
        res = _gauss_impl(context, builder, sig, args, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``cmath.sqrt``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``sqrt_impl`` `numba/targets/cmathimpl.py` lines 208-257

.. code-block:: python

    @lower(cmath.sqrt, types.Complex)
    def sqrt_impl(context, builder, sig, args):
        # We risk spurious overflow for components >= FLT_MAX / (1 + sqrt(2)).
        THRES = mathimpl.FLT_MAX / (1 + math.sqrt(2))

        def sqrt_impl(z):
            """cmath.sqrt(z)"""
            # This is NumPy's algorithm, see npy_csqrt() in npy_math_complex.c.src
            a = z.real
            b = z.imag
            if a == 0.0 and b == 0.0:
                return complex(abs(b), b)
            if math.isinf(b):
                return complex(abs(b), b)
            if math.isnan(a):
                return complex(a, a)
            if math.isinf(a):
                if a < 0.0:
                    return complex(abs(b - b), math.copysign(a, b))
                else:
                    return complex(a, math.copysign(b - b, b))

            # The remaining special case (b is NaN) is handled just fine by
            # the normal code path below.

            # Scale to avoid overflow
            if abs(a) >= THRES or abs(b) >= THRES:
                a *= 0.25
                b *= 0.25
                scale = True
            else:
                scale = False
            # Algorithm 312, CACM vol 10, Oct 1967
            if a >= 0:
                t = math.sqrt((a + math.hypot(a, b)) * 0.5)
                real = t
                imag = b / (2 * t)
            else:
                t = math.sqrt((-a + math.hypot(a, b)) * 0.5)
                real = abs(b) / (2 * t)
                imag = math.copysign(t, b)
            # Rescale
            if scale:
                return complex(real * 2, imag)
            else:
                return complex(real, imag)

        res = context.compile_internal(builder, sqrt_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``<ufunc 'cosh'>``
-----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'ldexp'>``
------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'|='``
-------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_inplace`` `numba/targets/setobj.py` lines 1262-1267

.. code-block:: python

    @lower_builtin(op, types.Set, types.Set)
    def set_inplace(context, builder, sig, args, op_impl=op_impl):
        assert sig.return_type == sig.args[0]
        op_impl(context, builder, sig, args)
        return impl_ret_borrowed(context, builder, sig.args[0], args[0])


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``<ufunc 'left_shift'>``
-----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'list.clear'``
---------------------------

signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_clear`` `numba/targets/listobj.py` lines 731-737

.. code-block:: python

    @lower_builtin("list.clear", types.List)
    def list_clear(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        inst.resize(context.get_constant(types.intp, 0))

        return context.get_dummy_value()


Lower Impl ``numpy.core.multiarray.frombuffer``
-----------------------------------------------

signature `(Buffer, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``np_frombuffer`` `numba/targets/arrayobj.py` lines 3151-3188

.. code-block:: python

    @lower_builtin(numpy.frombuffer, types.Buffer)
    @lower_builtin(numpy.frombuffer, types.Buffer, types.DTypeSpec)
    def np_frombuffer(context, builder, sig, args):
        bufty = sig.args[0]
        aryty = sig.return_type

        buf = make_array(bufty)(context, builder, value=args[0])
        out_ary_ty = make_array(aryty)
        out_ary = out_ary_ty(context, builder)
        out_datamodel = out_ary._datamodel

        itemsize = get_itemsize(context, aryty)
        ll_itemsize = lc.Constant.int(buf.itemsize.type, itemsize)
        nbytes = builder.mul(buf.nitems, buf.itemsize)

        # Check that the buffer size is compatible
        rem = builder.srem(nbytes, ll_itemsize)
        is_incompatible = cgutils.is_not_null(builder, rem)
        with builder.if_then(is_incompatible, likely=False):
            msg = "buffer size must be a multiple of element size"
            context.call_conv.return_user_exc(builder, ValueError, (msg,))

        shape = cgutils.pack_array(builder, [builder.sdiv(nbytes, ll_itemsize)])
        strides = cgutils.pack_array(builder, [ll_itemsize])
        data = builder.bitcast(buf.data,
                               context.get_value_type(out_datamodel.get_type('data')))

        populate_array(out_ary,
                       data=data,
                       shape=shape,
                       strides=strides,
                       itemsize=ll_itemsize,
                       meminfo=buf.meminfo,
                       parent=buf.parent,)

        res = out_ary._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``np_frombuffer`` `numba/targets/arrayobj.py` lines 3151-3188

.. code-block:: python

    @lower_builtin(numpy.frombuffer, types.Buffer)
    @lower_builtin(numpy.frombuffer, types.Buffer, types.DTypeSpec)
    def np_frombuffer(context, builder, sig, args):
        bufty = sig.args[0]
        aryty = sig.return_type

        buf = make_array(bufty)(context, builder, value=args[0])
        out_ary_ty = make_array(aryty)
        out_ary = out_ary_ty(context, builder)
        out_datamodel = out_ary._datamodel

        itemsize = get_itemsize(context, aryty)
        ll_itemsize = lc.Constant.int(buf.itemsize.type, itemsize)
        nbytes = builder.mul(buf.nitems, buf.itemsize)

        # Check that the buffer size is compatible
        rem = builder.srem(nbytes, ll_itemsize)
        is_incompatible = cgutils.is_not_null(builder, rem)
        with builder.if_then(is_incompatible, likely=False):
            msg = "buffer size must be a multiple of element size"
            context.call_conv.return_user_exc(builder, ValueError, (msg,))

        shape = cgutils.pack_array(builder, [builder.sdiv(nbytes, ll_itemsize)])
        strides = cgutils.pack_array(builder, [ll_itemsize])
        data = builder.bitcast(buf.data,
                               context.get_value_type(out_datamodel.get_type('data')))

        populate_array(out_ary,
                       data=data,
                       shape=shape,
                       strides=strides,
                       itemsize=ll_itemsize,
                       meminfo=buf.meminfo,
                       parent=buf.parent,)

        res = out_ary._getvalue()
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``'array.item'``
---------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_item`` `numba/targets/arrayobj.py` lines 494-507

.. code-block:: python

    @lower_builtin("array.item", types.Array)
    def array_item(context, builder, sig, args):
        aryty, = sig.args
        ary, = args
        ary = make_array(aryty)(context, builder, ary)

        nitems = ary.nitems
        with builder.if_then(builder.icmp_signed('!=', nitems, nitems.type(1)),
                             likely=False):
            msg = "item(): can only convert an array of size 1 to a Python scalar"
            context.call_conv.return_user_exc(builder, ValueError, (msg,))

        return load_item(context, builder, aryty, ary.data)


Lower Impl ``<ufunc 'less'>``
-----------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'number.item'``
----------------------------

signature `(Number)`
~~~~~~~~~~~~~~~~~~~~

by ``number_item_impl`` `numba/targets/numbers.py` lines 1004-1011

.. code-block:: python

    @lower_builtin("number.item", types.Boolean)
    @lower_builtin("number.item", types.Number)
    def number_item_impl(context, builder, sig, args):
        """
        The no-op .item() method on booleans and numbers.
        """
        return args[0]


signature `(Boolean)`
~~~~~~~~~~~~~~~~~~~~~

by ``number_item_impl`` `numba/targets/numbers.py` lines 1004-1011

.. code-block:: python

    @lower_builtin("number.item", types.Boolean)
    @lower_builtin("number.item", types.Number)
    def number_item_impl(context, builder, sig, args):
        """
        The no-op .item() method on booleans and numbers.
        """
        return args[0]


Lower Impl ``'np.random.binomial'``
-----------------------------------

signature `(Integer, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``binomial_impl`` `numba/targets/randomimpl.py` lines 754-811

.. code-block:: python

    @lower("np.random.binomial", types.Integer, types.Float)
    def binomial_impl(context, builder, sig, args):
        intty = sig.return_type
        _random = np.random.random

        def binomial_impl(n, p):
            """
            Binomial distribution.  Numpy's variant of the BINV algorithm
            is used.
            (Numpy uses BTPE for n*p >= 30, though)
            """
            if n < 0:
                raise ValueError("binomial(): n <= 0")
            if not (0.0 <= p <= 1.0):
                raise ValueError("binomial(): p outside of [0, 1]")
            if p == 0.0:
                return 0
            if p == 1.0:
                return n

            flipped = p > 0.5
            if flipped:
                p = 1.0 - p
            q = 1.0 - p

            niters = 1
            qn = q ** n
            while qn <= 1e-308:
                # Underflow => split into several iterations
                # Note this is much slower than Numpy's BTPE
                niters <<= 2
                n >>= 2
                qn = q ** n
                assert n > 0

            np = n * p
            bound = min(n, np + 10.0 * math.sqrt(np * q + 1))

            finished = False
            total = 0
            while niters > 0:
                X = 0
                U = _random()
                px = qn
                while X <= bound:
                    if U <= px:
                        total += n - X if flipped else X
                        niters -= 1
                        break
                    U -= px
                    X += 1
                    px = ((n - X + 1) * p * px) / (X * q)

            return total

        res = context.compile_internal(builder, binomial_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'less_equal'>``
-----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'ffi.from_buffer'``
--------------------------------

signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``from_buffer`` `numba/targets/cffiimpl.py` lines 13-24

.. code-block:: python

    @registry.lower('ffi.from_buffer', types.Buffer)
    def from_buffer(context, builder, sig, args):
        assert len(sig.args) == 1
        assert len(args) == 1
        [fromty] = sig.args
        [val] = args
        # Type inference should have prevented passing a buffer from an
        # array to a pointer of the wrong type
        assert fromty.dtype == sig.return_type.dtype
        ary = arrayobj.make_array(fromty)(context, builder, val)
        return ary.data


Lower Impl ``<ufunc 'log'>``
----------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.wald'``
-------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``wald_impl`` `numba/targets/randomimpl.py` lines 1095-1115

.. code-block:: python

    @lower("np.random.wald", types.Float, types.Float)
    def wald_impl(context, builder, sig, args):

        def wald_impl(mean, scale):
            if mean <= 0.0:
                raise ValueError("wald(): mean <= 0")
            if scale <= 0.0:
                raise ValueError("wald(): scale <= 0")
            mu_2l = mean / (2.0 * scale)
            Y = np.random.standard_normal()
            Y = mean * Y * Y
            X = mean + mu_2l * (Y - math.sqrt(4 * scale * Y + Y * Y))
            U = np.random.random()
            if U <= mean / (mean + X):
                return X
            else:
                return mean * mean / X

        res = context.compile_internal(builder, wald_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'log10'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'-'``
------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_difference`` `numba/targets/setobj.py` lines 1271-1280

.. code-block:: python

    @lower_builtin("-", types.Set, types.Set)
    @lower_builtin("set.difference", types.Set, types.Set)
    def set_difference(context, builder, sig, args):
        def difference_impl(a, b):
            s = a.copy()
            s.difference_update(b)
            return s

        return context.compile_internal(builder, difference_impl, sig, args)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sub_impl`` `numba/targets/numbers.py` lines 44-51

.. code-block:: python

    def int_sub_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        a = context.cast(builder, va, ta, sig.return_type)
        b = context.cast(builder, vb, tb, sig.return_type)
        res = builder.sub(a, b, flags=_int_arith_flags(sig.return_type))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_negate_impl`` `numba/targets/numbers.py` lines 335-342

.. code-block:: python

    def int_negate_impl(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        # Negate before upcasting, for unsigned numbers
        res = builder.neg(val)
        res = context.cast(builder, res, typ, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_sub_impl`` `numba/targets/numbers.py` lines 464-467

.. code-block:: python

    def real_sub_impl(context, builder, sig, args):
        res = builder.fsub(*args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``real_negate_impl`` `numba/targets/numbers.py` lines 699-703

.. code-block:: python

    def real_negate_impl(context, builder, sig, args):
        from . import mathimpl
        res = mathimpl.negate_real(builder, args[0])
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_sub_impl`` `numba/targets/numbers.py` lines 860-874

.. code-block:: python

    def complex_sub_impl(context, builder, sig, args):
        [cx, cy] = args
        ty = sig.args[0]
        x = context.make_complex(builder, ty, value=cx)
        y = context.make_complex(builder, ty, value=cy)
        z = context.make_complex(builder, ty)
        a = x.real
        b = x.imag
        c = y.real
        d = y.imag
        z.real = builder.fsub(a, c)
        z.imag = builder.fsub(b, d)
        res = z._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``complex_negate_impl`` `numba/targets/numbers.py` lines 933-943

.. code-block:: python

    def complex_negate_impl(context, builder, sig, args):
        from . import mathimpl
        [typ] = sig.args
        [val] = args
        cmplx = context.make_complex(builder, typ, value=val)
        res = context.make_complex(builder, typ)
        res.real = mathimpl.negate_real(builder, cmplx.real)
        res.imag = mathimpl.negate_real(builder, cmplx.imag)
        res = res._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_neg_impl`` `numba/targets/npdatetime.py` lines 124-128

.. code-block:: python

    @lower_builtin('-', types.NPTimedelta)
    def timedelta_neg_impl(context, builder, sig, args):
        res = builder.neg(args[0])
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_sub_impl`` `numba/targets/npdatetime.py` lines 174-185

.. code-block:: python

    @lower_builtin('-', *TIMEDELTA_BINOP_SIG)
    def timedelta_sub_impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_timedelta_result(builder)
        with cgutils.if_likely(builder, are_not_nat(builder, [va, vb])):
            va = scale_timedelta(context, builder, va, ta, sig.return_type)
            vb = scale_timedelta(context, builder, vb, tb, sig.return_type)
            builder.store(builder.sub(va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``datetime_minus_timedelta`` `numba/targets/npdatetime.py` lines 498-507

.. code-block:: python

    @lower_builtin('-', types.NPDatetime, types.NPTimedelta)
    def datetime_minus_timedelta(context, builder, sig, args):
        dt_arg, td_arg = args
        dt_type, td_type = sig.args
        res = _datetime_minus_timedelta(context, builder,
                                         dt_arg, dt_type.unit,
                                         td_arg, td_type.unit,
                                         sig.return_type.unit)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``datetime_minus_datetime`` `numba/targets/npdatetime.py` lines 510-525

.. code-block:: python

    @lower_builtin('-', types.NPDatetime, types.NPDatetime)
    def datetime_minus_datetime(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = sig.return_type.unit
        ret = alloc_timedelta_result(builder)
        with cgutils.if_likely(builder, are_not_nat(builder, [va, vb])):
            va = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
            vb = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
            ret_val = builder.sub(va, vb)
            builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``register_unary_operator_kernel.<locals>.lower_unary_operator`` `numba/targets/npyimpl.py` lines 462-465

.. code-block:: python

    def lower_unary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.standard_gamma'``
-----------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``gammavariate_impl`` `numba/targets/randomimpl.py` lines 457-464

.. code-block:: python

    @lower("np.random.standard_gamma", types.Float)
    @lower("np.random.gamma", types.Float)
    @lower("np.random.gamma", types.Float, types.Float)
    def gammavariate_impl(context, builder, sig, args):
        sig, args = _fill_defaults(context, builder, sig, args, (None, 1.0))
        res = _gammavariate_impl(context, builder, sig, args, np.random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'>>='``
--------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``<ufunc 'log1p'>``
------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.rayleigh'``
-----------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``rayleigh_impl`` `numba/targets/randomimpl.py` lines 1056-1069

.. code-block:: python

    @lower("np.random.rayleigh")
    @lower("np.random.rayleigh", types.Float)
    def rayleigh_impl(context, builder, sig, args):
        _random = np.random.random

        def rayleigh_impl(mode):
            if mode <= 0.0:
                raise ValueError("rayleigh(): mode <= 0")
            return mode * math.sqrt(-2.0 * math.log(1.0 - _random()))

        sig, args = _fill_defaults(context, builder, sig, args, (1.0,))
        res = context.compile_internal(builder, rayleigh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``rayleigh_impl`` `numba/targets/randomimpl.py` lines 1056-1069

.. code-block:: python

    @lower("np.random.rayleigh")
    @lower("np.random.rayleigh", types.Float)
    def rayleigh_impl(context, builder, sig, args):
        _random = np.random.random

        def rayleigh_impl(mode):
            if mode <= 0.0:
                raise ValueError("rayleigh(): mode <= 0")
            return mode * math.sqrt(-2.0 * math.log(1.0 - _random()))

        sig, args = _fill_defaults(context, builder, sig, args, (1.0,))
        res = context.compile_internal(builder, rayleigh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'np.random.logseries'``
------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``logseries_impl`` `numba/targets/randomimpl.py` lines 933-962

.. code-block:: python

    @lower("np.random.logseries", types.Float)
    def logseries_impl(context, builder, sig, args):
        intty = sig.return_type
        _random = np.random.random
        _log = math.log
        _exp = math.exp

        def logseries_impl(p):
            """Numpy's algorithm for logseries()."""
            if p <= 0.0 or p > 1.0:
                raise ValueError("logseries(): p outside of (0, 1]")
            r = _log(1.0 - p)

            while 1:
                V = _random()
                if V >= p:
                    return 1
                U = _random()
                q = 1.0 - _exp(r * U)
                if V <= q * q:
                    # XXX what if V == 0.0 ?
                    return intty(1.0 + _log(V) / _log(q))
                elif V >= q:
                    return 1
                else:
                    return 2

        res = context.compile_internal(builder, logseries_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'np.random.standard_exponential'``
-----------------------------------------------

signature `()`
~~~~~~~~~~~~~~

by ``exponential_impl`` `numba/targets/randomimpl.py` lines 597-609

.. code-block:: python

    @lower("np.random.standard_exponential")
    @lower("np.random.exponential")
    def exponential_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def exponential_impl():
            return -_log(1.0 - _random())

        res = context.compile_internal(builder, exponential_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``cmath.asin``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``asin_impl`` `numba/targets/cmathimpl.py` lines 447-456

.. code-block:: python

    @lower(cmath.asin, types.Complex)
    def asin_impl(context, builder, sig, args):
        def asin_impl(z):
            """cmath.asin(z) = -j * cmath.asinh(z j)"""
            r = cmath.asinh(complex(-z.imag, z.real))
            return complex(r.imag, -r.real)

        res = context.compile_internal(builder, asin_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``_operator.lt``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'%='``
-------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``'set.difference'``
-------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_difference`` `numba/targets/setobj.py` lines 1271-1280

.. code-block:: python

    @lower_builtin("-", types.Set, types.Set)
    @lower_builtin("set.difference", types.Set, types.Set)
    def set_difference(context, builder, sig, args):
        def difference_impl(a, b):
            s = a.copy()
            s.difference_update(b)
            return s

        return context.compile_internal(builder, difference_impl, sig, args)


Lower Impl ``<ufunc 'logaddexp'>``
----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.itemset'``
------------------------------

signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_itemset`` `numba/targets/arrayobj.py` lines 509-524

.. code-block:: python

    @lower_builtin("array.itemset", types.Array, types.Any)
    def array_itemset(context, builder, sig, args):
        aryty, valty = sig.args
        ary, val = args
        assert valty == aryty.dtype
        ary = make_array(aryty)(context, builder, ary)

        nitems = ary.nitems
        with builder.if_then(builder.icmp_signed('!=', nitems, nitems.type(1)),
                             likely=False):
            msg = "itemset(): can only write to an array of size 1"
            context.call_conv.return_user_exc(builder, ValueError, (msg,))

        store_item(context, builder, aryty, val, ary.data)
        return context.get_dummy_value()


Lower Impl ``'np.random.gumbel'``
---------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``gumbel_impl`` `numba/targets/randomimpl.py` lines 860-871

.. code-block:: python

    @lower("np.random.gumbel", types.Float, types.Float)
    def gumbel_impl(context, builder, sig, args):
        _random = np.random.random
        _log = math.log

        def gumbel_impl(loc, scale):
            U = 1.0 - _random()
            return loc - scale * _log(-_log(U))

        res = context.compile_internal(builder, gumbel_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``builtins.int``
---------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``int_impl`` `numba/targets/builtins.py` lines 192-199

.. code-block:: python

    @lower_builtin(int, types.Any)
    @lower_builtin(float, types.Any)
    def int_impl(context, builder, sig, args):
        [ty] = sig.args
        [val] = args
        res = context.cast(builder, val, ty, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'set.remove'``
---------------------------

signature `(Set, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_remove`` `numba/targets/setobj.py` lines 1181-1191

.. code-block:: python

    @lower_builtin("set.remove", types.Set, types.Any)
    def set_remove(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        item = args[1]
        found = inst.discard(item)
        with builder.if_then(builder.not_(found), likely=False):
            context.call_conv.return_user_exc(builder, KeyError,
                                              ("set.remove(): key not in set",))

        return context.get_dummy_value()


Lower Impl ``builtins.zip``
---------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``make_zip_object`` `numba/targets/iterators.py` lines 71-84

.. code-block:: python

    @lower_builtin(zip, types.VarArg(types.Any))
    def make_zip_object(context, builder, sig, args):
        zip_type = sig.return_type

        assert len(args) == len(zip_type.source_types)

        zipobj = context.make_helper(builder, zip_type)

        for i, (arg, srcty) in enumerate(zip(args, sig.args)):
            zipobj[i] = call_getiter(context, builder, srcty, arg)

        res = zipobj._getvalue()
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'array.sort'``
---------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_sort`` `numba/targets/arrayobj.py` lines 3369-3384

.. code-block:: python

    @lower_builtin("array.sort", types.Array)
    def array_sort(context, builder, sig, args):
        load_sorts()

        arytype = sig.args[0]
        dtype = arytype.dtype

        if isinstance(dtype, types.Float):
            def array_sort_impl(arr):
                return run_float_quicksort(arr)
        else:
            def array_sort_impl(arr):
                return run_default_quicksort(arr)

        return context.compile_internal(builder, array_sort_impl, sig, args)


Lower Impl ``'*='``
-------------------

signature `(List, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_mul_inplace`` `numba/targets/listobj.py` lines 607-625

.. code-block:: python

    @lower_builtin("*=", types.List, types.Integer)
    def list_mul_inplace(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        src_size = inst.size

        mult = args[1]
        zero = ir.Constant(mult.type, 0)
        mult = builder.select(cgutils.is_neg_int(builder, mult), zero, mult)
        nitems = builder.mul(mult, src_size)

        inst.resize(nitems)

        with cgutils.for_range_slice(builder, src_size, nitems, src_size, inc=True) as (dest_offset, _):
            with cgutils.for_range(builder, src_size) as loop:
                value = inst.getitem(loop.index)
                inst.setitem(builder.add(loop.index, dest_offset), value)

        return impl_ret_borrowed(context, builder, sig.return_type, inst.value)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``builtins.bool``
----------------------------

signature `(Sized)`
~~~~~~~~~~~~~~~~~~~

by ``sized_bool`` `numba/targets/builtins.py` lines 313-320

.. code-block:: python

    @lower_builtin(bool, types.Sized)
    def sized_bool(context, builder, sig, args):
        [ty] = sig.args
        if len(ty):
            return cgutils.true_bit
        else:
            return cgutils.false_bit


signature `(Sequence)`
~~~~~~~~~~~~~~~~~~~~~~

by ``sequence_bool`` `numba/targets/listobj.py` lines 549-555

.. code-block:: python

    @lower_builtin(bool, types.Sequence)
    def sequence_bool(context, builder, sig, args):
        def sequence_bool_impl(seq):
            return len(seq) != 0

        return context.compile_internal(builder, sequence_bool_impl, sig, args)


signature `(bool)`
~~~~~~~~~~~~~~~~~~

by ``bool_as_bool`` `numba/targets/numbers.py` lines 1024-1028

.. code-block:: python

    @lower_builtin(bool, types.boolean)
    def bool_as_bool(context, builder, sig, args):
        [val] = args
        return val


signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``int_as_bool`` `numba/targets/numbers.py` lines 1029-1033

.. code-block:: python

    @lower_builtin(bool, types.Integer)
    def int_as_bool(context, builder, sig, args):
        [val] = args
        return builder.icmp_unsigned('!=', val, ir.Constant(val.type, 0))


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``float_as_bool`` `numba/targets/numbers.py` lines 1034-1038

.. code-block:: python

    @lower_builtin(bool, types.Float)
    def float_as_bool(context, builder, sig, args):
        [val] = args
        return builder.fcmp(lc.FCMP_UNE, val, ir.Constant(val.type, 0.0))


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``complex_as_bool`` `numba/targets/numbers.py` lines 1039-1049

.. code-block:: python

    @lower_builtin(bool, types.Complex)
    def complex_as_bool(context, builder, sig, args):
        [typ] = sig.args
        [val] = args
        cmplx = context.make_complex(builder, typ, val)
        real, imag = cmplx.real, cmplx.imag
        zero = ir.Constant(real.type, 0.0)
        real_istrue = builder.fcmp(lc.FCMP_UNE, real, zero)
        imag_istrue = builder.fcmp(lc.FCMP_UNE, imag, zero)
        return builder.or_(real_istrue, imag_istrue)


Lower Impl ``<ufunc 'logical_and'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'hypot'>``
------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'array.copy'``
---------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_copy`` `numba/targets/arrayobj.py` lines 3083-3086

.. code-block:: python

    @lower_builtin("array.copy", types.Array)
    def array_copy(context, builder, sig, args):
        return _array_copy(context, builder, sig, args)


Lower Impl ``<ufunc 'logical_not'>``
------------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'random.shuffle'``
-------------------------------

signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``shuffle_impl`` `numba/targets/randomimpl.py` lines 1139-1143

.. code-block:: python

    @lower("random.shuffle", types.Buffer)
    def shuffle_impl(context, builder, sig, args):
        res = _shuffle_impl(context, builder, sig, args, random.randrange)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'random.weibullvariate'``
--------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``weibullvariate_impl`` `numba/targets/randomimpl.py` lines 661-676

.. code-block:: python

    @lower("random.weibullvariate",
               types.Float, types.Float)
    def weibullvariate_impl(context, builder, sig, args):
        _random = random.random
        _log = math.log

        def weibullvariate_impl(alpha, beta):
            """Weibull distribution.  Taken from CPython."""
            # Jain, pg. 499; bug fix courtesy Bill Arms
            u = 1.0 - _random()
            return alpha * (-_log(u)) ** (1.0/beta)

        res = context.compile_internal(builder, weibullvariate_impl,
                                        sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'np.random.f'``
----------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``f_impl`` `numba/targets/randomimpl.py` lines 823-832

.. code-block:: python

    @lower("np.random.f", types.Float, types.Float)
    def f_impl(context, builder, sig, args):

        def f_impl(num, denom):
            return ((np.random.chisquare(num) * denom) /
                    (np.random.chisquare(denom) * num))

        res = context.compile_internal(builder, f_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``numpy.core.numeric.identity``
------------------------------------------

signature `(Integer)`
~~~~~~~~~~~~~~~~~~~~~

by ``numpy_identity`` `numba/targets/arrayobj.py` lines 2835-2846

.. code-block:: python

    @lower_builtin(numpy.identity, types.Integer)
    def numpy_identity(context, builder, sig, args):

        def identity(n):
            arr = numpy.zeros((n, n))
            for i in range(n):
                arr[i, i] = 1
            return arr

        res = context.compile_internal(builder, identity, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Integer, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_identity`` `numba/targets/arrayobj.py` lines 2847-2858

.. code-block:: python

    @lower_builtin(numpy.identity, types.Integer, types.DTypeSpec)
    def numpy_identity(context, builder, sig, args):

        def identity(n, dtype):
            arr = numpy.zeros((n, n), dtype)
            for i in range(n):
                arr[i, i] = 1
            return arr

        res = context.compile_internal(builder, identity, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'array.cumprod'``
------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_cumprod`` `numba/targets/arraymath.py` lines 81-101

.. code-block:: python

    @lower_builtin(numpy.cumprod, types.Array)
    @lower_builtin("array.cumprod", types.Array)
    def array_cumprod(context, builder, sig, args):
        scalar_dtype = sig.return_type.dtype
        dtype = as_dtype(scalar_dtype)

        def array_cumprod_impl(arr):
            size = 1
            for i in arr.shape:
                size = size * i
            out = numpy.empty(size, dtype)
            c = 1
            for idx, v in enumerate(arr.flat):
                c *= v
                out[idx] = c
            return out

        res = context.compile_internal(builder, array_cumprod_impl, sig, args,
                                       locals=dict(c=scalar_dtype))
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'logical_or'>``
-----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.rect``
-------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``rect_impl`` `numba/targets/cmathimpl.py` lines 62-95

.. code-block:: python

    @lower(cmath.rect, types.Float, types.Float)
    def rect_impl(context, builder, sig, args):
        [r, phi] = args
        # We can't call math.isfinite() inside rect() below because it
        # only exists on 3.2+.
        phi_is_finite = mathimpl.is_finite(builder, phi)

        def rect(r, phi, phi_is_finite):
            if not phi_is_finite:
                if not r:
                    # cmath.rect(0, phi={inf, nan}) = 0
                    return abs(r)
                if math.isinf(r):
                    # cmath.rect(inf, phi={inf, nan}) = inf + j phi
                    return complex(r, phi)
            real = math.cos(phi)
            imag = math.sin(phi)
            if real == 0. and math.isinf(r):
                # 0 * inf would return NaN, we want to keep 0 but xor the sign
                real /= r
            else:
                real *= r
            if imag == 0. and math.isinf(r):
                # ditto
                imag /= r
            else:
                imag *= r
            return complex(real, imag)

        inner_sig = signature(sig.return_type, *sig.args + (types.boolean,))
        res = context.compile_internal(builder, rect, inner_sig,
                                        args + [phi_is_finite])
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'__array__'``
--------------------------

signature `(SmartArrayType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_as_array`` `numba/targets/smartarray.py` lines 20-25

.. code-block:: python

    @lower_builtin('__array__', types.SmartArrayType)
    def array_as_array(context, builder, sig, args):
        [argtype], [arg] = sig.args, args
        val = context.make_helper(builder, argtype, ref=arg)
        return val._get_ptr_by_name('data')


Lower Impl ``<ufunc 'logical_xor'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``builtins.slice``
-----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``slice_constructor_impl`` `numba/targets/slicing.py` lines 134-173

.. code-block:: python

    @lower_builtin(slice, types.VarArg(types.Any))
    def slice_constructor_impl(context, builder, sig, args):
        default_start_pos, default_start_neg, default_stop_pos, default_stop_neg, default_step = \
            [context.get_constant(types.intp, x) for x in get_defaults(context)]

        # Fetch non-None arguments
        slice_args = [None] * 3
        for i, (ty, val) in enumerate(zip(sig.args, args)):
            if ty is types.none:
                slice_args[i] = None
            else:
                slice_args[i] = val

        # Fill omitted arguments
        def get_arg_value(i, default):
            val = slice_args[i]
            if val is None:
                return default
            else:
                return val

        step = get_arg_value(2, default_step)
        is_step_negative = builder.icmp_signed('<', step,
                                               context.get_constant(types.intp, 0))
        default_stop = builder.select(is_step_negative,
                                      default_stop_neg, default_stop_pos)
        default_start = builder.select(is_step_negative,
                                       default_start_neg, default_start_pos)
        stop = get_arg_value(1, default_stop)
        start = get_arg_value(0, default_start)

        ty = sig.return_type
        sli = context.make_helper(builder, sig.return_type)
        sli.start = start
        sli.stop = stop
        sli.step = step

        res = sli._getvalue()
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'^='``
-------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_inplace`` `numba/targets/setobj.py` lines 1262-1267

.. code-block:: python

    @lower_builtin(op, types.Set, types.Set)
    def set_inplace(context, builder, sig, args, op_impl=op_impl):
        assert sig.return_type == sig.args[0]
        op_impl(context, builder, sig, args)
        return impl_ret_borrowed(context, builder, sig.args[0], args[0])


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``'array.astype'``
-----------------------------

signature `(Array, DTypeSpec)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``array_astype`` `numba/targets/arrayobj.py` lines 3121-3149

.. code-block:: python

    @lower_builtin("array.astype", types.Array, types.DTypeSpec)
    def array_astype(context, builder, sig, args):
        arytype = sig.args[0]
        ary = make_array(arytype)(context, builder, value=args[0])
        shapes = cgutils.unpack_tuple(builder, ary.shape)

        rettype = sig.return_type
        ret = _empty_nd_impl(context, builder, rettype, shapes)

        src_data = ary.data
        dest_data = ret.data

        src_strides = cgutils.unpack_tuple(builder, ary.strides)
        dest_strides = cgutils.unpack_tuple(builder, ret.strides)
        intp_t = context.get_value_type(types.intp)

        with cgutils.loop_nest(builder, shapes, intp_t) as indices:
            src_ptr = cgutils.get_item_pointer2(builder, src_data,
                                                shapes, src_strides,
                                                arytype.layout, indices)
            dest_ptr = cgutils.get_item_pointer2(builder, dest_data,
                                                 shapes, dest_strides,
                                                 rettype.layout, indices)
            item = load_item(context, builder, arytype, src_ptr)
            item = context.cast(builder, item, arytype.dtype, rettype.dtype)
            store_item(context, builder, rettype, item, dest_ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, ret._getvalue())


Lower Impl ``cmath.polar``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``intrinsic_complex_unary.<locals>.wrapper`` `numba/targets/cmathimpl.py` lines 97-112

.. code-block:: python

    def wrapper(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        x = z.real
        y = z.imag
        # Same as above: math.isfinite() is unavailable on 2.x so we precompute
        # its value and pass it to the pure Python implementation.
        x_is_finite = mathimpl.is_finite(builder, x)
        y_is_finite = mathimpl.is_finite(builder, y)
        inner_sig = signature(sig.return_type,
                              *(typ.underlying_float,) * 2 + (types.boolean,) * 2)
        res = context.compile_internal(builder, inner_func, inner_sig,
                                        (x, y, x_is_finite, y_is_finite))
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'list.pop'``
-------------------------

signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_pop`` `numba/targets/listobj.py` lines 858-869

.. code-block:: python

    @lower_builtin("list.pop", types.List)
    def list_pop(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])

        n = inst.size
        cgutils.guard_zero(context, builder, n,
                           (IndexError, "pop from empty list"))
        n = builder.sub(n, ir.Constant(n.type, 1))
        res = inst.getitem(n)
        inst.resize(n)
        return res


signature `(List, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_pop`` `numba/targets/listobj.py` lines 870-887

.. code-block:: python

    @lower_builtin("list.pop", types.List, types.Integer)
    def list_pop(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        idx = inst.fix_index(args[1])

        n = inst.size
        cgutils.guard_zero(context, builder, n,
                           (IndexError, "pop from empty list"))
        inst.guard_index(idx, "pop index out of range")

        res = inst.getitem(idx)

        one = ir.Constant(n.type, 1)
        n = builder.sub(n, ir.Constant(n.type, 1))
        inst.move(idx, builder.add(idx, one), builder.sub(n, idx))
        inst.resize(n)
        return res


Lower Impl ``<ufunc 'maximum'>``
--------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.pow``
-----------------------

signature `(Float, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``pow_impl`` `numba/targets/mathimpl.py` lines 390-395

.. code-block:: python

    @lower(math.pow, types.Float, types.Float)
    @lower(math.pow, types.Float, types.Integer)
    def pow_impl(context, builder, sig, args):
        impl = context.get_function("**", sig)
        return impl(builder, args)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``pow_impl`` `numba/targets/mathimpl.py` lines 390-395

.. code-block:: python

    @lower(math.pow, types.Float, types.Float)
    @lower(math.pow, types.Float, types.Integer)
    def pow_impl(context, builder, sig, args):
        impl = context.get_function("**", sig)
        return impl(builder, args)


Lower Impl ``'<<'``
-------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_shl_impl`` `numba/targets/numbers.py` lines 287-294

.. code-block:: python

    def int_shl_impl(context, builder, sig, args):
        [valty, amtty] = sig.args
        [val, amt] = args
        val = context.cast(builder, val, valty, sig.return_type)
        amt = context.cast(builder, amt, amtty, sig.return_type)
        res = builder.shl(val, amt)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``<ufunc 'minimum'>``
--------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.fromnumeric.cumsum``
--------------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_cumsum`` `numba/targets/arraymath.py` lines 57-78

.. code-block:: python

    @lower_builtin(numpy.cumsum, types.Array)
    @lower_builtin("array.cumsum", types.Array)
    def array_cumsum(context, builder, sig, args):
        scalar_dtype = sig.return_type.dtype
        dtype = as_dtype(scalar_dtype)
        zero = scalar_dtype(0)

        def array_cumsum_impl(arr):
            size = 1
            for i in arr.shape:
                size = size * i
            out = numpy.empty(size, dtype)
            c = zero
            for idx, v in enumerate(arr.flat):
                c += v
                out[idx] = c
            return out

        res = context.compile_internal(builder, array_cumsum_impl, sig, args,
                                       locals=dict(c=scalar_dtype))
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'array.flatten'``
------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_flatten`` `numba/targets/arrayobj.py` lines 1282-1291

.. code-block:: python

    @lower_builtin('array.flatten', types.Array)
    def array_flatten(context, builder, sig, args):
        # Only support flattening to C layout currently.
        def imp(ary):
            return ary.copy().reshape(ary.size)

        res = context.compile_internal(builder, imp, sig, args)
        res = impl_ret_new_ref(context, builder, sig.return_type, res)
        return res


Lower Impl ``'np.random.beta'``
-------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``betavariate_impl`` `numba/targets/randomimpl.py` lines 541-547

.. code-block:: python

    @lower("np.random.beta",
               types.Float, types.Float)
    def betavariate_impl(context, builder, sig, args):
        res = _betavariate_impl(context, builder, sig, args,
                                 np.random.gamma)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'random.normalvariate'``
-------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``gauss_impl`` `numba/targets/randomimpl.py` lines 206-211

.. code-block:: python

    @lower("random.gauss", types.Float, types.Float)
    @lower("random.normalvariate", types.Float, types.Float)
    def gauss_impl(context, builder, sig, args):
        res = _gauss_impl(context, builder, sig, args, "py")
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'list.insert'``
----------------------------

signature `(List, Integer, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_insert`` `numba/targets/listobj.py` lines 841-857

.. code-block:: python

    @lower_builtin("list.insert", types.List, types.Integer,
               types.Any)
    def list_insert(context, builder, sig, args):
        inst = ListInstance(context, builder, sig.args[0], args[0])
        index = inst.fix_index(args[1])
        index = inst.clamp_index(index)
        value = args[2]

        n = inst.size
        one = ir.Constant(n.type, 1)
        new_size = builder.add(n, one)
        inst.resize(new_size)
        inst.move(builder.add(index, one), index, builder.sub(n, index))
        inst.setitem(index, value)

        return context.get_dummy_value()


Lower Impl ``numpy.lib.twodim_base.diag``
-----------------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``numpy_diag`` `numba/targets/arrayobj.py` lines 2907-2912

.. code-block:: python

    @lower_builtin(numpy.diag, types.Array)
    def numpy_diag(context, builder, sig, args):
        def diag_impl(val):
            return numpy.diag(val, k=0)
        return context.compile_internal(builder, diag_impl, sig, args)


signature `(Array, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_diag_kwarg`` `numba/targets/arrayobj.py` lines 2913-2955

.. code-block:: python

    @lower_builtin(numpy.diag, types.Array, types.Integer)
    def numpy_diag_kwarg(context, builder, sig, args):
        arg = sig.args[0]
        if arg.ndim == 1:
            # vector context
            def diag_impl(arr, k=0):
                s = arr.shape
                n = s[0] + abs(k)
                ret = numpy.zeros((n, n), arr.dtype)
                if k >= 0:
                    for i in range(n - k):
                        ret[i, k + i] = arr[i]
                else:
                    for i in range(n + k):
                        ret[i - k, i] = arr[i]
                return ret
        elif arg.ndim == 2:
            # matrix context
            def diag_impl(arr, k=0):
                #Will return arr.diagonal(v, k) when axis args are supported
                rows, cols = arr.shape
                r = rows
                c = cols
                if k < 0:
                    rows = rows + k
                if k > 0:
                    cols = cols - k
                n = max(min(rows, cols), 0)
                ret = numpy.empty(n, arr.dtype)
                if k >= 0:
                    for i in range(n):
                        ret[i] = arr[i, k + i]
                else:
                    for i in range(n):
                        ret[i] = arr[i - k, i]
                return ret
        else:
            #invalid input
            raise ValueError("Input must be 1- or 2-d.")

        res = context.compile_internal(builder, diag_impl, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'np.random.poisson'``
----------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``poisson_impl`` `numba/targets/randomimpl.py` lines 981-1041

.. code-block:: python

    @lower("np.random.poisson")
    @lower("np.random.poisson", types.Float)
    def poisson_impl(context, builder, sig, args):
        state_ptr = get_np_state_ptr(context, builder)

        retptr = cgutils.alloca_once(builder, int64_t, name="ret")
        bbcont = builder.append_basic_block("bbcont")
        bbend = builder.append_basic_block("bbend")

        if len(args) == 1:
            lam, = args
            big_lam = builder.fcmp_ordered('>=', lam, ir.Constant(double, 10.0))
            with builder.if_then(big_lam):
                # For lambda >= 10.0, we switch to a more accurate
                # algorithm (see _helperlib.c).
                fnty = ir.FunctionType(int64_t, (rnd_state_ptr_t, double))
                fn = builder.function.module.get_or_insert_function(fnty,
                                                                    "numba_poisson_ptrs")
                ret = builder.call(fn, (state_ptr, lam))
                builder.store(ret, retptr)
                builder.branch(bbend)

        builder.branch(bbcont)
        builder.position_at_end(bbcont)

        _random = np.random.random
        _exp = math.exp

        def poisson_impl(lam):
            """Numpy's algorithm for poisson() on small *lam*.

            This method is invoked only if the parameter lambda of the
            distribution is small ( < 10 ). The algorithm used is described
            in "Knuth, D. 1969. 'Seminumerical Algorithms. The Art of
            Computer Programming' vol 2.
            """
            if lam < 0.0:
                raise ValueError("poisson(): lambda < 0")
            if lam == 0.0:
                return 0
            enlam = _exp(-lam)
            X = 0
            prod = 1.0
            while 1:
                U = _random()
                prod *= U
                if prod <= enlam:
                    return X
                X += 1

        if len(args) == 0:
            sig = signature(sig.return_type, types.float64)
            args = (ir.Constant(double, 1.0),)

        ret = context.compile_internal(builder, poisson_impl, sig, args)
        builder.store(ret, retptr)
        builder.branch(bbend)
        builder.position_at_end(bbend)
        res = builder.load(retptr)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `()`
~~~~~~~~~~~~~~

by ``poisson_impl`` `numba/targets/randomimpl.py` lines 981-1041

.. code-block:: python

    @lower("np.random.poisson")
    @lower("np.random.poisson", types.Float)
    def poisson_impl(context, builder, sig, args):
        state_ptr = get_np_state_ptr(context, builder)

        retptr = cgutils.alloca_once(builder, int64_t, name="ret")
        bbcont = builder.append_basic_block("bbcont")
        bbend = builder.append_basic_block("bbend")

        if len(args) == 1:
            lam, = args
            big_lam = builder.fcmp_ordered('>=', lam, ir.Constant(double, 10.0))
            with builder.if_then(big_lam):
                # For lambda >= 10.0, we switch to a more accurate
                # algorithm (see _helperlib.c).
                fnty = ir.FunctionType(int64_t, (rnd_state_ptr_t, double))
                fn = builder.function.module.get_or_insert_function(fnty,
                                                                    "numba_poisson_ptrs")
                ret = builder.call(fn, (state_ptr, lam))
                builder.store(ret, retptr)
                builder.branch(bbend)

        builder.branch(bbcont)
        builder.position_at_end(bbcont)

        _random = np.random.random
        _exp = math.exp

        def poisson_impl(lam):
            """Numpy's algorithm for poisson() on small *lam*.

            This method is invoked only if the parameter lambda of the
            distribution is small ( < 10 ). The algorithm used is described
            in "Knuth, D. 1969. 'Seminumerical Algorithms. The Art of
            Computer Programming' vol 2.
            """
            if lam < 0.0:
                raise ValueError("poisson(): lambda < 0")
            if lam == 0.0:
                return 0
            enlam = _exp(-lam)
            X = 0
            prod = 1.0
            while 1:
                U = _random()
                prod *= U
                if prod <= enlam:
                    return X
                X += 1

        if len(args) == 0:
            sig = signature(sig.return_type, types.float64)
            args = (ir.Constant(double, 1.0),)

        ret = context.compile_internal(builder, poisson_impl, sig, args)
        builder.store(ret, retptr)
        builder.branch(bbend)
        builder.position_at_end(bbend)
        res = builder.load(retptr)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``<ufunc 'multiply'>``
---------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.atan``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``atan_impl`` `numba/targets/cmathimpl.py` lines 457-470

.. code-block:: python

    @lower(cmath.atan, types.Complex)
    def atan_impl(context, builder, sig, args):
        def atan_impl(z):
            """cmath.atan(z) = -j * cmath.atanh(z j)"""
            r = cmath.atanh(complex(-z.imag, z.real))
            if math.isinf(z.real) and math.isnan(z.imag):
                # XXX this is odd but necessary
                return complex(r.imag, r.real)
            else:
                return complex(r.imag, -r.real)

        res = context.compile_internal(builder, atan_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``cmath.isfinite``
-----------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``isfinite_float_impl`` `numba/targets/cmathimpl.py` lines 53-60

.. code-block:: python

    @lower(cmath.isfinite, types.Complex)
    def isfinite_float_impl(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        res = is_finite(builder, z)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'>'``
------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_gt`` `numba/targets/listobj.py` lines 708-715

.. code-block:: python

    @lower_builtin('>', types.List, types.List)
    def list_gt(context, builder, sig, args):

        def list_gt_impl(a, b):
            return b < a

        return context.compile_internal(builder, list_gt_impl, sig, args)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_gt`` `numba/targets/setobj.py` lines 1374-1380

.. code-block:: python

    @lower_builtin(">", types.Set, types.Set)
    def set_gt(context, builder, sig, args):
        def gt_impl(a, b):
            return b < a

        return context.compile_internal(builder, gt_impl, sig, args)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ugt_impl`` `numba/targets/numbers.py` lines 253-256

.. code-block:: python

    def int_ugt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint8, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ugt_impl`` `numba/targets/numbers.py` lines 253-256

.. code-block:: python

    def int_ugt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint32, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ugt_impl`` `numba/targets/numbers.py` lines 253-256

.. code-block:: python

    def int_ugt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint16, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ugt_impl`` `numba/targets/numbers.py` lines 253-256

.. code-block:: python

    def int_ugt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ugt_impl`` `numba/targets/numbers.py` lines 253-256

.. code-block:: python

    def int_ugt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_UGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int8, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sgt_impl`` `numba/targets/numbers.py` lines 233-236

.. code-block:: python

    def int_sgt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int32, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sgt_impl`` `numba/targets/numbers.py` lines 233-236

.. code-block:: python

    def int_sgt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sgt_impl`` `numba/targets/numbers.py` lines 233-236

.. code-block:: python

    def int_sgt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int16, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_sgt_impl`` `numba/targets/numbers.py` lines 233-236

.. code-block:: python

    def int_sgt_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_SGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_gt_impl`` `numba/targets/numbers.py` lines 672-675

.. code-block:: python

    def real_gt_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_OGT, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_gt`` `numba/targets/tupleobj.py` lines 77-81

.. code-block:: python

    @lower_builtin('>', types.BaseTuple, types.BaseTuple)
    def tuple_gt(context, builder, sig, args):
        res = tuple_cmp_ordered(context, builder, '>', sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_ordering_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 291-306

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaT with something else
                # (i.e. NaT is <= everything else, since it's the smallest
                #  int64 value)
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'is not'``
-----------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``generic_is_not`` `numba/targets/builtins.py` lines 19-26

.. code-block:: python

    @lower_builtin('is not', types.Any, types.Any)
    def generic_is_not(context, builder, sig, args):
        """
        Implement `x is not y` as `not (x is y)`.
        """
        is_impl = context.get_function('is', sig)
        return builder.not_(is_impl(builder, args))


Lower Impl ``<ufunc 'negative'>``
---------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.isnan``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``isnan_float_impl`` `numba/targets/cmathimpl.py` lines 35-42

.. code-block:: python

    @lower(cmath.isnan, types.Complex)
    def isnan_float_impl(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        res = is_nan(builder, z)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``builtins.enumerate``
---------------------------------

signature `(IterableType, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_enumerate_object`` `numba/targets/iterators.py` lines 20-45

.. code-block:: python

    @lower_builtin(enumerate, types.IterableType)
    @lower_builtin(enumerate, types.IterableType, types.Integer)
    def make_enumerate_object(context, builder, sig, args):
        assert len(args) == 1 or len(args) == 2 # enumerate(it) or enumerate(it, start)
        srcty = sig.args[0]

        if len(args) == 1:
            src = args[0]
            start_val = context.get_constant(types.intp, 0)
        elif len(args) == 2:
            src = args[0]
            start_val = context.cast(builder, args[1], sig.args[1], types.intp)

        iterobj = call_getiter(context, builder, srcty, src)

        enum = context.make_helper(builder, sig.return_type)

        countptr = cgutils.alloca_once(builder, start_val.type)
        builder.store(start_val, countptr)

        enum.count = countptr
        enum.iter = iterobj

        res = enum._getvalue()
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(IterableType)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``make_enumerate_object`` `numba/targets/iterators.py` lines 20-45

.. code-block:: python

    @lower_builtin(enumerate, types.IterableType)
    @lower_builtin(enumerate, types.IterableType, types.Integer)
    def make_enumerate_object(context, builder, sig, args):
        assert len(args) == 1 or len(args) == 2 # enumerate(it) or enumerate(it, start)
        srcty = sig.args[0]

        if len(args) == 1:
            src = args[0]
            start_val = context.get_constant(types.intp, 0)
        elif len(args) == 2:
            src = args[0]
            start_val = context.cast(builder, args[1], sig.args[1], types.intp)

        iterobj = call_getiter(context, builder, srcty, src)

        enum = context.make_helper(builder, sig.return_type)

        countptr = cgutils.alloca_once(builder, start_val.type)
        builder.store(start_val, countptr)

        enum.count = countptr
        enum.iter = iterobj

        res = enum._getvalue()
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'array.cumsum'``
-----------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_cumsum`` `numba/targets/arraymath.py` lines 57-78

.. code-block:: python

    @lower_builtin(numpy.cumsum, types.Array)
    @lower_builtin("array.cumsum", types.Array)
    def array_cumsum(context, builder, sig, args):
        scalar_dtype = sig.return_type.dtype
        dtype = as_dtype(scalar_dtype)
        zero = scalar_dtype(0)

        def array_cumsum_impl(arr):
            size = 1
            for i in arr.shape:
                size = size * i
            out = numpy.empty(size, dtype)
            c = zero
            for idx, v in enumerate(arr.flat):
                c += v
                out[idx] = c
            return out

        res = context.compile_internal(builder, array_cumsum_impl, sig, args,
                                       locals=dict(c=scalar_dtype))
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'list.copy'``
--------------------------

signature `(List)`
~~~~~~~~~~~~~~~~~~

by ``list_copy`` `numba/targets/listobj.py` lines 738-744

.. code-block:: python

    @lower_builtin("list.copy", types.List)
    def list_copy(context, builder, sig, args):
        def list_copy_impl(lst):
            return list(lst)

        return context.compile_internal(builder, list_copy_impl, sig, args)


Lower Impl ``cmath.isinf``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``isinf_float_impl`` `numba/targets/cmathimpl.py` lines 43-50

.. code-block:: python

    @lower(cmath.isinf, types.Complex)
    def isinf_float_impl(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        res = is_inf(builder, z)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'!='``
-------------------

signature `(List, List)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``list_ne`` `numba/targets/listobj.py` lines 662-669

.. code-block:: python

    @lower_builtin('!=', types.List, types.List)
    def list_ne(context, builder, sig, args):

        def list_ne_impl(a, b):
            return not (a == b)

        return context.compile_internal(builder, list_ne_impl, sig, args)


signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_ne`` `numba/targets/setobj.py` lines 1360-1366

.. code-block:: python

    @lower_builtin("!=", types.Set, types.Set)
    def set_ne(context, builder, sig, args):
        def ne_impl(a, b):
            return not a == b

        return context.compile_internal(builder, ne_impl, sig, args)


signature `(EnumMember, EnumMember)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``enum_eq`` `numba/targets/enumimpl.py` lines 32-39

.. code-block:: python

    @lower_builtin('!=', types.EnumMember, types.EnumMember)
    def enum_eq(context, builder, sig, args):
        tu, tv = sig.args
        u, v = args
        res = context.generic_compare(builder, "!=",
                                      (tu.dtype, tv.dtype), (u, v))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(bool, bool)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ne_impl`` `numba/targets/numbers.py` lines 268-271

.. code-block:: python

    def int_ne_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_NE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_ne_impl`` `numba/targets/numbers.py` lines 268-271

.. code-block:: python

    def int_ne_impl(context, builder, sig, args):
        res = builder.icmp(lc.ICMP_NE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_ne_impl`` `numba/targets/numbers.py` lines 687-690

.. code-block:: python

    def real_ne_impl(context, builder, sig, args):
        res = builder.fcmp(lc.FCMP_UNE, *args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex_ne_impl`` `numba/targets/numbers.py` lines 962-972

.. code-block:: python

    def complex_ne_impl(context, builder, sig, args):
        [cx, cy] = args
        typ = sig.args[0]
        x = context.make_complex(builder, typ, value=cx)
        y = context.make_complex(builder, typ, value=cy)

        reals_are_ne = builder.fcmp(lc.FCMP_UNE, x.real, y.real)
        imags_are_ne = builder.fcmp(lc.FCMP_UNE, x.imag, y.imag)
        res = builder.or_(reals_are_ne, imags_are_ne)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(BaseTuple, BaseTuple)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``tuple_ne`` `numba/targets/tupleobj.py` lines 62-66

.. code-block:: python

    @lower_builtin('!=', types.BaseTuple, types.BaseTuple)
    def tuple_ne(context, builder, sig, args):
        res = builder.not_(tuple_eq(context, builder, sig, args))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta, NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_timedelta_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 268-286

.. code-block:: python

    def impl(context, builder, sig, args):
        [va, vb] = args
        [ta, tb] = sig.args
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                try:
                    norm_a, norm_b = normalize_timedeltas(context, builder, va, vb, ta, tb)
                except RuntimeError:
                    # Cannot normalize units => the values are unequal (except if NaT)
                    builder.store(default_value, ret)
                else:
                    builder.store(builder.icmp(ll_op, norm_a, norm_b), ret)
            with otherwise:
                # No scaling when comparing NaTs
                builder.store(builder.icmp(ll_op, va, vb), ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPDatetime, NPDatetime)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``_create_datetime_comparison_impl.<locals>.impl`` `numba/targets/npdatetime.py` lines 529-548

.. code-block:: python

    def impl(context, builder, sig, args):
        va, vb = args
        ta, tb = sig.args
        unit_a = ta.unit
        unit_b = tb.unit
        ret_unit = npdatetime.get_best_unit(unit_a, unit_b)
        ret = alloc_boolean_result(builder)
        with builder.if_else(are_not_nat(builder, [va, vb])) as (then, otherwise):
            with then:
                norm_a = convert_datetime_for_arith(builder, va, unit_a, ret_unit)
                norm_b = convert_datetime_for_arith(builder, vb, unit_b, ret_unit)
                ret_val = builder.icmp(ll_op, norm_a, norm_b)
                builder.store(ret_val, ret)
            with otherwise:
                # No scaling when comparing NaTs
                ret_val = builder.icmp(ll_op, va, vb)
                builder.store(ret_val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.shuffle'``
----------------------------------

signature `(Buffer)`
~~~~~~~~~~~~~~~~~~~~

by ``shuffle_impl`` `numba/targets/randomimpl.py` lines 1144-1148

.. code-block:: python

    @lower("np.random.shuffle", types.Buffer)
    def shuffle_impl(context, builder, sig, args):
        res = _shuffle_impl(context, builder, sig, args, np.random.randint)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'remainder'>``
----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``math.hypot``
-------------------------

signature `(int64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``hypot_s64_impl`` `numba/targets/mathimpl.py` lines 334-342

.. code-block:: python

    @lower(math.hypot, types.int64, types.int64)
    def hypot_s64_impl(context, builder, sig, args):
        [x, y] = args
        y = builder.sitofp(y, Type.double())
        x = builder.sitofp(x, Type.double())
        fsig = signature(types.float64, types.float64, types.float64)
        res = hypot_float_impl(context, builder, fsig, (x, y))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(uint64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``hypot_u64_impl`` `numba/targets/mathimpl.py` lines 343-351

.. code-block:: python

    @lower(math.hypot, types.uint64, types.uint64)
    def hypot_u64_impl(context, builder, sig, args):
        [x, y] = args
        y = builder.sitofp(y, Type.double())
        x = builder.sitofp(x, Type.double())
        fsig = signature(types.float64, types.float64, types.float64)
        res = hypot_float_impl(context, builder, fsig, (x, y))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``hypot_float_impl`` `numba/targets/mathimpl.py` lines 353-364

.. code-block:: python

    @lower(math.hypot, types.Float, types.Float)
    def hypot_float_impl(context, builder, sig, args):
        def hypot(x, y):
            if math.isinf(x):
                return abs(x)
            elif math.isinf(y):
                return abs(y)
            return math.sqrt(x * x + y * y)

        res = context.compile_internal(builder, hypot, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'array.prod'``
---------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_prod`` `numba/targets/arraymath.py` lines 43-56

.. code-block:: python

    @lower_builtin(numpy.prod, types.Array)
    @lower_builtin("array.prod", types.Array)
    def array_prod(context, builder, sig, args):

        def array_prod_impl(arr):
            c = 1
            for v in numpy.nditer(arr):
                c *= v.item()
            return c

        res = context.compile_internal(builder, array_prod_impl, sig, args,
                                        locals=dict(c=sig.return_type))
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'not_equal'>``
----------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``cmath.phase``
--------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``intrinsic_complex_unary.<locals>.wrapper`` `numba/targets/cmathimpl.py` lines 97-112

.. code-block:: python

    def wrapper(context, builder, sig, args):
        [typ] = sig.args
        [value] = args
        z = context.make_complex(builder, typ, value=value)
        x = z.real
        y = z.imag
        # Same as above: math.isfinite() is unavailable on 2.x so we precompute
        # its value and pass it to the pure Python implementation.
        x_is_finite = mathimpl.is_finite(builder, x)
        y_is_finite = mathimpl.is_finite(builder, y)
        inner_sig = signature(sig.return_type,
                              *(typ.underlying_float,) * 2 + (types.boolean,) * 2)
        res = context.compile_internal(builder, inner_func, inner_sig,
                                        (x, y, x_is_finite, y_is_finite))
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``'np.random.geometric'``
------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``geometric_impl`` `numba/targets/randomimpl.py` lines 834-858

.. code-block:: python

    @lower("np.random.geometric", types.Float)
    def geometric_impl(context, builder, sig, args):
        _random = np.random.random
        intty = sig.return_type

        def geometric_impl(p):
            # Numpy's algorithm.
            if p <= 0.0 or p > 1.0:
                raise ValueError("geometric(): p outside of (0, 1]")
            q = 1.0 - p
            if p >= 0.333333333333333333333333:
                X = intty(1)
                sum = prod = p
                U = _random()
                while U > sum:
                    prod *= q
                    sum += prod
                    X += 1
                return X
            else:
                return math.ceil(math.log(1.0 - _random()) / math.log(q))

        res = context.compile_internal(builder, geometric_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'set.pop'``
------------------------

signature `(Set)`
~~~~~~~~~~~~~~~~~

by ``set_pop`` `numba/targets/setobj.py` lines 1171-1180

.. code-block:: python

    @lower_builtin("set.pop", types.Set)
    def set_pop(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        used = inst.payload.used
        with builder.if_then(cgutils.is_null(builder, used), likely=False):
            context.call_conv.return_user_exc(builder, KeyError,
                                              ("set.pop(): empty set",))

        return inst.pop()


Lower Impl ``'array.min'``
--------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_min`` `numba/targets/arraymath.py` lines 145-183

.. code-block:: python

    @lower_builtin(numpy.min, types.Array)
    @lower_builtin("array.min", types.Array)
    def array_min(context, builder, sig, args):
        ty = sig.args[0].dtype
        if isinstance(ty, (types.NPDatetime, types.NPTimedelta)):
            # NaT is smaller than every other value, but it is
            # ignored as far as min() is concerned.
            nat = ty('NaT')

            def array_min_impl(arry):
                min_value = nat
                it = numpy.nditer(arry)
                for view in it:
                    v = view.item()
                    if v != nat:
                        min_value = v
                        break

                for view in it:
                    v = view.item()
                    if v != nat and v < min_value:
                        min_value = v
                return min_value

        else:
            def array_min_impl(arry):
                it = numpy.nditer(arry)
                for view in it:
                    min_value = view.item()
                    break

                for view in it:
                    v = view.item()
                    if v < min_value:
                        min_value = v
                return min_value
        res = context.compile_internal(builder, array_min_impl, sig, args)
        return impl_ret_borrowed(context, builder, sig.return_type, res)


Lower Impl ``'random.seed'``
----------------------------

signature `(uint32)`
~~~~~~~~~~~~~~~~~~~~

by ``seed_impl`` `numba/targets/randomimpl.py` lines 174-179

.. code-block:: python

    @lower("random.seed", types.uint32)
    def seed_impl(context, builder, sig, args):
        res =  _seed_impl(context, builder, sig, args, get_state_ptr(context,
                                                                     builder, "py"))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'power'>``
------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.triangular'``
-------------------------------------

signature `(Float, Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``triangular_impl_3`` `numba/targets/randomimpl.py` lines 423-429

.. code-block:: python

    @lower("np.random.triangular", types.Float,
               types.Float, types.Float)
    def triangular_impl_3(context, builder, sig, args):
        low, mode, high = args
        res = _triangular_impl_3(context, builder, sig, low, high, mode, "np")
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any, any, any)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'set.issuperset'``
-------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_issuperset`` `numba/targets/setobj.py` lines 1345-1352

.. code-block:: python

    @lower_builtin(">=", types.Set, types.Set)
    @lower_builtin("set.issuperset", types.Set, types.Set)
    def set_issuperset(context, builder, sig, args):
        def superset_impl(a, b):
            return b.issubset(a)

        return context.compile_internal(builder, superset_impl, sig, args)


Lower Impl ``builtins.abs``
---------------------------

signature `(uint8)`
~~~~~~~~~~~~~~~~~~~

by ``uint_abs_impl`` `numba/targets/numbers.py` lines 282-285

.. code-block:: python

    def uint_abs_impl(context, builder, sig, args):
        [x] = args
        return impl_ret_untracked(context, builder, sig.return_type, x)


signature `(uint32)`
~~~~~~~~~~~~~~~~~~~~

by ``uint_abs_impl`` `numba/targets/numbers.py` lines 282-285

.. code-block:: python

    def uint_abs_impl(context, builder, sig, args):
        [x] = args
        return impl_ret_untracked(context, builder, sig.return_type, x)


signature `(uint16)`
~~~~~~~~~~~~~~~~~~~~

by ``uint_abs_impl`` `numba/targets/numbers.py` lines 282-285

.. code-block:: python

    def uint_abs_impl(context, builder, sig, args):
        [x] = args
        return impl_ret_untracked(context, builder, sig.return_type, x)


signature `(uint64)`
~~~~~~~~~~~~~~~~~~~~

by ``uint_abs_impl`` `numba/targets/numbers.py` lines 282-285

.. code-block:: python

    def uint_abs_impl(context, builder, sig, args):
        [x] = args
        return impl_ret_untracked(context, builder, sig.return_type, x)


signature `(int8)`
~~~~~~~~~~~~~~~~~~

by ``int_abs_impl`` `numba/targets/numbers.py` lines 273-280

.. code-block:: python

    def int_abs_impl(context, builder, sig, args):
        [x] = args
        ZERO = Constant.null(x.type)
        ltz = builder.icmp(lc.ICMP_SLT, x, ZERO)
        negated = builder.neg(x)
        res = builder.select(ltz, negated, x)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int32)`
~~~~~~~~~~~~~~~~~~~

by ``int_abs_impl`` `numba/targets/numbers.py` lines 273-280

.. code-block:: python

    def int_abs_impl(context, builder, sig, args):
        [x] = args
        ZERO = Constant.null(x.type)
        ltz = builder.icmp(lc.ICMP_SLT, x, ZERO)
        negated = builder.neg(x)
        res = builder.select(ltz, negated, x)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int64)`
~~~~~~~~~~~~~~~~~~~

by ``int_abs_impl`` `numba/targets/numbers.py` lines 273-280

.. code-block:: python

    def int_abs_impl(context, builder, sig, args):
        [x] = args
        ZERO = Constant.null(x.type)
        ltz = builder.icmp(lc.ICMP_SLT, x, ZERO)
        negated = builder.neg(x)
        res = builder.select(ltz, negated, x)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(int16)`
~~~~~~~~~~~~~~~~~~~

by ``int_abs_impl`` `numba/targets/numbers.py` lines 273-280

.. code-block:: python

    def int_abs_impl(context, builder, sig, args):
        [x] = args
        ZERO = Constant.null(x.type)
        ltz = builder.icmp(lc.ICMP_SLT, x, ZERO)
        negated = builder.neg(x)
        res = builder.select(ltz, negated, x)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``real_abs_impl`` `numba/targets/numbers.py` lines 692-697

.. code-block:: python

    def real_abs_impl(context, builder, sig, args):
        [ty] = sig.args
        sig = typing.signature(ty, ty)
        impl = context.get_function(math.fabs, sig)
        return impl(builder, args)


signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``complex_abs_impl`` `numba/targets/numbers.py` lines 974-983

.. code-block:: python

    def complex_abs_impl(context, builder, sig, args):
        """
        abs(z) := hypot(z.real, z.imag)
        """
        def complex_abs(z):
            return math.hypot(z.real, z.imag)

        res = context.compile_internal(builder, complex_abs, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(NPTimedelta)`
~~~~~~~~~~~~~~~~~~~~~~~~~

by ``timedelta_abs_impl`` `numba/targets/npdatetime.py` lines 129-140

.. code-block:: python

    @lower_builtin(abs, types.NPTimedelta)
    def timedelta_abs_impl(context, builder, sig, args):
        val, = args
        ret = alloc_timedelta_result(builder)
        with builder.if_else(cgutils.is_scalar_neg(builder, val)) as (then, otherwise):
            with then:
                builder.store(builder.neg(val), ret)
            with otherwise:
                builder.store(val, ret)
        res = builder.load(ret)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'rad2deg'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``numpy.core.function_base.linspace``
------------------------------------------------

signature `(Number, Number)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_linspace_2`` `numba/targets/arrayobj.py` lines 3019-3027

.. code-block:: python

    @lower_builtin(numpy.linspace, types.Number, types.Number)
    def numpy_linspace_2(context, builder, sig, args):

        def linspace(start, stop):
            return numpy.linspace(start, stop, 50)

        res = context.compile_internal(builder, linspace, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


signature `(Number, Number, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``numpy_linspace_3`` `numba/targets/arrayobj.py` lines 3028-3044

.. code-block:: python

    @lower_builtin(numpy.linspace, types.Number, types.Number,
               types.Integer)
    def numpy_linspace_3(context, builder, sig, args):
        dtype = as_dtype(sig.return_type.dtype)

        def linspace(start, stop, num):
            arr = numpy.empty(num, dtype)
            div = num - 1
            delta = stop - start
            arr[0] = start
            for i in range(1, num):
                arr[i] = start + delta * (i / div)
            return arr

        res = context.compile_internal(builder, linspace, sig, args)
        return impl_ret_new_ref(context, builder, sig.return_type, res)


Lower Impl ``'set.symmetric_difference_update'``
------------------------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_symmetric_difference_update`` `numba/targets/setobj.py` lines 1225-1233

.. code-block:: python

    @lower_builtin("set.symmetric_difference_update", types.Set, types.Set)
    def set_symmetric_difference_update(context, builder, sig, args):
        inst = SetInstance(context, builder, sig.args[0], args[0])
        other = SetInstance(context, builder, sig.args[1], args[1])

        inst.symmetric_difference(other)

        return context.get_dummy_value()


Lower Impl ``_operator.neg``
----------------------------

signature `(*any)`
~~~~~~~~~~~~~~~~~~

by ``map_operator.<locals>.binop_impl`` `numba/targets/operatorimpl.py` lines 23-30

.. code-block:: python

    @lower(op_func, types.VarArg(types.Any))
    def binop_impl(context, builder, sig, args):
        if reverse_args:
            args = args[::-1]
            sig = typing.signature(sig.return_type, *sig.args[::-1])
        impl = context.get_function(op, sig)
        return impl(builder, args)


Lower Impl ``'set.symmetric_difference'``
-----------------------------------------

signature `(Set, Set)`
~~~~~~~~~~~~~~~~~~~~~~

by ``set_symmetric_difference`` `numba/targets/setobj.py` lines 1296-1311

.. code-block:: python

    @lower_builtin("^", types.Set, types.Set)
    @lower_builtin("set.symmetric_difference", types.Set, types.Set)
    def set_symmetric_difference(context, builder, sig, args):
        def symmetric_difference_impl(a, b):
            if len(a) > len(b):
                s = a.copy()
                s.symmetric_difference_update(b)
                return s
            else:
                s = b.copy()
                s.symmetric_difference_update(a)
                return s

        return context.compile_internal(builder, symmetric_difference_impl,
                                        sig, args)


Lower Impl ``math.ldexp``
-------------------------

signature `(Float, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``ldexp_impl`` `numba/targets/mathimpl.py` lines 276-288

.. code-block:: python

    @lower(math.ldexp, types.Float, types.intc)
    def ldexp_impl(context, builder, sig, args):
        val, exp = args
        fltty, intty = map(context.get_data_type, sig.args)
        fnty = Type.function(fltty, (fltty, intty))
        fname = {
            "float": "numba_ldexpf",
            "double": "numba_ldexp",
            }[str(fltty)]
        fn = cgutils.insert_pure_function(builder.module, fnty, name=fname)
        res = builder.call(fn, (val, exp))
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'radians'>``
--------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'//='``
--------------------

signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_inplace_operator`` `numba/targets/npyimpl.py` lines 474-482

.. code-block:: python

    def lower_inplace_operator(context, builder, sig, args):
        # The visible signature is (A, B) -> A
        # The implementation's signature (with explicit output)
        # is (A, B, A) -> A
        args = args + (args[0],)
        sig = typing.signature(sig.return_type, *sig.args + (sig.args[0],))
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=True)


Lower Impl ``'np.random.chisquare'``
------------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``chisquare_impl`` `numba/targets/randomimpl.py` lines 813-821

.. code-block:: python

    @lower("np.random.chisquare", types.Float)
    def chisquare_impl(context, builder, sig, args):

        def chisquare_impl(df):
            return 2.0 * np.random.standard_gamma(df / 2.0)

        res = context.compile_internal(builder, chisquare_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'array.nonzero'``
------------------------------

signature `(Array)`
~~~~~~~~~~~~~~~~~~~

by ``array_nonzero`` `numba/targets/arraymath.py` lines 693-751

.. code-block:: python

    @lower_builtin(numpy.nonzero, types.Array)
    @lower_builtin("array.nonzero", types.Array)
    @lower_builtin(numpy.where, types.Array)
    def array_nonzero(context, builder, sig, args):
        aryty = sig.args[0]
        # Return type is a N-tuple of 1D C-contiguous arrays
        retty = sig.return_type
        outaryty = retty.dtype
        ndim = aryty.ndim
        nouts = retty.count

        ary = make_array(aryty)(context, builder, args[0])
        shape = cgutils.unpack_tuple(builder, ary.shape)
        strides = cgutils.unpack_tuple(builder, ary.strides)
        data = ary.data
        layout = aryty.layout

        # First count the number of non-zero elements
        zero = context.get_constant(types.intp, 0)
        one = context.get_constant(types.intp, 1)
        count = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                builder.store(builder.add(builder.load(count), one), count)

        # Then allocate output arrays of the right size
        out_shape = (builder.load(count),)
        outs = [_empty_nd_impl(context, builder, outaryty, out_shape)._getvalue()
                for i in range(nouts)]
        outarys = [make_array(outaryty)(context, builder, out) for out in outs]
        out_datas = [out.data for out in outarys]

        # And fill them up
        index = cgutils.alloca_once_value(builder, zero)
        with cgutils.loop_nest(builder, shape, zero.type) as indices:
            ptr = cgutils.get_item_pointer2(builder, data, shape, strides,
                                            layout, indices)
            val = load_item(context, builder, aryty, ptr)
            nz = context.is_true(builder, aryty.dtype, val)
            with builder.if_then(nz):
                # Store element indices in output arrays
                if not indices:
                    # For a 0-d array, store 0 in the unique output array
                    indices = (zero,)
                cur = builder.load(index)
                for i in range(nouts):
                    ptr = cgutils.get_item_pointer2(builder, out_datas[i],
                                                    out_shape, (),
                                                    'C', [cur])
                    store_item(context, builder, outaryty, indices[i], ptr)
                builder.store(builder.add(cur, one), index)

        tup = context.make_tuple(builder, sig.return_type, outs)
        return impl_ret_new_ref(context, builder, sig.return_type, tup)


Lower Impl ``'random.vonmisesvariate'``
---------------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``vonmisesvariate_impl`` `numba/targets/randomimpl.py` lines 690-695

.. code-block:: python

    @lower("random.vonmisesvariate",
               types.Float, types.Float)
    def vonmisesvariate_impl(context, builder, sig, args):
        res = _vonmisesvariate_impl(context, builder, sig, args, random.random)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``<ufunc 'bitwise_and'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'random.random'``
------------------------------

signature `()`
~~~~~~~~~~~~~~

by ``random_impl`` `numba/targets/randomimpl.py` lines 193-198

.. code-block:: python

    @lower("random.random")
    def random_impl(context, builder, sig, args):
        state_ptr = get_state_ptr(context, builder, "py")
        res = get_next_double(context, builder, state_ptr)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'not in'``
-----------------------

signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``not_in`` `numba/targets/builtins.py` lines 294-301

.. code-block:: python

    @lower_builtin("not in", types.Any, types.Any)
    def not_in(context, builder, sig, args):
        def in_impl(a, b):
            return a in b

        res = context.compile_internal(builder, in_impl, sig, args)
        return builder.not_(res)


Lower Impl ``<ufunc 'arccos'>``
-------------------------------

signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc`` `numba/targets/npyimpl.py` lines 426-428

.. code-block:: python

    def unary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any)`
~~~~~~~~~~~~~~~~~

by ``register_unary_ufunc_kernel.<locals>.unary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 429-432

.. code-block:: python

    def unary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``'np.random.zipf'``
-------------------------------

signature `(Float)`
~~~~~~~~~~~~~~~~~~~

by ``zipf_impl`` `numba/targets/randomimpl.py` lines 1117-1137

.. code-block:: python

    @lower("np.random.zipf", types.Float)
    def zipf_impl(context, builder, sig, args):
        _random = np.random.random
        intty = sig.return_type

        def zipf_impl(a):
            if a <= 1.0:
                raise ValueError("zipf(): a <= 1")
            am1 = a - 1.0
            b = 2.0 ** am1
            while 1:
                U = 1.0 - _random()
                V = _random()
                X = intty(math.floor(U ** (-1.0 / am1)))
                T = (1.0 + 1.0 / X) ** am1
                if X >= 1 and V * X * (T - 1.0) / (b - 1.0) <= (T / b):
                    return X

        res = context.compile_internal(builder, zipf_impl, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``random_arr`` `numba/targets/randomimpl.py` lines 1198-1219

.. code-block:: python

    @lower(typing_key, *(types.Any,) * arity)
    def random_arr(context, builder, sig, args, typing_key=typing_key):
        from . import arrayobj

        arrty = sig.return_type
        dtype = arrty.dtype
        scalar_sig = signature(dtype, *sig.args[:-1])
        scalar_args = args[:-1]

        # Allocate array...
        shapes = arrayobj._parse_shape(context, builder, sig.args[-1], args[-1])
        arr = arrayobj._empty_nd_impl(context, builder, arrty, shapes)

        # ... and populate it in natural order
        scalar_impl = context.get_function(typing_key, scalar_sig)
        with cgutils.for_range(builder, arr.nitems) as loop:
            val = scalar_impl(builder, scalar_args)
            ptr = cgutils.gep(builder, arr.data, loop.index)
            arrayobj.store_item(context, builder, arrty, val, ptr)

        return impl_ret_new_ref(context, builder, sig.return_type, arr._getvalue())


Lower Impl ``'random.betavariate'``
-----------------------------------

signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``betavariate_impl`` `numba/targets/randomimpl.py` lines 534-540

.. code-block:: python

    @lower("random.betavariate",
               types.Float, types.Float)
    def betavariate_impl(context, builder, sig, args):
        res = _betavariate_impl(context, builder, sig, args,
                                 random.gammavariate)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``'**'``
-------------------

signature `(Integer, Integer)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, uint64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int8)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int32)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int64)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(float64, int16)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``int_power_impl`` `numba/targets/numbers.py` lines 177-221

.. code-block:: python

    def int_power_impl(context, builder, sig, args):
        """
        a ^ b, where a is an integer or real, and b an integer
        """
        is_integer = isinstance(sig.args[0], types.Integer)
        tp = sig.return_type
        zerodiv_return = False
        if is_integer and not context.error_model.raise_on_fp_zero_division:
            # If not raising, return 0x8000... when computing 0 ** <negative number>
            zerodiv_return = -1 << (tp.bitwidth - 1)

        def int_power(a, b):
            # Ensure computations are done with a large enough width
            r = tp(1)
            a = tp(a)
            if b < 0:
                invert = True
                exp = -b
                if exp < 0:
                    raise OverflowError
                if is_integer:
                    if a == 0:
                        if zerodiv_return:
                            return zerodiv_return
                        else:
                            raise ZeroDivisionError("0 cannot be raised to a negative power")
                    if a != 1 and a != -1:
                        return 0
            else:
                invert = False
                exp = b
            if exp > 0x10000:
                # Optimization cutoff: fallback on the generic algorithm
                return math.pow(a, float(b))
            while exp != 0:
                if exp & 1:
                    r *= a
                exp >>= 1
                a *= a

            return 1.0 / r if invert else r

        res = context.compile_internal(builder, int_power, sig, args)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Float, Float)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``real_power_impl`` `numba/targets/numbers.py` lines 650-660

.. code-block:: python

    def real_power_impl(context, builder, sig, args):
        x, y = args
        module = builder.module
        if context.implement_powi_as_math_call:
            imp = context.get_function(math.pow, sig)
            res = imp(builder, args)
        else:
            fn = lc.Function.intrinsic(module, lc.INTR_POW, [y.type])
            res = builder.call(fn, (x, y))
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Complex, Complex)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``complex128_power_impl`` `numba/targets/numbers.py` lines 805-843

.. code-block:: python

    @lower_builtin("**", types.Complex, types.Complex)
    @lower_builtin(pow, types.Complex, types.Complex)
    def complex128_power_impl(context, builder, sig, args):
        [ca, cb] = args
        ty = sig.args[0]
        fty = ty.underlying_float
        a = context.make_helper(builder, ty, value=ca)
        b = context.make_helper(builder, ty, value=cb)
        c = context.make_helper(builder, ty)
        module = builder.module
        pa = a._getpointer()
        pb = b._getpointer()
        pc = c._getpointer()

        # Optimize for square because cpow looses a lot of precsiion
        TWO = context.get_constant(fty, 2)
        ZERO = context.get_constant(fty, 0)

        b_real_is_two = builder.fcmp(lc.FCMP_OEQ, b.real, TWO)
        b_imag_is_zero = builder.fcmp(lc.FCMP_OEQ, b.imag, ZERO)
        b_is_two = builder.and_(b_real_is_two, b_imag_is_zero)

        with builder.if_else(b_is_two) as (then, otherwise):
            with then:
                # Lower as multiplication
                res = complex_mul_impl(context, builder, sig, (ca, ca))
                cres = context.make_helper(builder, ty, value=res)
                c.real = cres.real
                c.imag = cres.imag

            with otherwise:
                # Lower with call to external function
                fnty = Type.function(Type.void(), [pa.type] * 3)
                cpow = module.get_or_insert_function(fnty, name="numba.math.cpow")
                builder.call(cpow, (pa, pb, pc))

        res = builder.load(pc)
        return impl_ret_untracked(context, builder, sig.return_type, res)


signature `(Array, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


signature `(Array, any)`
~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_operator_kernel.<locals>.lower_binary_operator`` `numba/targets/npyimpl.py` lines 470-473

.. code-block:: python

    def lower_binary_operator(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)


Lower Impl ``builtins.float``
-----------------------------

signature `(any)`
~~~~~~~~~~~~~~~~~

by ``int_impl`` `numba/targets/builtins.py` lines 192-199

.. code-block:: python

    @lower_builtin(int, types.Any)
    @lower_builtin(float, types.Any)
    def int_impl(context, builder, sig, args):
        [ty] = sig.args
        [val] = args
        res = context.cast(builder, val, ty, sig.return_type)
        return impl_ret_untracked(context, builder, sig.return_type, res)


Lower Impl ``cmath.cosh``
-------------------------

signature `(Complex)`
~~~~~~~~~~~~~~~~~~~~~

by ``cosh_impl`` `numba/targets/cmathimpl.py` lines 268-295

.. code-block:: python

    @lower(cmath.cosh, types.Complex)
    def cosh_impl(context, builder, sig, args):
        def cosh_impl(z):
            """cmath.cosh(z)"""
            x = z.real
            y = z.imag
            if math.isinf(x):
                if math.isnan(y):
                    # x = +inf, y = NaN => cmath.cosh(x + y j) = inf + Nan * j
                    real = abs(x)
                    imag = y
                elif y == 0.0:
                    # x = +inf, y = 0 => cmath.cosh(x + y j) = inf + 0j
                    real = abs(x)
                    imag = y
                else:
                    real = math.copysign(x, math.cos(y))
                    imag = math.copysign(x, math.sin(y))
                if x < 0.0:
                    # x = -inf => negate imaginary part of result
                    imag = -imag
                return complex(real, imag)
            return complex(math.cos(y) * math.cosh(x),
                           math.sin(y) * math.sinh(x))

        res = context.compile_internal(builder, cosh_impl, sig, args)
        return impl_ret_untracked(context, builder, sig, res)


Lower Impl ``<ufunc 'right_shift'>``
------------------------------------

signature `(any, any, Array)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc`` `numba/targets/npyimpl.py` lines 444-446

.. code-block:: python

    def binary_ufunc(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel)


signature `(any, any)`
~~~~~~~~~~~~~~~~~~~~~~

by ``register_binary_ufunc_kernel.<locals>.binary_ufunc_no_explicit_output`` `numba/targets/npyimpl.py` lines 447-450

.. code-block:: python

    def binary_ufunc_no_explicit_output(context, builder, sig, args):
        return numpy_ufunc_kernel(context, builder, sig, args, kernel,
                                  explicit_output=False)



