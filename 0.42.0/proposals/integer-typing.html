<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8.1.1. NBEP 1: Changes in integer typing &#8212; Numba 0.42.0-py3.6-macosx-10.7-x86_64.egg documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/numba-docs.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.2.1. NBEP 2: Extension points" href="extension-points.html" />
    <link rel="prev" title="8. Numba Enhancement Proposals" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/numba_blue_icon_rgb.png"></span>
          Numba</a>
        <span class="navbar-text navbar-version pull-left"><b>0.42</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">8.1.1. NBEP 1: Changes in integer typing</a><ul>
<li><a class="reference internal" href="#current-semantics">8.1.1.1. Current semantics</a></li>
<li><a class="reference internal" href="#proposal-predictable-width-conserving-typing">8.1.1.2. Proposal: predictable width-conserving typing</a></li>
<li><a class="reference internal" href="#proposal-impact">8.1.1.3. Proposal impact</a><ul>
<li><a class="reference internal" href="#semantics">8.1.1.3.1. Semantics</a></li>
<li><a class="reference internal" href="#performance">8.1.1.3.2. Performance</a></li>
<li><a class="reference internal" href="#implementation">8.1.1.3.3. Implementation</a></li>
<li><a class="reference internal" href="#limitations">8.1.1.3.4. Limitations</a></li>
<li><a class="reference internal" href="#long-term-horizon">8.1.1.3.5. Long-term horizon</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="index.html" title="Previous Chapter: 8. Numba Enhancement Proposals"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 8. Numba Enha...</span>
    </a>
  </li>
  <li>
    <a href="extension-points.html" title="Next Chapter: 8.2.1. NBEP 2: Extension points"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">8.2.1. NBEP 2... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/proposals/integer-typing.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="nbep-1-changes-in-integer-typing">
<span id="nbep-1"></span><h1>8.1.1. NBEP 1: Changes in integer typing<a class="headerlink" href="#nbep-1-changes-in-integer-typing" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">July 2015</td>
</tr>
<tr class="field-odd field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
</tbody>
</table>
<div class="section" id="current-semantics">
<h2>8.1.1.1. Current semantics<a class="headerlink" href="#current-semantics" title="Permalink to this headline">¶</a></h2>
<p>Type inference of integers in Numba currently has some subtleties
and some corner cases.  The simple case is when some variable has an obvious
Numba type (for example because it is the result of a constructor call to a
Numpy scalar type such as <code class="docutils literal notranslate"><span class="pre">np.int64</span></code>). That case suffers no ambiguity.</p>
<p>The less simple case is when a variable doesn’t bear such explicit
information.  This can happen because it is inferred from a built-in Python
<code class="docutils literal notranslate"><span class="pre">int</span></code> value, or from an arithmetic operation between two integers, or
other cases yet.  Then Numba has a number of rules to infer the resulting
Numba type, especially its signedness and bitwidth.</p>
<p>Currently, the generic case could be summarized as: <em>start small,
grow bigger as required</em>.  Concretely:</p>
<ol class="arabic simple">
<li>Each constant or pseudo-constant is inferred using the <em>smallest signed
integer type</em> that can correctly represent it (or, possibly, <code class="docutils literal notranslate"><span class="pre">uint64</span></code>
for positive integers between <code class="docutils literal notranslate"><span class="pre">2**63</span></code> and <code class="docutils literal notranslate"><span class="pre">2**64</span> <span class="pre">-</span> <span class="pre">1</span></code>).</li>
<li>The result of an operation is typed so as to ensure safe representation
in the face of overflow and other magnitude increases (for example,
<code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">+</span> <span class="pre">int32</span></code> would be typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>).</li>
<li>As an exception, a Python <code class="docutils literal notranslate"><span class="pre">int</span></code> used as function argument is always
typed <code class="docutils literal notranslate"><span class="pre">intp</span></code>, a pointer-size integer.  This is to avoid the proliferation
of compiled specializations, as otherwise various integer bitwidths
in input arguments may produce multiple signatures.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The second rule above (the “respect magnitude increases” rule)
reproduces Numpy’s behaviour with arithmetic on scalar values.
Numba, however, has different implementation and performance constraints
than Numpy scalars.</p>
<p class="last">It is worth nothing, by the way, that Numpy arrays do not implement
said rule (i.e. <code class="docutils literal notranslate"><span class="pre">array(int32)</span> <span class="pre">+</span> <span class="pre">array(int32)</span></code> is typed <code class="docutils literal notranslate"><span class="pre">array(int32)</span></code>,
not <code class="docutils literal notranslate"><span class="pre">array(int64)</span></code>).  Probably because this makes performance more
controllable.</p>
</div>
<p>This has several non-obvious side-effects:</p>
<ol class="arabic">
<li><p class="first">It is difficult to predict the precise type of a value inside a function,
after several operations.  The basic operands in an expression tree
may for example be <code class="docutils literal notranslate"><span class="pre">int8</span></code> but the end result may be <code class="docutils literal notranslate"><span class="pre">int64</span></code>.  Whether
this is desirable or not is an open question; it is good for correctness,
but potentially bad for performance.</p>
</li>
<li><p class="first">In trying to follow the correctness over predictability rule, some values
can actually leave the integer realm.  For example, <code class="docutils literal notranslate"><span class="pre">int64</span> <span class="pre">+</span> <span class="pre">uint64</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">float64</span></code> in order to avoid magnitude losses (but incidentally
will lose precision on large integer values…), again following Numpy’s
semantics for scalars.  This is usually not intended by the user.</p>
</li>
<li><p class="first">More complicated scenarios can produce unexpected errors at the type unification
stage.  An example is at <a class="reference external" href="https://github.com/numba/numba/issues/1299">Github issue 1299</a>,
the gist of which is reproduced here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</pre></div>
</div>
<p>At the time of this writing, this fails compiling, on a 64-bit system,
with the error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>numba.errors.TypingError: Failed at nopython (nopython frontend)
Can&#39;t unify types of variable &#39;$48.4&#39;: $48.4 := {array(int32, 1d, C), array(int64, 1d, C)}
</pre></div>
</div>
<p>People expert with Numba’s type unification system can understand why.
But the user is caught in mystery.</p>
</li>
</ol>
</div>
<div class="section" id="proposal-predictable-width-conserving-typing">
<h2>8.1.1.2. Proposal: predictable width-conserving typing<a class="headerlink" href="#proposal-predictable-width-conserving-typing" title="Permalink to this headline">¶</a></h2>
<p>We propose to turn the current typing philosophy on its head.  Instead
of “<em>start small and grow as required</em>”, we propose “<em>start big and keep
the width unchanged</em>”.</p>
<p>Concretely:</p>
<ol class="arabic simple">
<li>The typing of Python <code class="docutils literal notranslate"><span class="pre">int</span></code> values used as function arguments doesn’t
change, as it works satisfyingly and doesn’t surprise the user.</li>
<li>The typing of integer <em>constants</em> (and pseudo-constants) changes to match
the typing of integer arguments.  That is, every non-explicitly typed
integer constant is typed <code class="docutils literal notranslate"><span class="pre">intp</span></code>, the pointer-sized integer; except for
the rare cases where <code class="docutils literal notranslate"><span class="pre">int64</span></code> (on 32-bit systems) or <code class="docutils literal notranslate"><span class="pre">uint64</span></code> is
required.</li>
<li>Operations on integers promote bitwidth to <code class="docutils literal notranslate"><span class="pre">intp</span></code>, if smaller, otherwise
they don’t promote.  For example, on a 32-bit machine, <code class="docutils literal notranslate"><span class="pre">int8</span> <span class="pre">+</span> <span class="pre">int8</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">int32</span></code>, as is <code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">+</span> <span class="pre">int32</span></code>.  However, <code class="docutils literal notranslate"><span class="pre">int64</span> <span class="pre">+</span> <span class="pre">int64</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>.</li>
<li>Furthermore, mixed operations between signed and unsigned fall back to
signed, while following the same bitwidth rule.  For example, on a
32-bit machine, <code class="docutils literal notranslate"><span class="pre">int8</span> <span class="pre">+</span> <span class="pre">uint16</span></code> is typed <code class="docutils literal notranslate"><span class="pre">int32</span></code>, as is
<code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">+</span> <span class="pre">int32</span></code>.</li>
</ol>
</div>
<div class="section" id="proposal-impact">
<h2>8.1.1.3. Proposal impact<a class="headerlink" href="#proposal-impact" title="Permalink to this headline">¶</a></h2>
<div class="section" id="semantics">
<h3>8.1.1.3.1. Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h3>
<p>With this proposal, the semantics become clearer.  Regardless of whether
the arguments and constants of a function were explicitly typed or not,
the results of various expressions at any point in the function have
easily predictable types.</p>
<p>When using built-in Python <code class="docutils literal notranslate"><span class="pre">int</span></code>, the user gets acceptable magnitude
(32 or 64 bits depending on the system’s bitness), and the type remains
the same accross all computations.</p>
<p>When explicitly using smaller bitwidths, intermediate results don’t
suffer from magnitude loss, since their bitwidth is promoted to <code class="docutils literal notranslate"><span class="pre">intp</span></code>.</p>
<p>There is also less potential for annoyances with the type unification
system as demonstrated above.  The user would have to force several
different types to be faced with such an error.</p>
<p>One potential cause for concern is the discrepancy with Numpy’s scalar
semantics; but at the same time this brings Numba scalar semantics closer
to array semantics (both Numba’s and Numpy’s), which seems a desirable
outcome as well.</p>
<p>It is worth pointing out that some sources of integer numbers, such
as the <code class="docutils literal notranslate"><span class="pre">range()</span></code> built-in, always yield 32-bit integers or larger.
This proposal could be an opportunity to standardize them on <code class="docutils literal notranslate"><span class="pre">intp</span></code>.</p>
</div>
<div class="section" id="performance">
<h3>8.1.1.3.2. Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>Except in trivial cases, it seems unlikely that the current “best fit”
behaviour for integer constants really brings a performance benefit.  After
all, most integers in Numba code would either be stored in arrays (with
well-known types, chosen by the user) or be used as indices, where a <code class="docutils literal notranslate"><span class="pre">int8</span></code>
is highly unlikely to fare better than a <code class="docutils literal notranslate"><span class="pre">intp</span></code> (actually, it may be worse,
if LLVM isn’t able to optimize away the required sign-extension).</p>
<p>As a side note, the default use of <code class="docutils literal notranslate"><span class="pre">intp</span></code> rather than <code class="docutils literal notranslate"><span class="pre">int64</span></code>
ensures that 32-bit systems won’t suffer from poor arithmetic performance.</p>
</div>
<div class="section" id="implementation">
<h3>8.1.1.3.3. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>Optimistically, this proposal may simplify some Numba internals a bit.
Or, at least, it doesn’t threaten to make them significantly more complicated.</p>
</div>
<div class="section" id="limitations">
<h3>8.1.1.3.4. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<p>This proposal doesn’t really solve the combination of signed and unsigned
integers.  It is geared mostly at solving the bitwidth issues, which are
a somewhat common cause of pain for users.  Unsigned integers are in
practice very uncommon in Numba-compiled code, except when explicitly
asked for, and therefore much less of a pain point.</p>
<p>On the bitwidth front, 32-bit systems could still show discrepancies based
on the values of constants: if a constant is too large to fit in 32 bits,
it is typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>, which propagates through other computations.
This would be a reminiscence of the current behaviour, but rarer and much
more controlled still.</p>
</div>
<div class="section" id="long-term-horizon">
<h3>8.1.1.3.5. Long-term horizon<a class="headerlink" href="#long-term-horizon" title="Permalink to this headline">¶</a></h3>
<p>While we believe this proposal makes Numba’s behaviour more regular and more
predictable, it also pulls it further from general compatibility with pure
Python semantics, where users can assume arbitrary-precision integers without
any truncation issues.</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Anaconda, Inc..<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>