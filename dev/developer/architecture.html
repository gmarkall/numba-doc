<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>6.2. Numba Architecture &mdash; Numba 0.23.0+38.gdde50d8-py2.7-linux-x86_64.egg documentation</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    
<link rel="stylesheet" href="../_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/bootstrap.min.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/font-awesome.min.css">
<!--[if IE 7]>
<link rel="stylesheet" href="../_static/css/font-awesome-ie7.min.css">
<![endif]-->
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
}
</style>
<link rel="stylesheet" href="../_static/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/bootstrap-responsive.min.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    '../',
            VERSION:     '0.23.0+38.gdde50d8-py2.7-linux-x86_64.egg',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
<script type="text/javascript" src="../_static/js/jquery.min.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript" src="../_static/js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    $('.show-sidebar').click(function(e) {
       e.preventDefault();
       if ($(".show-sidebar").html() == "Open Table Of Contents") {
          $('.for-mobile').removeClass('hidden-phone');
          $(".show-sidebar").html("Close Table Of Contents");
       } else {
          $(".show-sidebar").html("Open Table Of Contents");
       }
    });
  });
</script>
    <link rel="top" title="Numba 0.23.0+38.gdde50d8-py2.7-linux-x86_64.egg documentation" href="../index.html" />
    <link rel="up" title="6. Developer Manual" href="index.html" />
    <link rel="next" title="6.3. Extending the Numba frontend" href="extending-frontend.html" />
    <link rel="prev" title="6.1. Contributing to Numba" href="contributing.html" /> 
  </head>
  <body>
    <div class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Numba 0.23.0+38.gdde50d8-py2.7-linux-x86_64.egg documentation</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right">
              
                <li>
                <a href="../genindex.html" title="General Index" accesskey="I">index</a>
                </li>
                <li>
                <a href="extending-frontend.html" title="6.3. Extending the Numba frontend" accesskey="N">next</a>
                </li>
                <li>
                <a href="contributing.html" title="6.1. Contributing to Numba" accesskey="P">previous</a>
                </li>
                <li>
                <a href="index.html" accesskey="U">6. Developer Manual</a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container-fluid">


      
      <div class="row-fluid hidden-desktop hidden-tablet">
      
<div class="span3 ">
  <a class="visible-phone btn btn-small show-sidebar" data-toggle="collapse" data-target=".for-mobile">Open Table Of Contents</a>
  <div class="for-mobile sidebar hidden-phone">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.2. Numba Architecture</a><ul>
<li><a class="reference internal" href="#introduction">6.2.1. Introduction</a></li>
<li><a class="reference internal" href="#contexts">6.2.2. Contexts</a></li>
<li><a class="reference internal" href="#compiler-stages">6.2.3. Compiler Stages</a><ul>
<li><a class="reference internal" href="#stage-1-analyze-bytecode">6.2.3.1. Stage 1: Analyze Bytecode</a></li>
<li><a class="reference internal" href="#stage-2-generate-the-numba-ir">6.2.3.2. Stage 2: Generate the Numba IR</a></li>
<li><a class="reference internal" href="#stage-3-macro-expansion">6.2.3.3. Stage 3: Macro expansion</a></li>
<li><a class="reference internal" href="#stage-4-infer-types">6.2.3.4. Stage 4: Infer Types</a></li>
<li><a class="reference internal" href="#stage-5-rewrite-typed-ir">6.2.3.5. Stage 5: Rewrite Typed IR</a></li>
<li><a class="reference internal" href="#stage-6a-generate-no-python-llvm-ir">6.2.3.6. Stage 6a: Generate No-Python LLVM IR</a></li>
<li><a class="reference internal" href="#stage-6b-generate-object-mode-llvm-ir">6.2.3.7. Stage 6b: Generate Object Mode LLVM IR</a></li>
<li><a class="reference internal" href="#stage-7-compile-llvm-ir-to-machine-code">6.2.3.8. Stage 7: Compile LLVM IR to Machine Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contributing.html"
                        title="previous chapter">6.1. Contributing to Numba</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="extending-frontend.html"
                        title="next chapter">6.3. Extending the Numba frontend</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/developer/architecture.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="../search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div>
      </div>
      

      <!-- row -->
      <div class="row-fluid">
         
<div class="span3 visible-desktop visible-tablet">
  <div class=" sidebar hidden-phone">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.2. Numba Architecture</a><ul>
<li><a class="reference internal" href="#introduction">6.2.1. Introduction</a></li>
<li><a class="reference internal" href="#contexts">6.2.2. Contexts</a></li>
<li><a class="reference internal" href="#compiler-stages">6.2.3. Compiler Stages</a><ul>
<li><a class="reference internal" href="#stage-1-analyze-bytecode">6.2.3.1. Stage 1: Analyze Bytecode</a></li>
<li><a class="reference internal" href="#stage-2-generate-the-numba-ir">6.2.3.2. Stage 2: Generate the Numba IR</a></li>
<li><a class="reference internal" href="#stage-3-macro-expansion">6.2.3.3. Stage 3: Macro expansion</a></li>
<li><a class="reference internal" href="#stage-4-infer-types">6.2.3.4. Stage 4: Infer Types</a></li>
<li><a class="reference internal" href="#stage-5-rewrite-typed-ir">6.2.3.5. Stage 5: Rewrite Typed IR</a></li>
<li><a class="reference internal" href="#stage-6a-generate-no-python-llvm-ir">6.2.3.6. Stage 6a: Generate No-Python LLVM IR</a></li>
<li><a class="reference internal" href="#stage-6b-generate-object-mode-llvm-ir">6.2.3.7. Stage 6b: Generate Object Mode LLVM IR</a></li>
<li><a class="reference internal" href="#stage-7-compile-llvm-ir-to-machine-code">6.2.3.8. Stage 7: Compile LLVM IR to Machine Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contributing.html"
                        title="previous chapter">6.1. Contributing to Numba</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="extending-frontend.html"
                        title="next chapter">6.3. Extending the Numba frontend</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/developer/architecture.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="../search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        

        <div class="span9">
          <div class="document">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="numba-architecture">
<span id="architecture"></span><h1>6.2. Numba Architecture<a class="headerlink" href="#numba-architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>6.2.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Numba is a compiler for Python bytecode with optional type-specialization.</p>
<p>Suppose you type a function like this into the standard Python interpreter
(henceforward referred to as &#8220;CPython&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>The interpreter will immediately parse the function and convert it into a
bytecode representation that describes how the CPython interpreter should
execute the function at a low level.  For the example above, it looks
something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">2           0 LOAD_FAST                0 (a)</span>
<span class="go">            3 LOAD_FAST                1 (b)</span>
<span class="go">            6 BINARY_ADD</span>
<span class="go">            7 RETURN_VALUE</span>
</pre></div>
</div>
<p>CPython uses a stack-based interpreter (much like an HP calculator), so the
code first pushes two local variables onto the stack.  The <code class="docutils literal"><span class="pre">BINARY_ADD</span></code>
opcode pops the top two arguments off the stack and makes a Python C API
function call that is equivalent to calling <code class="docutils literal"><span class="pre">a.__add__(b)</span></code>.  The result is
then pushed onto the top of the interpreter stack.  Finally, the
<code class="docutils literal"><span class="pre">RETURN_VALUE</span></code> opcode returns value on the top of the stack as the result of
the function call.</p>
<p>Numba can take this bytecode and compile it to machine code that performs the
same operations as the CPython interpreter, treating <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> as
generic Python objects.  The full semantics of Python are preserved, and the
compiled function can be used with any kind of objects that have the add
operator defined.  When a Numba function is compiled this way, we say that it
has been compiled in <a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a>, because the code still manipulates
Python objects.</p>
<p>Numba code compiled in object mode is not much faster than executing the
original Python function in the CPython interpreter.  However, if we
specialize the function to only run with certain data types, Numba can
generate much shorter and more efficient code that manipulates the data
natively without any calls into the Python C API.  When code has been compiled
for specific data types so that the function body no longer relies on the
Python runtime, we say the function has been compiled in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.
Numeric code compiled in nopython mode can be hundreds of times faster
than the original Python.</p>
</div>
<div class="section" id="contexts">
<h2>6.2.2. Contexts<a class="headerlink" href="#contexts" title="Permalink to this headline">¶</a></h2>
<p>Numba is quite flexible, allowing it to generate code for different hardware
architectures like CPUs and GPUs (just CUDA, for now).  In order to support
these different applications, Numba uses a <em>typing context</em> and a <em>target
context</em>.</p>
<p>A typing context is used in the compiler frontend to perform type inference on
values in the function.  Similar typing contexts could be used for many
architectures because for nearly all cases, typing inference is hardware-independent.
However, Numba currently has a different typing context for each target.</p>
<p>A target context is used to generate the specific instruction sequence
required to operate on the Numba types identified during type inference.
Target contexts are architecture specific.  For example, Numba has a &#8220;cpu&#8221; and
a &#8220;gpu&#8221; context, and NumbaPro adds a &#8220;parallel&#8221; context which produces
multithreaded CPU code.</p>
</div>
<div class="section" id="compiler-stages">
<h2>6.2.3. Compiler Stages<a class="headerlink" href="#compiler-stages" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">&#64;jit</span></code> decorator in Numba ultimately calls
<code class="docutils literal"><span class="pre">numba.compiler.compile_extra()</span></code> which compiles the Python function in a
multi-stage process, described below.</p>
<div class="section" id="stage-1-analyze-bytecode">
<h3>6.2.3.1. Stage 1: Analyze Bytecode<a class="headerlink" href="#stage-1-analyze-bytecode" title="Permalink to this headline">¶</a></h3>
<p>At the start of compilation, the function bytecode is passed to an instance of
the Numba interpreter (<code class="docutils literal"><span class="pre">numba.interpreter</span></code>).  The interpreter object
analyzes the bytecode to find the control flow graph (<code class="docutils literal"><span class="pre">numba.controlflow</span></code>).
The control flow graph describes the ways that execution can move from one
block to the next inside the function as a result of loops and branches.</p>
<p>The data flow analysis (<code class="docutils literal"><span class="pre">numba.dataflow</span></code>) takes the control flow graph and
traces how values get pushed and popped off the Python interpreter stack for
different code paths.  This is important to understand the lifetimes of
variables on the stack, which are needed in Stage 2.</p>
<p>If you set the environment variable <code class="docutils literal"><span class="pre">NUMBA_DUMP_CFG</span></code> to 1, Numba will dump
the results of the control flow graph analysis to the screen.  Our <code class="docutils literal"><span class="pre">add()</span></code>
example is pretty boring, since there is only one statement block:</p>
<div class="highlight-python"><div class="highlight"><pre>CFG adjacency lists:
{0: []}
CFG dominators:
{0: set([0])}
CFG post-dominators:
{0: set([0])}
CFG back edges: []
CFG loops:
{}
CFG node-to-loops:
{0: []}
</pre></div>
</div>
<p>A function with more complex flow control will have a more interesting
control flow graph.  This function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">doloops</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">acc</span>
</pre></div>
</div>
<p>compiles to this bytecode:</p>
<div class="highlight-python"><div class="highlight"><pre> 9           0 LOAD_CONST               1 (0)
             3 STORE_FAST               1 (acc)

10           6 SETUP_LOOP              46 (to 55)
             9 LOAD_GLOBAL              0 (range)
            12 LOAD_FAST                0 (n)
            15 CALL_FUNCTION            1
            18 GET_ITER
       &gt;&gt;   19 FOR_ITER                32 (to 54)
            22 STORE_FAST               2 (i)

11          25 LOAD_FAST                1 (acc)
            28 LOAD_CONST               2 (1)
            31 INPLACE_ADD
            32 STORE_FAST               1 (acc)

12          35 LOAD_FAST                0 (n)
            38 LOAD_CONST               3 (10)
            41 COMPARE_OP               2 (==)
            44 POP_JUMP_IF_FALSE       19

13          47 BREAK_LOOP
            48 JUMP_ABSOLUTE           19
            51 JUMP_ABSOLUTE           19
       &gt;&gt;   54 POP_BLOCK

14     &gt;&gt;   55 LOAD_FAST                1 (acc)
            58 RETURN_VALUE
</pre></div>
</div>
<p>The corresponding CFG for this bytecode is:</p>
<div class="highlight-python"><div class="highlight"><pre>CFG adjacency lists:
{0: [6], 6: [19], 19: [54, 22], 22: [19, 47], 47: [55], 54: [55], 55: []}
CFG dominators:
{0: set([0]),
 6: set([0, 6]),
 19: set([0, 6, 19]),
 22: set([0, 6, 19, 22]),
 47: set([0, 6, 19, 22, 47]),
 54: set([0, 6, 19, 54]),
 55: set([0, 6, 19, 55])}
CFG post-dominators:
{0: set([0, 6, 19, 55]),
 6: set([6, 19, 55]),
 19: set([19, 55]),
 22: set([22, 55]),
 47: set([47, 55]),
 54: set([54, 55]),
 55: set([55])}
CFG back edges: [(22, 19)]
CFG loops:
{19: Loop(entries=set([6]), exits=set([54, 47]), header=19, body=set([19, 22]))}
CFG node-to-loops:
{0: [], 6: [], 19: [19], 22: [19], 47: [], 54: [], 55: []}
</pre></div>
</div>
<p>The numbers in the CFG refer to the bytecode offsets shown just to the left
of the opcode names above.</p>
</div>
<div class="section" id="stage-2-generate-the-numba-ir">
<span id="arch-generate-numba-ir"></span><h3>6.2.3.2. Stage 2: Generate the Numba IR<a class="headerlink" href="#stage-2-generate-the-numba-ir" title="Permalink to this headline">¶</a></h3>
<p>Once the control flow and data analyses are complete, the Numba interpreter
can step through the bytecode and translate it into an Numba-internal
intermediate representation.  This translation process changes the function
from a stack machine representation (used by the Python interpreter) to a
register machine representation (used by LLVM).</p>
<p>Although the IR is stored in memory as a tree of objects, it can be serialized
to a string for debugging.  If you set the environment variable
<code class="docutils literal"><span class="pre">NUMBA_DUMP_IR</span></code> equal to 1, the Numba IR will be dumped to the screen.  For
the <code class="docutils literal"><span class="pre">add()</span></code> function described above, the Numba IR looks like:</p>
<div class="highlight-python"><div class="highlight"><pre>label 0:
    a = arg(0, name=a)                       [&#39;a&#39;]
    b = arg(1, name=b)                       [&#39;b&#39;]
    $0.3 = a + b                             [&#39;$0.3&#39;, &#39;a&#39;, &#39;b&#39;]
    del b                                    []
    del a                                    []
    $0.4 = cast(value=$0.3)                  [&#39;$0.3&#39;, &#39;$0.4&#39;]
    del $0.3                                 []
    return $0.4                              [&#39;$0.4&#39;]
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">del</span></code> instructions are produced by live variable analysis.  Those
instructions ensure references are not leaked in <a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a>,
where each variable contains an owned reference to a PyObject.  They are
no-ops in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.</p>
</div>
<div class="section" id="stage-3-macro-expansion">
<h3>6.2.3.3. Stage 3: Macro expansion<a class="headerlink" href="#stage-3-macro-expansion" title="Permalink to this headline">¶</a></h3>
<p>Now that the function has been translated into the Numba IR, macro expansion can
be performed. Macro expansion converts specific attributes that are known to
Numba into IR nodes representing function calls. This is initiated in the
<code class="docutils literal"><span class="pre">numba.compiler.translate_stage</span></code> function, and is implemented in
<code class="docutils literal"><span class="pre">numba.macro</span></code>.</p>
<p>Examples of attributes that are macro-expanded include the CUDA instrinsics for
grid, block and thread dimensions and indices. For example, the assignment to
<code class="docutils literal"><span class="pre">tx</span></code> in the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cuda.jit</span><span class="p">(</span><span class="n">argtypes</span><span class="o">=</span><span class="p">[</span><span class="n">f4</span><span class="p">[:]])</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>has the following representation after translation to Numba IR:</p>
<div class="highlight-python"><div class="highlight"><pre>$0.1 = global(cuda: &lt;module &#39;numba.cuda&#39; from &#39;...&#39;&gt;) [&#39;$0.1&#39;]
$0.2 = getattr(value=$0.1, attr=threadIdx) [&#39;$0.1&#39;, &#39;$0.2&#39;]
del $0.1                                 []
$0.3 = getattr(value=$0.2, attr=x)       [&#39;$0.2&#39;, &#39;$0.3&#39;]
del $0.2                                 []
tx = $0.3                                [&#39;$0.3&#39;, &#39;tx&#39;]
</pre></div>
</div>
<p>After macro expansion, the <code class="docutils literal"><span class="pre">$0.3</span> <span class="pre">=</span> <span class="pre">getattr(value=$0.2,</span> <span class="pre">attr=x)</span></code> IR node is
translated into:</p>
<div class="highlight-python"><div class="highlight"><pre>$0.3 = call tid.x(, )                    [&#39;$0.3&#39;]
</pre></div>
</div>
<p>which represents an instance of the <code class="docutils literal"><span class="pre">Intrinsic</span></code> IR node for calling the
<code class="docutils literal"><span class="pre">tid.x</span></code> intrinsic function.</p>
</div>
<div class="section" id="stage-4-infer-types">
<span id="arch-type-inference"></span><h3>6.2.3.4. Stage 4: Infer Types<a class="headerlink" href="#stage-4-infer-types" title="Permalink to this headline">¶</a></h3>
<p>Now that the Numba IR has been generated and macro-expanded, type analysis
can be performed.  The types of the function arguments can be taken either
from the explicit function signature given in the <code class="docutils literal"><span class="pre">&#64;jit</span></code> decorator
(such as <code class="docutils literal"><span class="pre">&#64;jit('float64(float64,</span> <span class="pre">float64)')</span></code>), or they can be taken from
the types of the actual function arguments if compilation is happening
when the function is first called.</p>
<p>The type inference engine is found in <code class="docutils literal"><span class="pre">numba.typeinfer</span></code>.  Its job is to
assign a type to every intermediate variable in the Numba IR.  The result of
this pass can be seen by setting the <span class="target" id="index-0"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DUMP_ANNOTATION"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DUMP_ANNOTATION</span></code></a>
environment variable to 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">-----------------------------------</span><span class="n">ANNOTATION</span><span class="o">-----------------------------------</span>
<span class="c"># File: archex.py</span>
<span class="c"># --- LINE 4 ---</span>

<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># --- LINE 5 ---</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>

    <span class="c"># --- LINE 6 ---</span>
    <span class="c"># label 0</span>
    <span class="c">#   a = arg(0, name=a)  :: int64</span>
    <span class="c">#   b = arg(1, name=b)  :: int64</span>
    <span class="c">#   $0.3 = a + b  :: int64</span>
    <span class="c">#   del b</span>
    <span class="c">#   del a</span>
    <span class="c">#   $0.4 = cast(value=$0.3)  :: int64</span>
    <span class="c">#   del $0.3</span>
    <span class="c">#   return $0.4</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>If type inference fails to find a consistent type assignment for all the
intermediate variables, it will label every variable as type <code class="docutils literal"><span class="pre">pyobject</span></code> and
fall back to object mode.  Type inference can fail when unsupported Python
types, language features, or functions are used in the function body.</p>
</div>
<div class="section" id="stage-5-rewrite-typed-ir">
<span id="rewrite-typed-ir"></span><h3>6.2.3.5. Stage 5: Rewrite Typed IR<a class="headerlink" href="#stage-5-rewrite-typed-ir" title="Permalink to this headline">¶</a></h3>
<p>Numba implements a user-extensible rewriting pass that reads and
possibly rewrites Numba IR.  This pass&#8217;s purpose is to perform any
high-level optimizations that still require, or could at least benefit
from, Numba IR type information.</p>
<p>One example of a problem domain that isn&#8217;t as easily optimized once
lowered is the domain of multidimensional array operations.  When
Numba lowers an array operation, Numba treats the operation like a
full ufunc kernel.  During lowering a single array operation, Numba
generates an inline broadcasting loop that creates a new result array.
Then Numba generates an application loop that applies the operator
over the array inputs.  Recognizing and rewriting these loops once
they are lowered into LLVM is hard, if not impossible.</p>
<p>An example pair of optimizations in the domain of array operators is
loop fusion and shortcut deforestation.  When the optimizer
recognizes that the output of one array operator is being fed into
another array operator, and only to that array operator, it can fuse
the two loops into a single loop.  The optimizer can further eliminate
the temporary array allocated for the initial operation by directly
feeding the result of the first operation into the second, skipping
the store and load to the intermediate array.  This elimination is
known as shortcut deforestation.  Numba currently uses the rewrite
pass to implement these array optimizations.  For more information,
please consult the &#8220;<a class="reference internal" href="rewrites.html#case-study-array-expressions"><span>Case study: Array Expressions</span></a>&#8221; subsection,
later in this document.</p>
<p>One can see the result of rewriting by setting the
<span class="target" id="index-1"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DUMP_IR"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DUMP_IR</span></code></a> environment variable to a non-zero value (such
as 1).  The following example shows the output of the rewrite pass as
it recognizes an array expression consisting of a multiply and add,
and outputs a fused kernel as a special operator, <code class="xref py py-func docutils literal"><span class="pre">arrayexpr()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>______________________________________________________________________
REWRITING:
a0 = arg(0, name=a0)                     [&#39;a0&#39;]
a1 = arg(1, name=a1)                     [&#39;a1&#39;]
a2 = arg(2, name=a2)                     [&#39;a2&#39;]
$0.3 = a0 * a1                           [&#39;$0.3&#39;, &#39;a0&#39;, &#39;a1&#39;]
del a1                                   []
del a0                                   []
$0.5 = $0.3 + a2                         [&#39;$0.3&#39;, &#39;$0.5&#39;, &#39;a2&#39;]
del a2                                   []
del $0.3                                 []
$0.6 = cast(value=$0.5)                  [&#39;$0.5&#39;, &#39;$0.6&#39;]
del $0.5                                 []
return $0.6                              [&#39;$0.6&#39;]
____________________________________________________________
a0 = arg(0, name=a0)                     [&#39;a0&#39;]
a1 = arg(1, name=a1)                     [&#39;a1&#39;]
a2 = arg(2, name=a2)                     [&#39;a2&#39;]
$0.5 = arrayexpr(ty=array(float64, 1d, C), expr=(&#39;+&#39;, [(&#39;*&#39;, [Var(a0, test.py (14)), Var(a1, test.py (14))]), Var(a2, test.py (14))])) [&#39;$0.5&#39;, &#39;a0&#39;, &#39;a1&#39;, &#39;a2&#39;]
del a0                                   []
del a1                                   []
del a2                                   []
$0.6 = cast(value=$0.5)                  [&#39;$0.5&#39;, &#39;$0.6&#39;]
del $0.5                                 []
return $0.6                              [&#39;$0.6&#39;]
______________________________________________________________________
</pre></div>
</div>
<p>Following this rewrite, Numba lowers the array expression into a new
ufunc-like function that is inlined into a single loop that only
allocates a single result array.</p>
</div>
<div class="section" id="stage-6a-generate-no-python-llvm-ir">
<h3>6.2.3.6. Stage 6a: Generate No-Python LLVM IR<a class="headerlink" href="#stage-6a-generate-no-python-llvm-ir" title="Permalink to this headline">¶</a></h3>
<p>If type inference succeeds in finding a Numba type for every intermediate
variable, then Numba can (potentially) generate specialized native code.  This
process is called <em>lowering</em>.  The Numba IR tree is translated into LLVM IR by
using helper classes from <a class="reference external" href="https://github.com/numba/llvmlite">llvmlite</a>.
The  machine-generated LLVM IR can seem unnecessarily verbose, but the LLVM
toolchain is able to optimize it quite easily into compact, efficient code.</p>
<p>The basic lowering algorithm is generic, but the specifics of how particular
Numba IR nodes are translated to LLVM instructions is handled by the
target context selected for compilation.  The default target context is
the &#8220;cpu&#8221; context, defined in <code class="docutils literal"><span class="pre">numba.targets.cpu</span></code>.</p>
<p>The LLVM IR can be displayed by setting the <span class="target" id="index-2"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DUMP_LLVM"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DUMP_LLVM</span></code></a> environment
variable to 1.  For the &#8220;cpu&#8221; context, our <code class="docutils literal"><span class="pre">add()</span></code> example would look like:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="k">define</span> <span class="k">i32</span> <span class="vg">@&quot;__main__.add$1.int64.int64&quot;</span><span class="p">(</span><span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;retptr&quot;</span><span class="p">,</span>
                                         <span class="p">{</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span><span class="p">}**</span> <span class="nv">%&quot;excinfo&quot;</span><span class="p">,</span>
                                         <span class="k">i8</span><span class="p">*</span> <span class="nv">%&quot;env&quot;</span><span class="p">,</span>
                                         <span class="k">i64</span> <span class="nv">%&quot;arg.a&quot;</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%&quot;arg.b&quot;</span><span class="p">)</span>
<span class="p">{</span>
   <span class="nl">entry:</span>
     <span class="nv">%&quot;a&quot;</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
     <span class="nv">%&quot;b&quot;</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
     <span class="nv">%&quot;$0.3&quot;</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
     <span class="nv">%&quot;$0.4&quot;</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
     <span class="k">br</span> <span class="kt">label</span> <span class="nv">%&quot;B0&quot;</span>
   <span class="nl">B0:</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%&quot;arg.a&quot;</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;a&quot;</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%&quot;arg.b&quot;</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;b&quot;</span>
     <span class="nv">%&quot;.8&quot;</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;a&quot;</span>
     <span class="nv">%&quot;.9&quot;</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;b&quot;</span>
     <span class="nv">%&quot;.10&quot;</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%&quot;.8&quot;</span><span class="p">,</span> <span class="nv">%&quot;.9&quot;</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%&quot;.10&quot;</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.3&quot;</span>
     <span class="nv">%&quot;.12&quot;</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.3&quot;</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%&quot;.12&quot;</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.4&quot;</span>
     <span class="nv">%&quot;.14&quot;</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.4&quot;</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%&quot;.14&quot;</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;retptr&quot;</span>
     <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The post-optimization LLVM IR can be output by setting
<span class="target" id="index-3"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DUMP_OPTIMIZED"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DUMP_OPTIMIZED</span></code></a> to 1.  The optimizer shortens the code
generated above quite significantly:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="k">define</span> <span class="k">i32</span> <span class="vg">@&quot;__main__.add$1.int64.int64&quot;</span><span class="p">(</span><span class="k">i64</span><span class="p">*</span> <span class="k">nocapture</span> <span class="nv">%retptr</span><span class="p">,</span>
                                         <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}**</span> <span class="k">nocapture</span> <span class="k">readnone</span> <span class="nv">%excinfo</span><span class="p">,</span>
                                         <span class="k">i8</span><span class="p">*</span> <span class="k">nocapture</span> <span class="k">readnone</span> <span class="nv">%env</span><span class="p">,</span>
                                         <span class="k">i64</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%arg.b</span><span class="p">)</span>
<span class="p">{</span>
   <span class="nl">entry:</span>
     <span class="nv">%.10</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%arg.b</span><span class="p">,</span> <span class="nv">%arg.a</span>
     <span class="k">store</span> <span class="k">i64</span> <span class="nv">%.10</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%retptr</span><span class="p">,</span> <span class="k">align</span> <span class="m">8</span>
     <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stage-6b-generate-object-mode-llvm-ir">
<h3>6.2.3.7. Stage 6b: Generate Object Mode LLVM IR<a class="headerlink" href="#stage-6b-generate-object-mode-llvm-ir" title="Permalink to this headline">¶</a></h3>
<p>If type inference fails to find Numba types for all values inside a function,
the function will be compiled in object mode.  The generated LLVM will be
significantly longer, as the compiled code will need to make calls to the
<a class="reference external" href="https://docs.python.org/3/c-api/">Python C API</a> to perform basically all
operations.  The optimized LLVM for our example <code class="docutils literal"><span class="pre">add()</span></code> function is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="vg">@PyExc_SystemError</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i8</span>
<span class="vg">@&quot;.const.Numba_internal_error:_object_mode_function_called_without_an_environment&quot;</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">73</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;Numba internal error: object mode function called without an environment\00&quot;</span>
<span class="vg">@&quot;.const.name_&#39;a&#39;_is_not_defined&quot;</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">24</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;name &#39;a&#39; is not defined\00&quot;</span>
<span class="vg">@PyExc_NameError</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i8</span>
<span class="vg">@&quot;.const.name_&#39;b&#39;_is_not_defined&quot;</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">24</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;name &#39;b&#39; is not defined\00&quot;</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@&quot;__main__.add$1.pyobject.pyobject&quot;</span><span class="p">(</span><span class="k">i8</span><span class="p">**</span> <span class="k">nocapture</span> <span class="nv">%retptr</span><span class="p">,</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}**</span> <span class="k">nocapture</span> <span class="k">readnone</span> <span class="nv">%excinfo</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">readnone</span> <span class="nv">%env</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%.6</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%env</span><span class="p">,</span> <span class="k">null</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%.6</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%entry.if</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%entry.endif</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">entry.if:</span>                                         <span class="c">; preds = %entry</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="vg">@PyExc_SystemError</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">73</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@&quot;.const.Numba_internal_error:_object_mode_function_called_without_an_environment&quot;</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">))</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">-1</span>

<span class="nl">entry.endif:</span>                                      <span class="c">; preds = %entry</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="nv">%.21</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">null</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%.21</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.if</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">B0.if:</span>                                            <span class="c">; preds = %entry.endif</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="vg">@PyExc_NameError</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">24</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@&quot;.const.name_&#39;a&#39;_is_not_defined&quot;</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">))</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">-1</span>

<span class="nl">B0.endif:</span>                                         <span class="c">; preds = %entry.endif</span>
  <span class="nv">%.30</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">,</span> <span class="k">null</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%.30</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif1.1</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">B0.endif1:</span>                                        <span class="c">; preds = %B0.endif</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="vg">@PyExc_NameError</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">24</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@&quot;.const.name_&#39;b&#39;_is_not_defined&quot;</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">))</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">-1</span>

<span class="nl">B0.endif1.1:</span>                                      <span class="c">; preds = %B0.endif</span>
  <span class="nv">%.38</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@PyNumber_Add</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="nv">%.39</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%.38</span><span class="p">,</span> <span class="k">null</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%.39</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif1.1.if</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif1.1.endif</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">B0.endif1.1.if:</span>                                   <span class="c">; preds = %B0.endif1.1</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">-1</span>

<span class="nl">B0.endif1.1.endif:</span>                                <span class="c">; preds = %B0.endif1.1</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%.38</span><span class="p">)</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%.38</span><span class="p">)</span>
  <span class="k">store</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%.38</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%retptr</span><span class="p">,</span> <span class="k">align</span> <span class="m">8</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@PyNumber_Add</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>
</pre></div>
</div>
<p>The careful reader might notice several unnecessary calls to <code class="docutils literal"><span class="pre">Py_IncRef</span></code>
and <code class="docutils literal"><span class="pre">Py_DecRef</span></code> in the generated code.  Currently Numba isn&#8217;t able to
optimize those away.</p>
<p>Object mode compilation will also attempt to identify loops which can be
extracted and statically-typed for &#8220;nopython&#8221; compilation.  This process is
called <em>loop-lifting</em>, and results in the creation of a hidden nopython mode
function just containing the loop which is then called from the original
function.  Loop-lifting helps improve the performance of functions that
need to access uncompilable code (such as I/O or plotting code) but still
contain a time-intensive section of compilable code.</p>
</div>
<div class="section" id="stage-7-compile-llvm-ir-to-machine-code">
<h3>6.2.3.8. Stage 7: Compile LLVM IR to Machine Code<a class="headerlink" href="#stage-7-compile-llvm-ir-to-machine-code" title="Permalink to this headline">¶</a></h3>
<p>In both &#8220;object mode&#8221; and &#8220;nopython mode&#8221;, the generated LLVM IR is compiled
by the LLVM JIT compiler and the machine code is loaded into memory.  A Python
wrapper is also created (defined in <code class="docutils literal"><span class="pre">numba.dispatcher.Overloaded</span></code>) which can
do the dynamic dispatch to the correct version of the compiled function if
multiple type specializations were generated (for example, for both
<code class="docutils literal"><span class="pre">float32</span></code> and <code class="docutils literal"><span class="pre">float64</span></code> versions of the same function).</p>
<p>The machine assembly code generated by LLVM can be dumped to the screen by
setting the <span class="target" id="index-4"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DUMP_ASSEMBLY"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DUMP_ASSEMBLY</span></code></a> environment variable to 1:</p>
<div class="highlight-gas"><div class="highlight"><pre>        <span class="na">.globl</span>  <span class="no">__main__.add$1.int64.int64</span>
        <span class="na">.align</span>  <span class="mi">16</span><span class="p">,</span> <span class="mi">0x90</span>
        <span class="na">.type</span>   <span class="no">__main__.add$1.int64.int64</span><span class="p">,</span><span class="na">@function</span>
<span class="nl">__main__.add$1.int64.int64:</span>
        <span class="nf">addq</span>    <span class="nv">%r8</span><span class="p">,</span> <span class="nv">%rcx</span>
        <span class="nf">movq</span>    <span class="nv">%rcx</span><span class="p">,</span> <span class="p">(</span><span class="nv">%rdi</span><span class="p">)</span>
        <span class="nf">xorl</span>    <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%eax</span>
        <span class="nf">retq</span>
</pre></div>
</div>
<p>The assembly output will also include the generated wrapper function that
translates the Python arguments to native data types.</p>
</div>
</div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
        
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row-fluid">
<div class="related navbar ">
  <div class="navbar-inner">
    <ul class="nav pull-right">
      
        <li><a href="../genindex.html" title="General Index" >index</a></li>
        <li><a href="extending-frontend.html" title="6.3. Extending the Numba frontend" >next</a></li>
        <li><a href="contributing.html" title="6.1. Contributing to Numba" >previous</a></li>
        <li><a href="../index.html">Numba 0.23.0+38.gdde50d8-py2.7-linux-x86_64.egg documentation</a></li>
        <li><a href="index.html" >6. Developer Manual</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer>
          &copy; Copyright 2012-2015, Continuum Analytics.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>