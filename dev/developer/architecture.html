<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>Numba Architecture &mdash; numba 0.13.4-225-g330c240 documentation</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    
<link rel="stylesheet" href="../_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/bootstrap.min.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/font-awesome.min.css">
<!--[if IE 7]>
<link rel="stylesheet" href="../_static/css/font-awesome-ie7.min.css">
<![endif]-->
<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
}
</style>
<link rel="stylesheet" href="../_static/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
<link rel="stylesheet" href="../_static/css/bootstrap-responsive.min.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    '../',
            VERSION:     '0.13.4-225-g330c240',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
<script type="text/javascript" src="../_static/js/jquery.min.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../_static/js/bootstrap.min.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    $('.show-sidebar').click(function(e) {
       e.preventDefault();
       if ($(".show-sidebar").html() == "Open Table Of Contents") {
          $('.for-mobile').removeClass('hidden-phone');
          $(".show-sidebar").html("Close Table Of Contents");
       } else {
          $(".show-sidebar").html("Open Table Of Contents");
       }
    });
  });
</script>
    <link rel="top" title="numba 0.13.4-225-g330c240 documentation" href="../index.html" />
    <link rel="next" title="Code Generation Utilties" href="cgutils.html" />
    <link rel="prev" title="Contributing to Numba" href="contributing.html" /> 
  </head>
  <body>
    <div class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">numba 0.13.4-225-g330c240 documentation</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right">
              
                <li>
                <a href="../genindex.html" title="General Index" accesskey="I">index</a>
                </li>
                <li>
                <a href="../py-modindex.html" title="Python Module Index" >modules</a>
                </li>
                <li>
                <a href="cgutils.html" title="Code Generation Utilties" accesskey="N">next</a>
                </li>
                <li>
                <a href="contributing.html" title="Contributing to Numba" accesskey="P">previous</a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container-fluid">


      
      <div class="row-fluid hidden-desktop hidden-tablet">
      
<div class="span3 ">
  <a class="visible-phone btn btn-small show-sidebar" data-toggle="collapse" data-target=".for-mobile">Open Table Of Contents</a>
  <div class="for-mobile sidebar hidden-phone">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Numba Architecture</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#contexts">Contexts</a></li>
<li><a class="reference internal" href="#compiler-stages">Compiler Stages</a><ul>
<li><a class="reference internal" href="#stage-1-analyze-bytecode">Stage 1: Analyze Bytecode</a></li>
<li><a class="reference internal" href="#stage-2-generate-the-numba-ir">Stage 2: Generate the Numba IR</a></li>
<li><a class="reference internal" href="#stage-3-infer-types">Stage 3: Infer Types</a></li>
<li><a class="reference internal" href="#stage-4a-generate-no-python-llvm-ir">Stage 4a: Generate No-Python LLVM IR</a></li>
<li><a class="reference internal" href="#stage-4b-generate-object-mode-llvm-ir">Stage 4b: Generate Object Mode LLVM IR</a></li>
<li><a class="reference internal" href="#stage-5-compile-llvm-ir-to-machine-code">Stage 5: Compile LLVM IR to Machine Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contributing.html"
                        title="previous chapter">Contributing to Numba</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cgutils.html"
                        title="next chapter">Code Generation Utilties</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/developer/architecture.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="../search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div>
      </div>
      

      <!-- row -->
      <div class="row-fluid">
         
<div class="span3 visible-desktop visible-tablet">
  <div class=" sidebar hidden-phone">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Numba Architecture</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#contexts">Contexts</a></li>
<li><a class="reference internal" href="#compiler-stages">Compiler Stages</a><ul>
<li><a class="reference internal" href="#stage-1-analyze-bytecode">Stage 1: Analyze Bytecode</a></li>
<li><a class="reference internal" href="#stage-2-generate-the-numba-ir">Stage 2: Generate the Numba IR</a></li>
<li><a class="reference internal" href="#stage-3-infer-types">Stage 3: Infer Types</a></li>
<li><a class="reference internal" href="#stage-4a-generate-no-python-llvm-ir">Stage 4a: Generate No-Python LLVM IR</a></li>
<li><a class="reference internal" href="#stage-4b-generate-object-mode-llvm-ir">Stage 4b: Generate Object Mode LLVM IR</a></li>
<li><a class="reference internal" href="#stage-5-compile-llvm-ir-to-machine-code">Stage 5: Compile LLVM IR to Machine Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contributing.html"
                        title="previous chapter">Contributing to Numba</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cgutils.html"
                        title="next chapter">Code Generation Utilties</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/developer/architecture.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox">
  <h3>Quick search</h3>
  <form class="search form-search" action="../search.html" method="get">
      <div class="input-append">
        <input type="text" class="search-query" name="q">
        <input type="submit" class="btn" value="Go" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        

        <div class="span9">
          <div class="document">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="numba-architecture">
<h1>Numba Architecture<a class="headerlink" href="#numba-architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Numba is a compiler for Python bytecode with optional type-specialization.</p>
<p>Suppose you type a function like this into the standard Python interpreter
(henceforward referred to as &#8220;CPython&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>The interpreter will immediately parse the function and convert it into a
bytecode representation that describes how the CPython interpreter should
execute the function at a low level.  For the example above, it looks
something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">2           0 LOAD_FAST                0 (a)</span>
<span class="go">            3 LOAD_FAST                1 (b)</span>
<span class="go">            6 BINARY_ADD</span>
<span class="go">            7 RETURN_VALUE</span>
</pre></div>
</div>
<p>CPython uses a stack-based interpreter (much like an HP calculator), so the
code first pushes two local variables onto the stack.  The <tt class="docutils literal"><span class="pre">BINARY_ADD</span></tt>
opcode pops the top two arguments off the stack and makes a Python C API
function call that is equivalent to calling <tt class="docutils literal"><span class="pre">a.__add__(b)</span></tt>.  The result is
then pushed onto the top of the interpreter stack.  Finally, the
<tt class="docutils literal"><span class="pre">RETURN_VALUE</span></tt> opcode returns value on the top of the stack as the result of
the function call.</p>
<p>Numba can take this bytecode and compile it to machine code that performs the
same operations as the CPython interpreter, treating <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> as
generic Python objects.  The full semantics of Python are preserved, and the
compiled function can used with any kind of objects that have the add operator
defined.  When a Numba function is compiled this way, we say that it has been
compiled in <strong>object mode</strong>, because the code still manipulates Python
objects.</p>
<p>Numba code compiled in object mode is not much faster than executing the
original Python function in the CPython interpreter.  However, if we
specialize the function to only run with certain data types, Numba can
generate much shorter and more efficient code that manipulates the data
natively without any calls into the Python C API.  When code has been compiled
for specific data types so that the function body no longer relies on the
Python runtime, we say the function has been compiled in <strong>nopython mode</strong>.
Numeric code compiled in nopython mode can be hundreds of times faster
than the original Python.</p>
</div>
<div class="section" id="contexts">
<h2>Contexts<a class="headerlink" href="#contexts" title="Permalink to this headline">¶</a></h2>
<p>Numba is quite flexible, allowing it to generate code for different hardware
architectures like CPUs and GPUs (just CUDA, for now).  In order to support
these different applications, Numba uses a <em>typing context</em> and a <em>target
context</em>.</p>
<p>A typing context is used in the compiler frontend to perform type inference on
values in the function.  Similar typing contexts could be used for many
architectures because for nearly all cases, typing inference is hardware-independent.
However, Numba currently has a different typing context for each target.</p>
<p>A target context is used to generate the specific instruction sequence
required to operate on the Numba types identified during type inference.
Target contexts are architecture specific.  For example, Numba has a &#8220;cpu&#8221; and
a &#8220;gpu&#8221; context, and NumbaPro adds a &#8220;parallel&#8221; context which produces
multithreaded CPU code.</p>
</div>
<div class="section" id="compiler-stages">
<h2>Compiler Stages<a class="headerlink" href="#compiler-stages" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">&#64;jit</span></tt> decorator in Numba ultimately calls
<tt class="docutils literal"><span class="pre">numba.compiler.compile_extra()</span></tt> which compiles the Python function in a
multi-stage process, described below.</p>
<div class="section" id="stage-1-analyze-bytecode">
<h3>Stage 1: Analyze Bytecode<a class="headerlink" href="#stage-1-analyze-bytecode" title="Permalink to this headline">¶</a></h3>
<p>At the start of compilation, the function bytecode is passed to an instance of
the Numba interpreter (<tt class="docutils literal"><span class="pre">numba.interpreter</span></tt>).  The interpreter object
analyzes the bytecode to find the control flow graph (<tt class="docutils literal"><span class="pre">numba.controlflow</span></tt>).
The control flow graph describes the ways that execution can move from one
block to the next inside the function as a result of loops and branches.</p>
<p>The data flow analysis (<tt class="docutils literal"><span class="pre">numba.dataflow</span></tt>) takes the control flow graph and
traces how values get pushed and popped off the Python interpreter stack for
different code paths.  This is important to understand the lifetimes of
variables on the stack, which are needed in Stage 2.</p>
<p>If you set the environment variable <tt class="docutils literal"><span class="pre">NUMBA_DUMP_CFG</span></tt> to 1, Numba will dump
the results of the control flow graph analysis to the screen.  Our <tt class="docutils literal"><span class="pre">add()</span></tt>
example is pretty boring, since there is only one statement block:</p>
<div class="highlight-python"><div class="highlight"><pre>CFG adjacency lists:
{0: []}
CFG dominators:
{0: set([0])}
CFG post-dominators:
{0: set([0])}
CFG back edges: []
CFG loops:
{}
CFG node-to-loops:
{0: []}
</pre></div>
</div>
<p>A function with more complex flow control will have a more interesting
control flow graph.  This function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">doloops</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">acc</span>
</pre></div>
</div>
<p>compiles to this bytecode:</p>
<div class="highlight-python"><div class="highlight"><pre> 9           0 LOAD_CONST               1 (0)
             3 STORE_FAST               1 (acc)

10           6 SETUP_LOOP              46 (to 55)
             9 LOAD_GLOBAL              0 (range)
            12 LOAD_FAST                0 (n)
            15 CALL_FUNCTION            1
            18 GET_ITER
       &gt;&gt;   19 FOR_ITER                32 (to 54)
            22 STORE_FAST               2 (i)

11          25 LOAD_FAST                1 (acc)
            28 LOAD_CONST               2 (1)
            31 INPLACE_ADD
            32 STORE_FAST               1 (acc)

12          35 LOAD_FAST                0 (n)
            38 LOAD_CONST               3 (10)
            41 COMPARE_OP               2 (==)
            44 POP_JUMP_IF_FALSE       19

13          47 BREAK_LOOP
            48 JUMP_ABSOLUTE           19
            51 JUMP_ABSOLUTE           19
       &gt;&gt;   54 POP_BLOCK

14     &gt;&gt;   55 LOAD_FAST                1 (acc)
            58 RETURN_VALUE
</pre></div>
</div>
<p>The corresponding CFG for this bytecode is:</p>
<div class="highlight-python"><div class="highlight"><pre>CFG adjacency lists:
{0: [6], 6: [19], 19: [54, 22], 22: [19, 47], 47: [55], 54: [55], 55: []}
CFG dominators:
{0: set([0]),
 6: set([0, 6]),
 19: set([0, 6, 19]),
 22: set([0, 6, 19, 22]),
 47: set([0, 6, 19, 22, 47]),
 54: set([0, 6, 19, 54]),
 55: set([0, 6, 19, 55])}
CFG post-dominators:
{0: set([0, 6, 19, 55]),
 6: set([6, 19, 55]),
 19: set([19, 55]),
 22: set([22, 55]),
 47: set([47, 55]),
 54: set([54, 55]),
 55: set([55])}
CFG back edges: [(22, 19)]
CFG loops:
{19: Loop(entries=set([6]), exits=set([54, 47]), header=19, body=set([19, 22]))}
CFG node-to-loops:
{0: [], 6: [], 19: [19], 22: [19], 47: [], 54: [], 55: []}
</pre></div>
</div>
<p>The numbers in the CFG refer to the bytecode offsets shown just to the left
of the opcode names above.</p>
</div>
<div class="section" id="stage-2-generate-the-numba-ir">
<h3>Stage 2: Generate the Numba IR<a class="headerlink" href="#stage-2-generate-the-numba-ir" title="Permalink to this headline">¶</a></h3>
<p>Once the control flow and data analyses are complete, the Numba interpreter
can step through the bytecode and translate it into an Numba-internal
intermediate representation.  This translation process changes the function
from a stack machine representation (used by the Python interpreter) to a
register machine representation (used by LLVM).</p>
<p>Although the IR is stored in memory as a tree of objects, it can be serialized
to a string for debugging.  If you set the environment variable
<tt class="docutils literal"><span class="pre">NUMBA_DUMP_IR</span></tt> equal to 1, the Numba IR will be dumped to the screen.  For
the <tt class="docutils literal"><span class="pre">add()</span></tt> function described above, the Numba IR looks like:</p>
<div class="highlight-python"><div class="highlight"><pre>label 0:
    a.1 = a
    b.1 = b
    $0.3 = a.1 + b.1
    return $0.3
</pre></div>
</div>
</div>
<div class="section" id="stage-3-infer-types">
<h3>Stage 3: Infer Types<a class="headerlink" href="#stage-3-infer-types" title="Permalink to this headline">¶</a></h3>
<p>Now that the function has been translated into the Numba IR, type analysis
can be performed.  The types of the function arguments can be taken either
from the explicit function signature given in the <tt class="docutils literal"><span class="pre">&#64;jit</span></tt> decorator
(such as <tt class="docutils literal"><span class="pre">&#64;jit('float64(float64,</span> <span class="pre">float64)')</span></tt>), or they can be taken from
the types of the actual function arguments if compilation is happening
when the function is first called.</p>
<p>The type inference engine is found in <tt class="docutils literal"><span class="pre">numba.typeinfer</span></tt>.  Its job is to
assign a type to every intermediate variable in the Numba IR.  The result of
this pass can be seen by setting the <tt class="docutils literal"><span class="pre">NUMBA_DUMP_ANNOTATION</span></tt> environment
variable to 1:</p>
<div class="highlight-python"><div class="highlight"><pre>-----------------------------------ANNOTATION-----------------------------------
# File: test.py
# --- LINE 3 ---

@numba.jit()

# --- LINE 4 ---

def add(a, b):

    # --- LINE 5 ---
    # label 0
    #   a.1 = a  :: int64
    #   b.1 = b  :: int64
    #   $0.3 = a.1 + b.1  :: int64
    #   return $0.3

    return a + b


================================================================================
</pre></div>
</div>
<p>If type inference fails to find a consistent type assignment for all the
intermediate variables, it will label every variable as type <tt class="docutils literal"><span class="pre">pyobject</span></tt> and
fall back to object mode.  Type inference can fail when unsupported Python
types, language features, or functions are used in the function body.</p>
</div>
<div class="section" id="stage-4a-generate-no-python-llvm-ir">
<h3>Stage 4a: Generate No-Python LLVM IR<a class="headerlink" href="#stage-4a-generate-no-python-llvm-ir" title="Permalink to this headline">¶</a></h3>
<p>If type inference succeeds in finding a Numba type for every intermediate
variable, then Numba can (potentially) generate specialized native code.  This
process is called <em>lowering</em>.  The Numba IR tree is translated into LLVM IR by
using helper classes from <a class="reference external" href="http://www.llvmpy.org/">llvmpy</a>.  The  machine-
generated LLVM IR can seem unnecessarily verbose, but the LLVM  toolchain is
able to optimize it quite easily into compact, efficient code.</p>
<p>The basic lowering algorithm is generic, but the specifics of how particular
Numba IR nodes are translated to LLVM instructions is handled by the
target context selected for compilation.  The default target context is
the &#8220;cpu&#8221; context, defined in <tt class="docutils literal"><span class="pre">numba.targets.cpu</span></tt>.</p>
<p>The LLVM IR can be displayed by setting the <tt class="docutils literal"><span class="pre">NUMBA_DUMP_LLVM</span></tt> environment
variable to 1.  For the &#8220;cpu&#8221; context, our <tt class="docutils literal"><span class="pre">add()</span></tt> example would look like:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="c">; ModuleID = &#39;module.add$3&#39;</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@add.int64.int64</span><span class="p">(</span><span class="k">i64</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%env</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%arg.b</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%a</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%a</span>
  <span class="nv">%b</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv">%arg.b</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%b</span>
  <span class="nv">%a.1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
  <span class="nv">%b.1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
  <span class="nv">%&quot;$0.3&quot;</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i64</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%B0</span>

<span class="nl">B0:</span>                                               <span class="c">; preds = %entry</span>
  <span class="nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%a</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv-Anonymous">%1</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%a.1</span>
  <span class="nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%b</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv-Anonymous">%2</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%b.1</span>
  <span class="nv-Anonymous">%3</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%a.1</span>
  <span class="nv-Anonymous">%4</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%b.1</span>
  <span class="nv-Anonymous">%5</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv-Anonymous">%3</span><span class="p">,</span> <span class="nv-Anonymous">%4</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv-Anonymous">%5</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.3&quot;</span>
  <span class="nv-Anonymous">%6</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%&quot;$0.3&quot;</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv-Anonymous">%6</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv-Anonymous">%0</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The post-optimization LLVM IR can be output by setting <tt class="docutils literal"><span class="pre">NUMBA_DUMP_FUNC_OPT</span></tt>
to 1.  The optimizer shortens the code generated above quite significantly:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="c">; ModuleID = &#39;module.add$3&#39;</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@add.int64.int64</span><span class="p">(</span><span class="k">i64</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%env</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%arg.b</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="nv">%arg.b</span>
  <span class="k">store</span> <span class="k">i64</span> <span class="nv-Anonymous">%1</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv-Anonymous">%0</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stage-4b-generate-object-mode-llvm-ir">
<h3>Stage 4b: Generate Object Mode LLVM IR<a class="headerlink" href="#stage-4b-generate-object-mode-llvm-ir" title="Permalink to this headline">¶</a></h3>
<p>If type inference fails to find Numba types for all values inside a function,
the function will be compiled in object mode.  The generated LLVM will be
significantly longer, as the compiled code will need to make calls to the
<a class="reference external" href="https://docs.python.org/3/c-api/">Python C API</a> to perform basically all
operations.  The optimized LLVM for our example <tt class="docutils literal"><span class="pre">add()</span></tt> function is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="c">; ModuleID = &#39;module.add$3&#39;</span>

<span class="vg">@PyExc_SystemError</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i8</span>
<span class="vg">@&quot;.const.Numba internal error: object mode function called without an environment&quot;</span> <span class="p">=</span> <span class="k">internal</span> <span class="k">constant</span> <span class="p">[</span><span class="m">73</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;Numba internal error: object mode function called without an environment\00&quot;</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@add.pyobject.pyobject</span><span class="p">(</span><span class="k">i8</span><span class="p">**,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%env</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%env</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv-Anonymous">%1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%entry.if</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%entry.endif</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">error:</span>                                            <span class="c">; preds = %entry.endif, %entry.if</span>
  <span class="nv">%a.1.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i8</span><span class="p">*</span> <span class="p">[</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%entry.if</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="nv">%entry.endif</span> <span class="p">]</span>
  <span class="nv">%b.1.0</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i8</span><span class="p">*</span> <span class="p">[</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%entry.if</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%arg.b</span><span class="p">,</span> <span class="nv">%entry.endif</span> <span class="p">]</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%b.1.0</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%a.1.0</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">-1</span>

<span class="nl">entry.if:</span>                                         <span class="c">; preds = %entry</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="vg">@PyExc_SystemError</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">73</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@&quot;.const.Numba internal error: object mode function called without an environment&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">))</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%error</span>

<span class="nl">entry.endif:</span>                                      <span class="c">; preds = %entry</span>
  <span class="nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%env</span> <span class="k">to</span> <span class="k">i64</span>
  <span class="nv-Anonymous">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv-Anonymous">%2</span><span class="p">,</span> <span class="m">16</span>
  <span class="nv-Anonymous">%4</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i64</span> <span class="nv-Anonymous">%3</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="nv-Anonymous">%5</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@PyNumber_Add</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="nv-Anonymous">%6</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv-Anonymous">%5</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv-Anonymous">%6</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%error</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%B0.endif</span><span class="p">,</span> <span class="nv">!prof</span> <span class="nv-Anonymous">!0</span>

<span class="nl">B0.endif:</span>                                         <span class="c">; preds = %entry.endif</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv-Anonymous">%5</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv-Anonymous">%5</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.b</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%arg.a</span><span class="p">)</span>
  <span class="k">store</span> <span class="k">i8</span><span class="p">*</span> <span class="nv-Anonymous">%5</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv-Anonymous">%0</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@Py_IncRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@Py_DecRef</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@PyErr_SetString</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>

<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@PyNumber_Add</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>

<span class="nv-Anonymous">!0</span> <span class="p">=</span> <span class="kt">metadata</span> <span class="p">!{</span><span class="kt">metadata</span> <span class="nv">!&quot;branch_weights&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">99</span><span class="p">}</span>
</pre></div>
</div>
<p>The careful reader might notice a lot of unnecessary calls to <tt class="docutils literal"><span class="pre">Py_IncRef</span></tt>
and <tt class="docutils literal"><span class="pre">Py_DecRef</span></tt> in the generated code.  A special pass is run after the
LLVM optimizer to identify and remove these extra reference count calls.</p>
<p>Object mode compilation will also attempt to identify loops which can be
extracted and statically-typed for &#8220;nopython&#8221; compilation.  This process is
called <em>loop-lifting</em>, and results in the creation of a hidden nopython mode
function just containing the loop which is then called from the original
function.  Loop-lifting helps improve the performance of functions that
need to access uncompilable code (such as I/O or plotting code) but still
contain a time-intensive section of compilable code.</p>
</div>
<div class="section" id="stage-5-compile-llvm-ir-to-machine-code">
<h3>Stage 5: Compile LLVM IR to Machine Code<a class="headerlink" href="#stage-5-compile-llvm-ir-to-machine-code" title="Permalink to this headline">¶</a></h3>
<p>In both &#8220;object mode&#8221; and &#8220;nopython mode&#8221;, the generated LLVM IR is compiled
by the LLVM JIT compiler and the machine code is loaded into memory.  A Python
wrapper is also created (defined in <tt class="docutils literal"><span class="pre">numba.dispatcher.Overloaded</span></tt>) which can
do the dynamic dispatch to the correct version of the compiled function if
multiple type specializations were generated (for example, for both
<tt class="docutils literal"><span class="pre">float32</span></tt> and <tt class="docutils literal"><span class="pre">float64</span></tt> versions of the same function).</p>
<p>The machine assembly code generated by LLVM can be dumped to the screen by
setting the <tt class="docutils literal"><span class="pre">NUMBA_DUMP_ASSEMBLY</span></tt> environment variable to 1:</p>
<div class="highlight-gas"><div class="highlight"><pre>  <span class="na">.section</span>  <span class="no">__TEXT</span><span class="p">,</span><span class="no">__text</span><span class="p">,</span><span class="no">regular</span><span class="p">,</span><span class="no">pure_instructions</span>
  <span class="na">.globl</span>  <span class="no">_add.int64.int64</span>
  <span class="na">.align</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">0x90</span>
<span class="nl">_add.int64.int64:</span>
  <span class="nf">addq</span>  <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nf">movq</span>  <span class="nv">%rdx</span><span class="p">,</span> <span class="p">(</span><span class="nv">%rdi</span><span class="p">)</span>
  <span class="nf">xorl</span>  <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%eax</span>
  <span class="nf">ret</span>
</pre></div>
</div>
<p>The assembly output will also include the generated wrapper function that
translates the Python arguments to native data types.</p>
</div>
</div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
        
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row-fluid">
<div class="related navbar ">
  <div class="navbar-inner">
    <ul class="nav pull-right">
      
        <li><a href="../genindex.html" title="General Index" >index</a></li>
        <li><a href="../py-modindex.html" title="Python Module Index" >modules</a></li>
        <li><a href="cgutils.html" title="Code Generation Utilties" >next</a></li>
        <li><a href="contributing.html" title="Contributing to Numba" >previous</a></li>
        <li><a href="../index.html">numba 0.13.4-225-g330c240 documentation</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer>
          &copy; Copyright 2012-2014, Continuum Analytics.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>