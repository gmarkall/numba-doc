<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1.13. Performance Tips &mdash; Numba 0.43.0.dev0+581.ga0a3bd7-py2.7-linux-x86_64.egg documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/numba-docs.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.43.0.dev0+581.ga0a3bd7-py2.7-linux-x86_64.egg',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Numba 0.43.0.dev0+581.ga0a3bd7-py2.7-linux-x86_64.egg documentation" href="../index.html" />
    <link rel="up" title="1. User Manual" href="index.html" />
    <link rel="next" title="1.14. The Threading Layers" href="threading-layer.html" />
    <link rel="prev" title="1.12. Callback into the Python Interpreter from within JIT’ed code" href="withobjmode.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/numba_blue_icon_rgb.png"></span>
          Numba</a>
        <span class="navbar-text navbar-version pull-left"><b>0.43</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proposals/index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">1.13. Performance Tips</a><ul>
<li><a class="reference internal" href="#no-python-mode-vs-object-mode">1.13.1. No Python mode vs Object mode</a></li>
<li><a class="reference internal" href="#loops">1.13.2. Loops</a></li>
<li><a class="reference internal" href="#fastmath">1.13.3. Fastmath</a></li>
<li><a class="reference internal" href="#parallel-true">1.13.4. Parallel=True</a></li>
<li><a class="reference internal" href="#intel-svml">1.13.5. Intel SVML</a></li>
<li><a class="reference internal" href="#linear-algebra">1.13.6. Linear algebra</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="withobjmode.html" title="Previous Chapter: 1.12. Callback into the Python Interpreter from within JIT’ed code"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 1.12. Callback i...</span>
    </a>
  </li>
  <li>
    <a href="threading-layer.html" title="Next Chapter: 1.14. The Threading Layers"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">1.14. The Thread... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/user/performance-tips.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="performance-tips">
<span id="id1"></span><h1>1.13. Performance Tips<a class="headerlink" href="#performance-tips" title="Permalink to this headline">¶</a></h1>
<p>This is a short guide to features present in Numba that can help with obtaining
the best performance from code. Two examples are used, both are entirely
contrived and exist purely for pedagogical reasons to motivate discussion.
The first is the computation of the trigonometric identity
<code class="docutils literal"><span class="pre">cos(x)^2</span> <span class="pre">+</span> <span class="pre">sin(x)^2</span></code>, the second is a simple element wise square root of a
vector with reduction over summation. All performance numbers are indicative
only and unless otherwise stated were taken from running on an Intel <code class="docutils literal"><span class="pre">i7-4790</span></code>
CPU (4 hardware threads) with an input of <code class="docutils literal"><span class="pre">np.arange(1.e7)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A reasonably effective approach to achieving high performance code is to
profile the code running with real data and use that to guide performance
tuning. The information presented here is to demonstrate features, not to act
as canonical guidance!</p>
</div>
<div class="section" id="no-python-mode-vs-object-mode">
<h2>1.13.1. No Python mode vs Object mode<a class="headerlink" href="#no-python-mode-vs-object-mode" title="Permalink to this headline">¶</a></h2>
<p>A common pattern is to decorate functions with <code class="docutils literal"><span class="pre">&#64;jit</span></code> as this is the most
flexible decorator offered by Numba. <code class="docutils literal"><span class="pre">&#64;jit</span></code> essentially encompasses two modes
of compilation, first it will try and compile the decorated function in no
Python mode, if this fails it will try again to compile the function using
object mode. Whilst the use of looplifting in object mode can enable some
performance increase, getting functions to compile under no python mode is
really the key to good performance. To make it such that only no python mode is
used and if compilation fails an exception is raised the decorators <code class="docutils literal"><span class="pre">&#64;njit</span></code>
and <code class="docutils literal"><span class="pre">&#64;jit(nopython=True)</span></code> can be used (the first is an alias of the
second for convenience).</p>
</div>
<div class="section" id="loops">
<h2>1.13.2. Loops<a class="headerlink" href="#loops" title="Permalink to this headline">¶</a></h2>
<p>Whilst NumPy has developed a strong idiom around the use of vector operations,
Numba is perfectly happy with loops too. For users familiar with C or Fortran,
writing Python in this style will work fine in Numba (after all, LLVM gets a
lot of use in compiling C lineage languages). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">ident_np</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">ident_loops</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The above run at almost identical speeds when decorated with <code class="docutils literal"><span class="pre">&#64;njit</span></code>, without
the decorator the vectorized function is a couple of orders of magnitude faster.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="18%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">&#64;njit</th>
<th class="head">Execution time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ident_np</span></code></td>
<td>No</td>
<td>0.581s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ident_np</span></code></td>
<td>Yes</td>
<td>0.659s</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ident_loops</span></code></td>
<td>No</td>
<td>25.2s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ident_loops</span></code></td>
<td>Yes</td>
<td>0.670s</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fastmath">
<h2>1.13.3. Fastmath<a class="headerlink" href="#fastmath" title="Permalink to this headline">¶</a></h2>
<p>In certain classes of applications strict IEEE 754 compliance is less
important. As a result it is possible to relax some numerical rigour with
view of gaining additional performance. The way to achieve this behaviour in
Numba is through the use of the <code class="docutils literal"><span class="pre">fastmath</span></code> keyword argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_sum</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c"># without fastmath, this loop must accumulate in strict order</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">acc</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_sum_fast</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c"># with fastmath, the reduction can be vectorized as floating point</span>
    <span class="c"># reassociation is permitted.</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">acc</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">Execution time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">do_sum</span></code></td>
<td>35.2 ms</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">do_sum_fast</span></code></td>
<td>17.8 ms</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="parallel-true">
<h2>1.13.4. Parallel=True<a class="headerlink" href="#parallel-true" title="Permalink to this headline">¶</a></h2>
<p>If code contains operations that are parallelisable (<a class="reference internal" href="parallel.html#numba-parallel-supported"><span>and supported</span></a>) Numba can compile a version of that will run in
parallel on multiple native threads (no GIL!). This parallelisation is performed
automatically and is enabled by simply adding the <code class="docutils literal"><span class="pre">parallel</span></code> keyword
argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ident_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Executions times are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">Execution time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ident_parallel</span></code></td>
<td>112 ms</td>
</tr>
</tbody>
</table>
<p>The execution speed of this function with <code class="docutils literal"><span class="pre">parallel=True</span></code> present is
approximately 5x that of the NumPy equivalent and 6x that of standard
<code class="docutils literal"><span class="pre">&#64;njit</span></code>.</p>
<p>Numba parallel execution also has support for explicit parallel loop
declaration similar to that in OpenMP. To indicate that a loop should be
executed in parallel the <code class="docutils literal"><span class="pre">numba.prange</span></code> function should be used, this function
behaves like Python <code class="docutils literal"><span class="pre">range</span></code> and if <code class="docutils literal"><span class="pre">parallel=True</span></code> is not set it acts
simply as an alias of <code class="docutils literal"><span class="pre">range</span></code>. Loops induced with <code class="docutils literal"><span class="pre">prange</span></code> can be used for
embarrassingly parallel computation and also reductions.</p>
<p>Revisiting the reduce over sum example, assuming it is safe for the sum to be
accumulated out of order, the loop in <code class="docutils literal"><span class="pre">n</span></code> can be parallelised through the use
of <code class="docutils literal"><span class="pre">prange</span></code>. Further, the <code class="docutils literal"><span class="pre">fastmath=True</span></code> keyword argument can be added
without concern in this case as the assumption that out of order execution is
valid has already been made through the use of <code class="docutils literal"><span class="pre">parallel=True</span></code> (as each thread
computes a partial sum).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_sum_parallel</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="c"># each thread can accumulate its own partial sum, and then a cross</span>
    <span class="c"># thread reduction is performed to obtain the result to return</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">acc</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_sum_parallel_fast</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">acc</span>
</pre></div>
</div>
<p>Execution times are as follows, <code class="docutils literal"><span class="pre">fastmath</span></code> again improves performance.</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">Execution time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">do_sum_parallel</span></code></td>
<td>9.81 ms</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">do_sum_parallel_fast</span></code></td>
<td>5.37 ms</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="intel-svml">
<span id="id2"></span><h2>1.13.5. Intel SVML<a class="headerlink" href="#intel-svml" title="Permalink to this headline">¶</a></h2>
<p>Intel provides a short vector math library (SVML) that contains a large number
of optimised transcendental functions available for use as compiler
intrinsics. If the <code class="docutils literal"><span class="pre">icc_rt</span></code> package is present in the environment (or the SVML
libraries are simply locatable!) then Numba automatically configures the LLVM
back end to use the SVML intrinsic functions where ever possible. SVML provides
both high and low accuracy versions of each intrinsic and the version that is
used is determined through the use of the <code class="docutils literal"><span class="pre">fastmath</span></code> keyword. The default is
to use high accuracy which is accurate to within <code class="docutils literal"><span class="pre">1</span> <span class="pre">ULP</span></code>, however if
<code class="docutils literal"><span class="pre">fastmath</span></code> is set to <code class="docutils literal"><span class="pre">True</span></code> then the lower accuracy versions of the
intrinsics are used (answers to within <code class="docutils literal"><span class="pre">4</span> <span class="pre">ULP</span></code>).</p>
<p>First obtain SVML, using conda for example:</p>
<div class="highlight-python"><div class="highlight"><pre>conda install -c numba icc_rt
</pre></div>
</div>
<p>Rerunning the identity function example <code class="docutils literal"><span class="pre">ident_np</span></code> from above with various
combinations of options to <code class="docutils literal"><span class="pre">&#64;njit</span></code> and with/without SVML yields the following
performance results (input size <code class="docutils literal"><span class="pre">np.arange(1.e8)</span></code>). For reference, with just
NumPy the function executed in <code class="docutils literal"><span class="pre">5.84s</span></code>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="13%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">&#64;njit</span></code> kwargs</th>
<th class="head">SVML</th>
<th class="head">Execution time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">None</span></code></td>
<td>No</td>
<td>5.95s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">None</span></code></td>
<td>Yes</td>
<td>2.26s</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">fastmath=True</span></code></td>
<td>No</td>
<td>5.97s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">fastmath=True</span></code></td>
<td>Yes</td>
<td>1.8s</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">parallel=True</span></code></td>
<td>No</td>
<td>1.36s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">parallel=True</span></code></td>
<td>Yes</td>
<td>0.624s</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">parallel=True,</span> <span class="pre">fastmath=True</span></code></td>
<td>No</td>
<td>1.32s</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">parallel=True,</span> <span class="pre">fastmath=True</span></code></td>
<td>Yes</td>
<td>0.576s</td>
</tr>
</tbody>
</table>
<p>It is evident that SVML significantly increases the performance of this
function. The impact of <code class="docutils literal"><span class="pre">fastmath</span></code> in the case of SVML not being present is
zero, this is expected as there is nothing in the original function that would
benefit from relaxing numerical strictness.</p>
</div>
<div class="section" id="linear-algebra">
<h2>1.13.6. Linear algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<p>Numba supports most of <code class="docutils literal"><span class="pre">numpy.linalg</span></code> in no Python mode. The internal
implementation relies on a LAPACK and BLAS library to do the numerical work
and it obtains the bindings for the necessary functions from SciPy. Therefore,
to achieve good performance in <code class="docutils literal"><span class="pre">numpy.linalg</span></code> functions with Numba it is
necessary to use a SciPy built against a well optimised LAPACK/BLAS library.
In the case of the Anaconda distribution SciPy is built against Intel&#8217;s MKL
which is highly optimised and as a result Numba makes use of this performance.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Anaconda, Inc..<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>