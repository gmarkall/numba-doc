<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1.6. Creating Numpy universal functions &mdash; Numba 0.41.0.dev0+75.gdb0256a-py2.7-linux-x86_64.egg documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/numba-docs.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.41.0.dev0+75.gdb0256a-py2.7-linux-x86_64.egg',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Numba 0.41.0.dev0+75.gdb0256a-py2.7-linux-x86_64.egg documentation" href="../index.html" />
    <link rel="up" title="1. User Manual" href="index.html" />
    <link rel="next" title="1.7. Compiling python classes with @jitclass" href="jitclass.html" />
    <link rel="prev" title="1.5. Flexible specializations with @generated_jit" href="generated-jit.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/numba_blue_icon_rgb.png"></span>
          Numba</a>
        <span class="navbar-text navbar-version pull-left"><b>0.41</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proposals/index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">1.6. Creating Numpy universal functions</a><ul>
<li><a class="reference internal" href="#the-vectorize-decorator">1.6.1. The <code class="docutils literal"><span class="pre">&#64;vectorize</span></code> decorator</a></li>
<li><a class="reference internal" href="#the-guvectorize-decorator">1.6.2. The <code class="docutils literal"><span class="pre">&#64;guvectorize</span></code> decorator</a></li>
<li><a class="reference internal" href="#dynamic-universal-functions">1.6.3. Dynamic universal functions</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="generated-jit.html" title="Previous Chapter: 1.5. Flexible specializations with @generated_jit"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 1.5. Flexible sp...</span>
    </a>
  </li>
  <li>
    <a href="jitclass.html" title="Next Chapter: 1.7. Compiling python classes with @jitclass"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">1.7. Compiling p... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/user/vectorize.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="creating-numpy-universal-functions">
<h1>1.6. Creating Numpy universal functions<a class="headerlink" href="#creating-numpy-universal-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-vectorize-decorator">
<span id="vectorize"></span><h2>1.6.1. The <code class="docutils literal"><span class="pre">&#64;vectorize</span></code> decorator<a class="headerlink" href="#the-vectorize-decorator" title="Permalink to this headline">¶</a></h2>
<p>Numba&#8217;s vectorize allows Python functions taking scalar input arguments to
be used as NumPy <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html">ufuncs</a>.  Creating a traditional NumPy ufunc is not
not the most straightforward process and involves writing some C code.
Numba makes this easy.  Using the <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator, Numba
can compile a pure Python function into a ufunc that operates over NumPy
arrays as fast as traditional ufuncs written in C.</p>
<p>Using <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a>, you write your function as operating over
input scalars, rather than arrays.  Numba will generate the surrounding
loop (or <em>kernel</em>) allowing efficient iteration over the actual inputs.</p>
<p>The <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator has two modes of operation:</p>
<ul class="simple">
<li>Eager, or decoration-time, compilation: If you pass one or more type
signatures to the decorator, you will be building a Numpy universal
function (ufunc).  The rest of this subsection describes building
ufuncs using decoration-time compilation.</li>
<li>Lazy, or call-time, compilation: When not given any signatures, the
decorator will give you a Numba dynamic universal function
(<a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a>) that dynamically compiles a new kernel when
called with a previously unsupported input type.  A later
subsection, &#8220;<a class="reference internal" href="#dynamic-universal-functions"><span>Dynamic universal functions</span></a>&#8221;, describes this mode in
more depth.</li>
</ul>
<p>As described above, if you pass a list of signatures to the
<a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator, your function will be compiled
into a Numpy ufunc.  In the basic case, only one signature will be
passed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">float64</span>

<span class="nd">@vectorize</span><span class="p">([</span><span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>If you pass several signatures, beware that you have to pass most specific
signatures before least specific ones (e.g., single-precision floats
before double-precision floats), otherwise type-based dispatching will not work
as expected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@vectorize</span><span class="p">([</span><span class="n">int32</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">int32</span><span class="p">),</span>
            <span class="n">int64</span><span class="p">(</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">),</span>
            <span class="n">float32</span><span class="p">(</span><span class="n">float32</span><span class="p">,</span> <span class="n">float32</span><span class="p">),</span>
            <span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>The function will work as expected over the specified array types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  6,  8, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0. ,  0.4,  0.8,  1.2,  1.6,  2. ])</span>
</pre></div>
</div>
<p>but it will fail working on other types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1j</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">ufunc &#39;ufunc&#39; not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule &#39;&#39;safe&#39;&#39;</span>
</pre></div>
</div>
<p>You might ask yourself, &#8220;why would I go through this instead of compiling
a simple iteration loop using the <a class="reference internal" href="jit.html#jit"><span>&#64;jit</span></a> decorator?&#8221;.  The
answer is that NumPy ufuncs automatically get other features such as
reduction, accumulation or broadcasting.  Using the example above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([12, 15, 18, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 6, 22, 38])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  6,  8, 10],</span>
<span class="go">       [12, 15, 18, 21]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  3,  6],</span>
<span class="go">       [ 4,  9, 15, 22],</span>
<span class="go">       [ 8, 17, 27, 38]])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufunc">Standard features of ufuncs</a> (NumPy documentation).</p>
</div>
<p>The <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator supports multiple ufunc targets:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Target</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cpu</td>
<td>Single-threaded CPU</td>
</tr>
<tr class="row-odd"><td>parallel</td>
<td>Multi-core CPU</td>
</tr>
<tr class="row-even"><td>cuda</td>
<td><p class="first">CUDA GPU</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This creates an <em>ufunc-like</em> object.
See <a class="reference external" href="../cuda/ufunc.html">documentation for CUDA ufunc</a> for detail.</p>
</div>
</td>
</tr>
</tbody>
</table>
<p>A general guideline is to choose different targets for different data sizes
and algorithms.
The &#8220;cpu&#8221; target works well for small data sizes (approx. less than 1KB) and low
compute intensity algorithms. It has the least amount of overhead.
The &#8220;parallel&#8221; target works well for medium data sizes (approx. less than 1MB).
Threading adds a small delay.
The &#8220;cuda&#8221; target works well for big data sizes (approx. greater than 1MB) and
high compute intensity algorithms.  Transfering memory to and from the GPU adds
significant overhead.</p>
</div>
<div class="section" id="the-guvectorize-decorator">
<span id="guvectorize"></span><h2>1.6.2. The <code class="docutils literal"><span class="pre">&#64;guvectorize</span></code> decorator<a class="headerlink" href="#the-guvectorize-decorator" title="Permalink to this headline">¶</a></h2>
<p>While <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> allows you to write ufuncs that work on one
element at a time, the <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal"><span class="pre">guvectorize()</span></code></a> decorator takes the concept
one step further and allows you to write ufuncs that will work on an
arbitrary number of elements of input arrays, and take and return arrays of
differing dimensions.  The typical example is a running median or a
convolution filter.</p>
<p>Contrary to <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> functions, <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal"><span class="pre">guvectorize()</span></code></a>
functions don&#8217;t return their result value: they take it as an array
argument, which must be filled in by the function.  This is because the
array is actually allocated by NumPy&#8217;s dispatch mechanism, which calls into
the Numba-generated code.</p>
<p>Here is a very simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@guvectorize</span><span class="p">([(</span><span class="n">int64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">[:])],</span> <span class="s">&#39;(n),()-&gt;(n)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>The underlying Python function simply adds a given scalar (<code class="docutils literal"><span class="pre">y</span></code>) to all
elements of a 1-dimension array.  What&#8217;s more interesting is the declaration.
There are two things there:</p>
<ul class="simple">
<li>the declaration of input and output <em>layouts</em>, in symbolic form:
<code class="docutils literal"><span class="pre">(n),()-&gt;(n)</span></code> tells NumPy that the function takes a <em>n</em>-element one-dimension
array, a scalar (symbolically denoted by the empty tuple <code class="docutils literal"><span class="pre">()</span></code>) and
returns a <em>n</em>-element one-dimension array;</li>
<li>the list of supported concrete <em>signatures</em> as in <code class="docutils literal"><span class="pre">&#64;vectorize</span></code>; here we
only support <code class="docutils literal"><span class="pre">int64</span></code> arrays.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1D array type can also receive scalar arguments (those with shape <code class="docutils literal"><span class="pre">()</span></code>).
In the above example, the second argument also could be declared as
<code class="docutils literal"><span class="pre">int64[:]</span></code>.  In that case, the value must be read by <code class="docutils literal"><span class="pre">y[0]</span></code>.</p>
</div>
<p>We can now check what the compiled ufunc does, over a simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>The nice thing is that NumPy will automatically dispatch over more
complicated inputs, depending on their shapes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]))</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [23, 24, 25]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> and <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal"><span class="pre">guvectorize()</span></code></a> support
passing <code class="docutils literal"><span class="pre">nopython=True</span></code> <a class="reference internal" href="jit.html#jit-nopython"><span>as in the &#64;jit decorator</span></a>.
Use it to ensure the generated code does not fallback to
<a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a>.</p>
</div>
</div>
<div class="section" id="dynamic-universal-functions">
<span id="id1"></span><h2>1.6.3. Dynamic universal functions<a class="headerlink" href="#dynamic-universal-functions" title="Permalink to this headline">¶</a></h2>
<p>As described above, if you do not pass any signatures to the
<a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator, your Python function will be used
to build a dynamic universal function, or <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a>.  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">vectorize</span>

<span class="nd">@vectorize</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>
</div>
<p>The resulting <code class="xref py py-func docutils literal"><span class="pre">f()</span></code> is a <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a> instance that
starts with no supported input types.  As you make calls to <code class="xref py py-func docutils literal"><span class="pre">f()</span></code>,
Numba generates new kernels whenever you pass a previously unsupported
input type.  Given the example above, the following set of interpreter
interactions illustrate how dynamic compilation works:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;numba._DUFunc &#39;f&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">ufunc</span>
<span class="go">&lt;ufunc &#39;f&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">types</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The example above shows that <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a> instances are not
ufuncs.  Rather than subclass ufunc&#8217;s, <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a>
instances work by keeping a <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc.ufunc" title="numba.DUFunc.ufunc"><code class="xref py py-attr docutils literal"><span class="pre">ufunc</span></code></a> member, and
then delegating ufunc property reads and method calls to this member
(also known as type aggregation).  When we look at the initial types
supported by the ufunc, we can verify there are none.</p>
<p>Let&#8217;s try to make a call to <code class="xref py py-func docutils literal"><span class="pre">f()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>   <span class="c"># shorthand for f.ufunc.types</span>
<span class="go">[&#39;ll-&gt;l&#39;]</span>
</pre></div>
</div>
<p>If this was a normal Numpy ufunc, we would have seen an exception
complaining that the ufunc couldn&#8217;t handle the input types.  When we
call <code class="xref py py-func docutils literal"><span class="pre">f()</span></code> with integer arguments, not only do we receive an
answer, but we can verify that Numba created a loop supporting C
<code class="code docutils literal"><span class="pre">long</span></code> integers.</p>
<p>We can add additional loops by calling <code class="xref py py-func docutils literal"><span class="pre">f()</span></code> with different inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;ll-&gt;l&#39;, &#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>We can now verify that Numba added a second loop for dealing with
floating-point inputs, <code class="code docutils literal"><span class="pre">&quot;dd-&gt;d&quot;</span></code>.</p>
<p>If we mix input types to <code class="xref py py-func docutils literal"><span class="pre">f()</span></code>, we can verify that <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#casting-rules">Numpy ufunc
casting rules</a> are still in effect:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;ll-&gt;l&#39;, &#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>This example demonstrates that calling <code class="xref py py-func docutils literal"><span class="pre">f()</span></code> with mixed types
caused Numpy to select the floating-point loop, and cast the integer
argument to a floating-point value.  Thus, Numba did not create a
special <code class="code docutils literal"><span class="pre">&quot;dl-&gt;d&quot;</span></code> kernel.</p>
<p>This <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal"><span class="pre">DUFunc</span></code></a> behavior leads us to a point similar to
the warning given above in &#8220;<a class="reference internal" href="#the-vectorize-decorator">The &#64;vectorize decorator</a>&#8221; subsection,
but instead of signature declaration order in the decorator, call
order matters.  If we had passed in floating-point arguments first,
any calls with integer arguments would be cast to double-precision
floating-point values.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@vectorize</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">0.66666666666666663</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.66666666666666663</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>If you require precise support for various type signatures, you should
specify them in the <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal"><span class="pre">vectorize()</span></code></a> decorator, and not rely
on dynamic compilation.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Anaconda, Inc..<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>