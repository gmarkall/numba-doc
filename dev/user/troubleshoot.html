<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1.12. Troubleshooting and tips &mdash; Numba 0.40.0.dev0+105.g94e6727-py2.7-linux-x86_64.egg documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.40.0.dev0+105.g94e6727-py2.7-linux-x86_64.egg',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Numba 0.40.0.dev0+105.g94e6727-py2.7-linux-x86_64.egg documentation" href="../index.html" />
    <link rel="up" title="1. User Manual" href="index.html" />
    <link rel="next" title="1.13. Frequently Asked Questions" href="faq.html" />
    <link rel="prev" title="1.11. Performance Tips" href="performance-tips.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/numba_blue_icon_rgb.png"></span>
          Numba</a>
        <span class="navbar-text navbar-version pull-left"><b>0.40</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hsa/index.html">5. Numba for HSA APUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proposals/index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">1.12. Troubleshooting and tips</a><ul>
<li><a class="reference internal" href="#what-to-compile">1.12.1. What to compile</a></li>
<li><a class="reference internal" href="#my-code-doesn-t-compile">1.12.2. My code doesn&#8217;t compile</a></li>
<li><a class="reference internal" href="#my-code-has-a-type-unification-problem">1.12.3. My code has a type unification problem</a></li>
<li><a class="reference internal" href="#the-compiled-code-is-too-slow">1.12.4. The compiled code is too slow</a></li>
<li><a class="reference internal" href="#disabling-jit-compilation">1.12.5. Disabling JIT compilation</a></li>
<li><a class="reference internal" href="#debugging-jit-compiled-code-with-gdb">1.12.6. Debugging JIT compiled code with GDB</a><ul>
<li><a class="reference internal" href="#example-debug-usage">1.12.6.1. Example debug usage</a></li>
<li><a class="reference internal" href="#globally-override-debug-setting">1.12.6.2. Globally override debug setting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging-cuda-python-code">1.12.7. Debugging CUDA Python code</a><ul>
<li><a class="reference internal" href="#using-the-simulator">1.12.7.1. Using the simulator</a></li>
<li><a class="reference internal" href="#debug-info">1.12.7.2. Debug Info</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="performance-tips.html" title="Previous Chapter: 1.11. Performance Tips"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 1.11. Performanc...</span>
    </a>
  </li>
  <li>
    <a href="faq.html" title="Next Chapter: 1.13. Frequently Asked Questions"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">1.13. Frequently... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/user/troubleshoot.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="troubleshooting-and-tips">
<span id="numba-troubleshooting"></span><h1>1.12. Troubleshooting and tips<a class="headerlink" href="#troubleshooting-and-tips" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-to-compile">
<span id="id1"></span><h2>1.12.1. What to compile<a class="headerlink" href="#what-to-compile" title="Permalink to this headline">¶</a></h2>
<p>The general recommendation is that you should only try to compile the
critical paths in your code.  If you have a piece of performance-critical
computational code amongst some higher-level code, you may factor out
the performance-critical code in a separate function and compile the
separate function with Numba.  Letting Numba focus on that small piece
of performance-critical code has several advantages:</p>
<ul class="simple">
<li>it reduces the risk of hitting unsupported features;</li>
<li>it reduces the compilation times;</li>
<li>it allows you to evolve the higher-level code which is outside of the
compiled function much easier.</li>
</ul>
</div>
<div class="section" id="my-code-doesn-t-compile">
<span id="code-doesnt-compile"></span><h2>1.12.2. My code doesn&#8217;t compile<a class="headerlink" href="#my-code-doesn-t-compile" title="Permalink to this headline">¶</a></h2>
<p>There can be various reasons why Numba cannot compile your code, and raises
an error instead.  One common reason is that your code relies on an
unsupported Python feature, especially in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.
Please see the list of <a class="reference internal" href="../reference/pysupported.html#pysupported"><span>Supported Python features</span></a>.  If you find something that
is listed there and still fails compiling, please
<a class="reference internal" href="../developer/contributing.html#report-numba-bugs"><span>report a bug</span></a>.</p>
<p>When Numba tries to compile your code it first tries to work out the types of
all the variables in use, this is so it can generate a type specific
implementation of your code that can be compiled down to machine code. A common
reason for Numba failing to compile (especially in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>) is a
type inference failure, essentially Numba cannot work out what the type of all
the variables in your code should be.</p>
<p>For example, let&#8217;s consider this trivial function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>If you call it with two numbers, Numba is able to infer the types properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">    3</span>
</pre></div>
</div>
<p>If however you call it with a tuple and a number, Numba is unable to say
what the result of adding a tuple and number is, and therefore compilation
errors out:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt;&gt;&gt; f(1, (2,))
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;&lt;path&gt;/numba/numba/dispatcher.py&quot;, line 339, in _compile_for_args
    reraise(type(e), e, None)
File &quot;&lt;path&gt;/numba/numba/six.py&quot;, line 658, in reraise
    raise value.with_traceback(tb)
numba.errors.TypingError: Failed at nopython (nopython frontend)
Invalid use of + with parameters (int64, tuple(int64 x 1))
Known signatures:
* (int64, int64) -&gt; int64
* (int64, uint64) -&gt; int64
* (uint64, int64) -&gt; int64
* (uint64, uint64) -&gt; uint64
* (float32, float32) -&gt; float32
* (float64, float64) -&gt; float64
* (complex64, complex64) -&gt; complex64
* (complex128, complex128) -&gt; complex128
* (uint16,) -&gt; uint64
* (uint8,) -&gt; uint64
* (uint64,) -&gt; uint64
* (uint32,) -&gt; uint64
* (int16,) -&gt; int64
* (int64,) -&gt; int64
* (int8,) -&gt; int64
* (int32,) -&gt; int64
* (float32,) -&gt; float32
* (float64,) -&gt; float64
* (complex64,) -&gt; complex64
* (complex128,) -&gt; complex128
* parameterized
[1] During: typing of intrinsic-call at &lt;stdin&gt; (3)

File &quot;&lt;stdin&gt;&quot;, line 3:
</pre></div>
</div>
<p>The error message helps you find out what went wrong:
&#8220;Invalid use of + with parameters (int64, tuple(int64 x 1))&#8221; is to be
interpreted as &#8220;Numba encountered an addition of variables typed as integer
and 1-tuple of integer, respectively, and doesn&#8217;t know about any such
operation&#8221;.</p>
<p>Note that if you allow object mode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>compilation will succeed and the compiled function will raise at runtime as
Python would do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for +: &#39;int&#39; and &#39;tuple&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="my-code-has-a-type-unification-problem">
<h2>1.12.3. My code has a type unification problem<a class="headerlink" href="#my-code-has-a-type-unification-problem" title="Permalink to this headline">¶</a></h2>
<p>Another common reason for Numba not being able to compile your code is that it
cannot statically determine the return type of a function. The most likely
cause of this is the return type depending on a value that is available only at
runtime. Again, this is most often problematic when using
<a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>. The concept of type unification is simply trying to find
a type in which two variables could safely be represented. For example a 64 bit
float and a 64 bit complex number could both be represented in a 128 bit complex
number.</p>
<p>As an example of type unification failure, this function has a return type that
is determined at runtime based on the value of <cite>x</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre>In [1]: from numba import jit

In [2]: @jit(nopython=True)
...: def f(x):
...:     if x &gt; 10:
...:         return (1,)
...:     else:
...:         return 1
...:

In [3]: f(10)
</pre></div>
</div>
<p>Trying to execute this function, errors out as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>TypingError: Failed at nopython (nopython frontend)
Can&#39;t unify return type from the following types: tuple(int64 x 1), int64
Return of: IR name &#39;$8.2&#39;, type &#39;(int64 x 1)&#39;, location:
File &quot;&lt;ipython-input-2-51ef1cc64bea&gt;&quot;, line 4:
def f(x):
    &lt;source elided&gt;
    if x &gt; 10:
        return (1,)
        ^
Return of: IR name &#39;$12.2&#39;, type &#39;int64&#39;, location:
File &quot;&lt;ipython-input-2-51ef1cc64bea&gt;&quot;, line 6:
def f(x):
    &lt;source elided&gt;
    else:
        return 1
</pre></div>
</div>
<p>The error message &#8220;Can&#8217;t unify return type from the following types:
tuple(int64 x 1), int64&#8221; should be read as &#8220;Numba cannot find a type that
can safely represent a 1-tuple of integer and an integer&#8221;.</p>
</div>
<div class="section" id="the-compiled-code-is-too-slow">
<h2>1.12.4. The compiled code is too slow<a class="headerlink" href="#the-compiled-code-is-too-slow" title="Permalink to this headline">¶</a></h2>
<p>The most common reason for slowness of a compiled JIT function is that
compiling in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a> has failed and the Numba compiler has
fallen back to <a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a>.  <a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a> currently provides
little to no speedup compared to regular Python interpretation, and its
main point is to allow an internal optimization known as
<a class="reference internal" href="../glossary.html#term-loop-lifting"><span class="xref std std-term">loop-lifting</span></a>: this optimization will allow to compile inner
loops in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a> regardless of what code surrounds those
inner loops.</p>
<p>To find out if type inference succeeded on your function, you can use
the <a class="reference internal" href="../reference/jit-compilation.html#Dispatcher.inspect_types" title="Dispatcher.inspect_types"><code class="xref py py-meth docutils literal"><span class="pre">inspect_types()</span></code></a> method on the compiled function.</p>
<p>For example, let&#8217;s take the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>When called with numbers, this function should be fast as Numba is able
to convert number types to floating-point numbers.  Let&#8217;s see:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">inspect_types</span><span class="p">()</span>
<span class="go">f (int64, int64)</span>
<span class="go">--------------------------------------------------------------------------------</span>
<span class="go"># --- LINE 7 ---</span>

<span class="go">@jit</span>

<span class="go"># --- LINE 8 ---</span>

<span class="go">def f(a, b):</span>

<span class="go">    # --- LINE 9 ---</span>
<span class="go">    # label 0</span>
<span class="go">    #   a.1 = a  :: int64</span>
<span class="go">    #   del a</span>
<span class="go">    #   b.1 = b  :: int64</span>
<span class="go">    #   del b</span>
<span class="go">    #   $0.2 = global(float: &lt;class &#39;float&#39;&gt;)  :: Function(&lt;class &#39;float&#39;&gt;)</span>
<span class="go">    #   $0.4 = call $0.2(b.1, )  :: (int64,) -&gt; float64</span>
<span class="go">    #   del b.1</span>
<span class="go">    #   del $0.2</span>
<span class="go">    #   $0.5 = a.1 + $0.4  :: float64</span>
<span class="go">    #   del a.1</span>
<span class="go">    #   del $0.4</span>
<span class="go">    #   s = $0.5  :: float64</span>
<span class="go">    #   del $0.5</span>

<span class="go">    s = a + float(b)</span>

<span class="go">    # --- LINE 10 ---</span>
<span class="go">    #   $0.7 = cast(value=s)  :: float64</span>
<span class="go">    #   del s</span>
<span class="go">    #   return $0.7</span>

<span class="go">    return s</span>
</pre></div>
</div>
<p>Without trying to understand too much of the Numba intermediate representation,
it is still visible that all variables and temporary values have had their
types inferred properly: for example <em>a</em> has the type <code class="docutils literal"><span class="pre">int64</span></code>, <em>$0.5</em> has
the type <code class="docutils literal"><span class="pre">float64</span></code>, etc.</p>
<p>However, if <em>b</em> is passed as a string, compilation will fall back on object
mode as the float() constructor with a string is currently not supported
by Numba:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">inspect_types</span><span class="p">()</span>
<span class="go">[... snip annotations for other signatures, see above ...]</span>
<span class="go">================================================================================</span>
<span class="go">f (int64, str)</span>
<span class="go">--------------------------------------------------------------------------------</span>
<span class="go"># --- LINE 7 ---</span>

<span class="go">@jit</span>

<span class="go"># --- LINE 8 ---</span>

<span class="go">def f(a, b):</span>

<span class="go">    # --- LINE 9 ---</span>
<span class="go">    # label 0</span>
<span class="go">    #   a.1 = a  :: pyobject</span>
<span class="go">    #   del a</span>
<span class="go">    #   b.1 = b  :: pyobject</span>
<span class="go">    #   del b</span>
<span class="go">    #   $0.2 = global(float: &lt;class &#39;float&#39;&gt;)  :: pyobject</span>
<span class="go">    #   $0.4 = call $0.2(b.1, )  :: pyobject</span>
<span class="go">    #   del b.1</span>
<span class="go">    #   del $0.2</span>
<span class="go">    #   $0.5 = a.1 + $0.4  :: pyobject</span>
<span class="go">    #   del a.1</span>
<span class="go">    #   del $0.4</span>
<span class="go">    #   s = $0.5  :: pyobject</span>
<span class="go">    #   del $0.5</span>

<span class="go">    s = a + float(b)</span>

<span class="go">    # --- LINE 10 ---</span>
<span class="go">    #   $0.7 = cast(value=s)  :: pyobject</span>
<span class="go">    #   del s</span>
<span class="go">    #   return $0.7</span>

<span class="go">    return s</span>
</pre></div>
</div>
<p>Here we see that all variables end up typed as <code class="docutils literal"><span class="pre">pyobject</span></code>.  This means
that the function was compiled in object mode and values are passed
around as generic Python objects, without Numba trying to look into them
to reason about their raw values.  This is a situation you want to avoid
when caring about the speed of your code.</p>
<p>There are several ways of understanding why a function fails to
compile in nopython mode:</p>
<ul>
<li><p class="first">pass <em>nopython=True</em>, which will raise an error indicating what went wrong
(see above <a class="reference internal" href="#code-doesnt-compile"><span>My code doesn&#8217;t compile</span></a>);</p>
</li>
<li><p class="first">enable warnings by setting the <span class="target" id="index-0"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_WARNINGS"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_WARNINGS</span></code></a> environment
variable; for example with the <code class="docutils literal"><span class="pre">f()</span></code> function above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
<span class="go">example.py:7: NumbaWarning: Function &quot;f&quot; failed type inference: Internal error at &lt;numba.typeinfer.CallConstrain object at 0x7f6b8dd24550&gt;:</span>
<span class="go">float() only support for numbers</span>
<span class="go">File &quot;example.py&quot;, line 9</span>
<span class="go">  @jit</span>
<span class="go">example.py:7: NumbaWarning: Function &quot;f&quot; was compiled in object mode without forceobj=True.</span>
<span class="go">  @jit</span>
<span class="go">3.0</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="disabling-jit-compilation">
<h2>1.12.5. Disabling JIT compilation<a class="headerlink" href="#disabling-jit-compilation" title="Permalink to this headline">¶</a></h2>
<p>In order to debug code, it is possible to disable JIT compilation, which makes
the <code class="docutils literal"><span class="pre">jit</span></code> decorator (and the decorators <code class="docutils literal"><span class="pre">njit</span></code> and <code class="docutils literal"><span class="pre">autojit</span></code>) act as if
they perform no operation, and the invocation of decorated functions calls the
original Python function instead of a compiled version. This can be toggled by
setting the <span class="target" id="index-1"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_DISABLE_JIT"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_DISABLE_JIT</span></code></a> enviroment variable to <code class="docutils literal"><span class="pre">1</span></code>.</p>
<p>When this mode is enabled, the <code class="docutils literal"><span class="pre">vectorize</span></code> and <code class="docutils literal"><span class="pre">guvectorize</span></code> decorators will
still result in compilation of a ufunc, as there is no straightforward pure
Python implementation of these functions.</p>
</div>
<div class="section" id="debugging-jit-compiled-code-with-gdb">
<h2>1.12.6. Debugging JIT compiled code with GDB<a class="headerlink" href="#debugging-jit-compiled-code-with-gdb" title="Permalink to this headline">¶</a></h2>
<p>Setting the <code class="docutils literal"><span class="pre">debug</span></code> keyword argument in the <code class="docutils literal"><span class="pre">jit</span></code> decorator
(e.g. <code class="docutils literal"><span class="pre">&#64;jit(debug=True)</span></code>) enables the emission of debug info in the jitted
code.  To debug, GDB version 7.0 or above is required.  Currently, the following
debug info is available:</p>
<ul class="simple">
<li>Function name will be shown in the backtrace.  But, no type information.</li>
<li>Source location (filename and line number) is available.  For example,
user can set break point by the absolute filename and line number;
e.g. <code class="docutils literal"><span class="pre">break</span> <span class="pre">/path/to/myfile.py:6</span></code>.</li>
<li>Local variables in the current function can be shown with <code class="docutils literal"><span class="pre">info</span> <span class="pre">locals</span></code>.</li>
<li>Type of variable with <code class="docutils literal"><span class="pre">whatis</span> <span class="pre">myvar</span></code>.</li>
<li>Value of variable with <code class="docutils literal"><span class="pre">print</span> <span class="pre">myvar</span></code> or <code class="docutils literal"><span class="pre">display</span> <span class="pre">myvar</span></code>.<ul>
<li>Simple numeric types, i.e. int, float and double, are shown in their
native representation.  But, integers are assumed to be signed.</li>
<li>Other types are shown as sequence of bytes.</li>
</ul>
</li>
</ul>
<p>Known issues:</p>
<ul class="simple">
<li>Stepping depends heavily on optimization level.<ul>
<li>At full optimization (equivalent to O3), most of the variables are
optimized out.</li>
<li>With no optimization (e.g. <code class="docutils literal"><span class="pre">NUMBA_OPT=0</span></code>), source location jumps around
when stepping through the code.</li>
<li>At O1 optimization (e.g. <code class="docutils literal"><span class="pre">NUMBA_OPT=1</span></code>), stepping is stable but some
variables are optimized out.</li>
</ul>
</li>
<li>Memory consumption increases significantly with debug info enabled.
The compiler emits extra information (<a class="reference external" href="http://www.dwarfstd.org/">DWARF</a>)
along with the instructions.  The emitted object code can be 2x bigger with
debug info.</li>
</ul>
<p>Internal details:</p>
<ul>
<li><p class="first">Since Python semantics allow variables to bind to value of different types,
Numba internally creates multiple versions of the variable for each type.
So for code like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>         <span class="c"># type int</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">2.3</span>       <span class="c"># type float</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c"># type 3-tuple of int</span>
</pre></div>
</div>
<p>Each assignments will store to a different variable name.  In the debugger,
the variables will be <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">x$1</span></code> and <code class="docutils literal"><span class="pre">x$2</span></code>.  (In the Numba IR, they are
<code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">x.1</span></code> and <code class="docutils literal"><span class="pre">x.2</span></code>.)</p>
</li>
<li><p class="first">When debug is enabled, inlining of the function is disabled.</p>
</li>
</ul>
<div class="section" id="example-debug-usage">
<h3>1.12.6.1. Example debug usage<a class="headerlink" href="#example-debug-usage" title="Permalink to this headline">¶</a></h3>
<p>The python source:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mf">2.34</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

<span class="n">r</span><span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the terminal:</p>
<div class="highlight-none"><div class="highlight"><pre><span class="hll">$ NUMBA_OPT=1 gdb -q python
</span>Reading symbols from python...done.
(gdb) break /home/user/chk_debug.py:5
No source file named /home/user/chk_debug.py.
Make breakpoint pending on future shared library load? (y or [n]) y

Breakpoint 1 (/home/user/chk_debug.py:5) pending.
<span class="hll">(gdb) run chk_debug.py
</span>Starting program: /home/user/miniconda/bin/python chk_debug.py
...
Breakpoint 1, __main__::foo$241(long long) () at chk_debug.py:5
5         b = a + 1
<span class="hll">(gdb) n
</span>6         c = a * 2.34
<span class="hll">(gdb) bt
</span>#0  __main__::foo$241(long long) () at chk_debug.py:6
#1  0x00007ffff7fec47c in cpython::__main__::foo$241(long long) ()
#2  0x00007fffeb7976e2 in call_cfunc (locals=0x0, kws=0x0, args=0x7fffeb486198,
...
<span class="hll">(gdb) info locals
</span>a = 0
d = &lt;error reading variable d (DWARF-2 expression error: `DW_OP_stack_value&#39; operations must be used either alone or in conjunction with DW_OP_piece or DW_OP_bit_piece.)&gt;
c = 0
b = 124
<span class="hll">(gdb) whatis b
</span>type = i64
<span class="hll">(gdb) whatis d
</span>type = {i64, i64, double}
<span class="hll">(gdb) print b
</span>$2 = 124
</pre></div>
</div>
</div>
<div class="section" id="globally-override-debug-setting">
<h3>1.12.6.2. Globally override debug setting<a class="headerlink" href="#globally-override-debug-setting" title="Permalink to this headline">¶</a></h3>
<p>It is possible to enable debug for the full application by setting environment
variable <code class="docutils literal"><span class="pre">NUMBA_DEBUGINFO=1</span></code>.  This sets the default value of the <code class="docutils literal"><span class="pre">debug</span></code>
option in <code class="docutils literal"><span class="pre">jit</span></code>.  Debug can be turned off on individual functions by setting
<code class="docutils literal"><span class="pre">debug=False</span></code>.</p>
<p>Beware that enabling debug info significantly increases the memory consumption
for each compiled function.  For large application, this may cause out-of-memory
error.</p>
</div>
</div>
<div class="section" id="debugging-cuda-python-code">
<h2>1.12.7. Debugging CUDA Python code<a class="headerlink" href="#debugging-cuda-python-code" title="Permalink to this headline">¶</a></h2>
<div class="section" id="using-the-simulator">
<h3>1.12.7.1. Using the simulator<a class="headerlink" href="#using-the-simulator" title="Permalink to this headline">¶</a></h3>
<p>CUDA Python code can be run in the Python interpreter using the CUDA Simulator,
allowing it to be debugged with the Python debugger or with print statements. To
enable the CUDA simulator, set the environment variable
<span class="target" id="index-2"></span><a class="reference internal" href="../reference/envvars.html#envvar-NUMBA_ENABLE_CUDASIM"><code class="xref std std-envvar docutils literal"><span class="pre">NUMBA_ENABLE_CUDASIM</span></code></a> to 1. For more information on the CUDA Simulator,
see <a class="reference internal" href="../cuda/simulator.html#simulator"><span>the CUDA Simulator documentation</span></a>.</p>
</div>
<div class="section" id="debug-info">
<h3>1.12.7.2. Debug Info<a class="headerlink" href="#debug-info" title="Permalink to this headline">¶</a></h3>
<p>By setting the <code class="docutils literal"><span class="pre">debug</span></code> argument to <code class="docutils literal"><span class="pre">cuda.jit</span></code> to <code class="docutils literal"><span class="pre">True</span></code>
(<code class="docutils literal"><span class="pre">&#64;cuda.jit(debug=True)</span></code>), Numba will emit source location in the compiled
CUDA code.  Unlike the CPU target, only filename and line information are
available, but no variable type information is emitted.  The information
is sufficient to debug memory error with
<a class="reference external" href="http://docs.nvidia.com/cuda/cuda-memcheck/index.html">cuda-memcheck</a>.</p>
<p>For example, given the following cuda python code:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>

<span class="nd">@cuda.jit</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">foo</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">](</span><span class="n">arr</span><span class="p">)</span>   <span class="c"># more threads than array elements</span>
</pre></div>
</td></tr></table></div>
<p>We can use <code class="docutils literal"><span class="pre">cuda-memcheck</span></code> to find the memory error:</p>
<div class="highlight-none"><div class="highlight"><pre>$ cuda-memcheck python chk_cuda_debug.py
========= CUDA-MEMCHECK
========= Invalid __global__ write of size 8
=========     at 0x00000148 in /home/user/chk_cuda_debug.py:6:cudapy::__main__::foo$241(Array&lt;__int64, int=1, C, mutable, aligned&gt;)
=========     by thread (31,0,0) in block (0,0,0)
=========     Address 0x500a600f8 is out of bounds
...
=========
========= Invalid __global__ write of size 8
=========     at 0x00000148 in /home/user/chk_cuda_debug.py:6:cudapy::__main__::foo$241(Array&lt;__int64, int=1, C, mutable, aligned&gt;)
=========     by thread (30,0,0) in block (0,0,0)
=========     Address 0x500a600f0 is out of bounds
...
</pre></div>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Anaconda, Inc..<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>