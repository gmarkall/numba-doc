

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Types and Variables &mdash; numba 0.7.1-44-g53a9263-dirty documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.1-44-g53a9263-dirty',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="numba 0.7.1-44-g53a9263-dirty documentation" href="../index.html" />
    <link rel="next" title="Python Functionality" href="pythonstuff.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pythonstuff.html" title="Python Functionality"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">numba 0.7.1-44-g53a9263-dirty documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="types-and-variables">
<span id="types"></span><h1>Types and Variables<a class="headerlink" href="#types-and-variables" title="Permalink to this headline">¶</a></h1>
<p>Types can be used in Numba to compile functions directly with the <tt class="docutils literal"><span class="pre">jit</span></tt>
function, and they can be used to declare local variables in both <tt class="docutils literal"><span class="pre">jit</span></tt>
and <tt class="docutils literal"><span class="pre">autojit</span></tt> functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@autojit</span><span class="p">(</span><span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">double</span><span class="p">[:,</span> <span class="p">:],</span> <span class="n">scalar1</span><span class="o">=</span><span class="n">double</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">scalar1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c"># scalar is declared double</span>
    <span class="n">scalar2</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Of course, declaring types in this example is unnecessary since the type
inferencer knows the input type of <tt class="docutils literal"><span class="pre">array</span></tt>, and hence knows the type
of <tt class="docutils literal"><span class="pre">array[i,</span> <span class="pre">j]</span></tt> to be the dtype of <tt class="docutils literal"><span class="pre">array</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Type declarations or casts can be useful in cases where the
type inferencer doesn&#8217;t know the type, or if you want to
override the type inferencer&#8217;s rules (e.g. force 32-bit floating
point precision).</p>
</div>
<p>Cases where the type inferencer doesn&#8217;t know the type is often when you call
a Python function or method that is not a numba function and numba doesn&#8217;t
otherwise recognize.</p>
<p>Numba allows you to obtain the type of a expression or variable through
the typeof function in a Numba function. This type can then be used for
instance to cast other values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">type</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">typeof</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>When used outside of a Numba function, it returns the type the type inferencer
would infer for that value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">typeof</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">double</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">typeof</span><span class="p">(</span><span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">complex128</span>
</pre></div>
</div>
<div class="section" id="variables-declared-in-locals">
<span id="variables"></span><h2>Variables declared in Locals<a class="headerlink" href="#variables-declared-in-locals" title="Permalink to this headline">¶</a></h2>
<p>Variables declared in the <tt class="docutils literal"><span class="pre">locals</span></tt> dict have a single type throughout
the entire function. However, any variable not declared in locals can
assume different types, just like in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">variable_ressign</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="n">var</span> <span class="o">=</span> <span class="s">&quot;world&quot;</span>
</pre></div>
</div>
<p>However, there are some restrictions, namely that variables must have
a unifyable type at control flow merge points. For example, the following
code will not compile:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">incompatible_types</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span>

    <span class="k">return</span> <span class="n">x</span>        <span class="c"># ERROR! Inconsistent type for x!</span>
</pre></div>
</div>
<p>This code is invalid because strings and integers are not compatible.
However, if we do not read <tt class="docutils literal"><span class="pre">x</span></tt> after the if block, the code will
compile fine, since it does not need to unify the type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">compatible_types</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>The same goes for loop carried dependencies and variables escaping loops, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">incompatible_types2</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">x</span>     <span class="c"># ERROR! Inconsistent type for x!</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">x</span>

<span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">incompatible_types3</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">print</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">x</span>        <span class="c"># ERROR! Inconsistent type for x if N &lt;= 0</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-aggregate-types">
<h2>Specifying Aggregate Types<a class="headerlink" href="#specifying-aggregate-types" title="Permalink to this headline">¶</a></h2>
<p>The numba type system goes far beyond the simple scalars (e.g. <tt class="docutils literal"><span class="pre">ushort</span></tt>)
and arrays (e.g. <tt class="docutils literal"><span class="pre">float32[:,</span> <span class="pre">:]</span></tt>) that we had previously covered.
We can also define structs, pointers, functions and strings.</p>
<div class="section" id="structs-records">
<span id="structtypes"></span><h3>Structs/Records<a class="headerlink" href="#structs-records" title="Permalink to this headline">¶</a></h3>
<p>Structs can be either aligned or unaligned (packed). Aligned structs are
the recommended default. Structs can be ordered, in case we need to interface
with non-numba code or NumPy record arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numba</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">struct</span><span class="p">([(</span><span class="s">&#39;first_field&#39;</span><span class="p">,</span> <span class="n">double</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;second_field&#39;</span><span class="p">,</span> <span class="n">float_</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;MyStruct&#39;</span><span class="p">)</span>
<span class="go">struct MyStruct { double first_field, float second_field }</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">name</span></tt> argument is optional, but useful for debugging purposes and code clarity.
An unordered struct can be created using keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">first_field</span><span class="o">=</span><span class="n">double</span><span class="p">,</span> <span class="n">second_field</span><span class="o">=</span><span class="n">float_</span><span class="p">)</span>
<span class="go">struct { double first_field, float second_field }</span>
</pre></div>
</div>
<p>Unordered structs order their fields by the size of their data type, and secondarily on
the field name. Since <tt class="docutils literal"><span class="pre">sizeof(double)</span> <span class="pre">&gt;</span> <span class="pre">sizeof(float)</span></tt>,
<tt class="docutils literal"><span class="pre">first_field</span></tt> precedes <tt class="docutils literal"><span class="pre">second_field</span></tt> in the struct.</p>
<p>Inferface:</p>
<dl class="class">
<dt id="numba.struct">
<em class="property">class </em><tt class="descclassname">numba.</tt><tt class="descname">struct</tt><big>(</big><em>fields</em>, <em>name=None</em>, <em>packed=False</em><big>)</big><a class="headerlink" href="#numba.struct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="numba.struct.name">
<tt class="descname">name</tt><a class="headerlink" href="#numba.struct.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Struct name or None</p>
</dd></dl>

<dl class="attribute">
<dt id="numba.struct.packed">
<tt class="descname">packed</tt><a class="headerlink" href="#numba.struct.packed" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the fields of the structs are aligned or packed.</p>
</dd></dl>

<dl class="attribute">
<dt id="numba.struct.fields">
<tt class="descname">fields</tt><a class="headerlink" href="#numba.struct.fields" title="Permalink to this definition">¶</a></dt>
<dd><p>List of 2-tuples in the order of the fields: <tt class="docutils literal"><span class="pre">[(field_name,</span> <span class="pre">field_type)]</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="numba.struct.fielddict">
<tt class="descname">fielddict</tt><a class="headerlink" href="#numba.struct.fielddict" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict mapping field names to field types.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pointers">
<span id="pointertypes"></span><h3>Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h3>
<p>Each type has a <tt class="docutils literal"><span class="pre">pointer</span></tt> method that allows one to create a pointer type with that type
as the base type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">double</span><span class="o">.</span><span class="n">pointer</span><span class="p">()</span>
<span class="go">double *</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">first_field</span><span class="o">=</span><span class="n">double</span><span class="p">,</span> <span class="n">second_field</span><span class="o">=</span><span class="n">float_</span><span class="p">)</span><span class="o">.</span><span class="n">pointer</span><span class="p">()</span>
<span class="go">struct { double first_field, float second_field } *</span>
</pre></div>
</div>
<p>Pointer support is still somewhat immature, but in the future it is likely ctypes and CFFI pointers
will be supported, and possibly pointers returned by Cython cdef functions or methods. Currently
pointers can be obtained from integers by using the <tt class="docutils literal"><span class="pre">Py_uintptr_t</span></tt> type, which is an integer large
enough to store any pointer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">voidp</span> <span class="o">=</span> <span class="n">void</span><span class="o">.</span><span class="n">pointer</span><span class="p">()</span>

<span class="nd">@autojit</span>
<span class="k">def</span> <span class="nf">test_compare_null_attribute</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">voidp</span><span class="p">(</span><span class="n">Py_uintptr_t</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">numba</span><span class="o">.</span><span class="n">NULL</span>
</pre></div>
</div>
<p>Note how we declare the type <tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt> outside the function, since numba does not yet recognize
<tt class="docutils literal"><span class="pre">void.pointer()</span></tt> inside a numba function as the type which it constitutes (it is also valid
to pass <tt class="docutils literal"><span class="pre">voidp</span></tt> in as an argument to the function).</p>
<p>Note also how we use numba.NULL, which represents the C NULL pointer, and may be compared to a
pointer of any type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Type declarations inside numba functions itself is still immature, but at any time
can types be passed into numba functions, or accessed as module attributes or globals.</p>
</div>
<p>Inferface:</p>
<dl class="class">
<dt id="PointerType">
<em class="property">class </em><tt class="descname">PointerType</tt><a class="headerlink" href="#PointerType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PointerType.base_type">
<tt class="descname">base_type</tt><a class="headerlink" href="#PointerType.base_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Base type of the pointer, i.e. what type after dereferencing the pointer.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<span id="functiontypes"></span><h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>As we have already seen, functions can be easily specified by calling types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">void</span><span class="p">(</span><span class="n">double</span><span class="p">)</span>
<span class="go">void (*)(double)</span>
</pre></div>
</div>
<p>Function types can also be created through the <tt class="docutils literal"><span class="pre">FunctionType</span></tt> class exposed in the <tt class="docutils literal"><span class="pre">numba</span></tt> namespace.
For instance, this allows you to omit a return type, and to have the type inferencer infer the return
type automatically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="go">None (*foo)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numba</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="n">void</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">is_vararg</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">void (*foo )(...)</span>
</pre></div>
</div>
<p>Inferface:</p>
<dl class="class">
<dt id="numba.FunctionType">
<em class="property">class </em><tt class="descclassname">numba.</tt><tt class="descname">FunctionType</tt><big>(</big><em>return_type</em>, <em>args</em>, <em>name=None</em>, <em>is_vararg=False</em><big>)</big><a class="headerlink" href="#numba.FunctionType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="numba.FunctionType.return_type">
<tt class="descname">return_type</tt><a class="headerlink" href="#numba.FunctionType.return_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Base type of the pointer, i.e. the type after dereferencing the pointer.</p>
</dd></dl>

<dl class="attribute">
<dt id="numba.FunctionType.args">
<tt class="descname">args</tt><a class="headerlink" href="#numba.FunctionType.args" title="Permalink to this definition">¶</a></dt>
<dd><p>The argument types.</p>
</dd></dl>

<dl class="attribute">
<dt id="numba.FunctionType.is_vararg">
<tt class="descname">is_vararg</tt><a class="headerlink" href="#numba.FunctionType.is_vararg" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether it takes a variable number of arguments (compatible with C ABI).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="strings">
<span id="stringtypes"></span><h3>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">¶</a></h3>
<p>Strings may be specified through the <tt class="docutils literal"><span class="pre">c_string_type</span></tt> type, a name which is subject to change in the future.
This does not handle unicode, and is equivalent to <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c_string_type</span>
<span class="go">const char *</span>
</pre></div>
</div>
</div>
<div class="section" id="c-arrays">
<h3>C Arrays<a class="headerlink" href="#c-arrays" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="templates">
<span id="id1"></span><h2>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h2>
<p>Templates allow the user to deal with types in a more abstract manner, which is useful when concrete types
are not available at the time of specification. This can be used in conjuction with the <tt class="docutils literal"><span class="pre">autojit</span></tt> decorator,
which determines the types based on the argument input values. For example, this allows one to access the
base type of a pointer, or the dtype of an array to declare variable types or perform casts:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">template</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">)</span> <span class="c"># the name argument is optional</span>

<span class="nd">@autojit</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:]),</span> <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="n">T</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_templates</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">scalar</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">scalar</span>
</pre></div>
</div>
<p>This specifies that the function takes a 2D array of some dtype <tt class="docutils literal"><span class="pre">T</span></tt>, and returns a value of type <tt class="docutils literal"><span class="pre">T</span></tt>.
The local variable <tt class="docutils literal"><span class="pre">scalar</span></tt> also assumes type <tt class="docutils literal"><span class="pre">T</span></tt>. In this example we could just as well have relied
on the type inferencer, but we have gained a constraint on the input type <tt class="docutils literal"><span class="pre">array</span></tt>, namely that it is
a 2D array.</p>
<p>We can loosen the constaint a bit, and for instance allow any N-dimensional array to be passed in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">template</span><span class="p">()</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dtype</span>

<span class="nd">@autojit</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_template_generic</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">scalar</span> <span class="o">=</span> <span class="n">array</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">scalar</span>
</pre></div>
</div>
<p>We can do a similar thing with pointers by accessing the <tt class="docutils literal"><span class="pre">base_type</span></tt> attribute, or with struct fields
by indexing <tt class="docutils literal"><span class="pre">fielddict</span></tt>. E.g. we could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pointer_type</span> <span class="o">=</span> <span class="n">T2</span><span class="o">.</span><span class="n">pointer</span><span class="p">()</span>
<span class="n">struct_type</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">T1</span><span class="p">[:],</span> <span class="n">pointer</span><span class="o">=</span><span class="n">pointer_type</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">T1</span><span class="p">(</span><span class="n">pointer_type</span><span class="p">,</span> <span class="n">T3</span><span class="p">))</span>

<span class="nd">@autojit</span><span class="p">(</span><span class="n">void</span><span class="p">(</span><span class="n">struct_type</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">process_struct</span><span class="p">(</span><span class="n">struct</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">T3</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pointer</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p>as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cast_type</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">fielddict</span><span class="p">[</span><span class="s">&quot;func&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># Get at the T3 type in the example above</span>

<span class="nd">@autojit</span><span class="p">(</span><span class="n">void</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">process_struct</span><span class="p">(</span><span class="n">struct</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">cast_type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pointer</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Types and Variables</a><ul>
<li><a class="reference internal" href="#variables-declared-in-locals">Variables declared in Locals</a></li>
<li><a class="reference internal" href="#specifying-aggregate-types">Specifying Aggregate Types</a><ul>
<li><a class="reference internal" href="#structs-records">Structs/Records</a></li>
<li><a class="reference internal" href="#pointers">Pointers</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#strings">Strings</a></li>
<li><a class="reference internal" href="#c-arrays">C Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#templates">Templates</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="examples.html"
                        title="previous chapter">Examples</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pythonstuff.html"
                        title="next chapter">Python Functionality</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/doc/types.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pythonstuff.html" title="Python Functionality"
             >next</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             >previous</a> |</li>
        <li><a href="../index.html">numba 0.7.1-44-g53a9263-dirty documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Continuum Analytics.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>